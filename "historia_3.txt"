 1/1:
import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, delta):
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,int(Fs/2))

plt.plot(czestosci, fourier(kor, czestosci), color = "green")
 1/2: import saffy
 2/1: import saffy
 2/2:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
sig = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
 2/3:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
sig = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
 2/4:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
sig = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
EEG.extract_channels([ 'Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
 2/5:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EEG = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
EEG.extract_channels([ 'Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
 2/6:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EE = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
 2/7:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EE = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
EEG.extract_channels(['Fp1', 'P3'])
 2/8:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EE = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
 2/9:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EEG = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
2/10:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EEG = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG
2/11:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EEG = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.welch_mean_spectrum()
2/12:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EEG = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.copy('pre')
2/13:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EEG = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])

PRE_EEG = EEG.copy('pre')


PRE_EEG.welch_mean_spectrum()
2/14:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EEG = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.extract_channels(['C3', 'C4', 'trig'])

EEG.set_tags_from_channel('trig')

EEG.remove_channel('trig')

EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

PRE_EEG = EEG.copy('pre')
PRE_EEG.set_epochs_from_tags(-4, -2)

PRE_EEG.welch_mean_spectrum()

POST_EEG = EEG.copy('post')
POST_EEG.set_epochs_from_tags(0.5, 2.5)

POST_EEG.welch_mean_spectrum()
2/15:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EEG = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.extract_channels(['C3', 'C4'])

EEG.set_tags_from_channel('trig')

EEG.remove_channel('trig')

EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

PRE_EEG = EEG.copy('pre')
PRE_EEG.set_epochs_from_tags(-4, -2)

PRE_EEG.welch_mean_spectrum()

POST_EEG = EEG.copy('post')
POST_EEG.set_epochs_from_tags(0.5, 2.5)

POST_EEG.welch_mean_spectrum()
2/16: !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master
2/17: !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master --user
2/18: import saffy
2/19:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EEG = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.extract_channels(['C3', 'C4'])

EEG.set_tags_from_channel('trig')

EEG.remove_channel('trig')

EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

PRE_EEG = EEG.copy('pre')
PRE_EEG.set_epochs_from_tags(-4, -2)

PRE_EEG.welch_mean_spectrum()

POST_EEG = EEG.copy('post')
POST_EEG.set_epochs_from_tags(0.5, 2.5)

POST_EEG.welch_mean_spectrum()
2/20:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EEG = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.extract_channels(['C3', 'C4'])

#EEG.set_tags_from_channel('trig')

#EEG.remove_channel('trig')

EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

PRE_EEG = EEG.copy('pre')
PRE_EEG.set_epochs_from_tags(-4, -2)

PRE_EEG.welch_mean_spectrum()

POST_EEG = EEG.copy('post')
POST_EEG.set_epochs_from_tags(0.5, 2.5)

POST_EEG.welch_mean_spectrum()
2/21:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete.raw','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1.raw'}
EEG = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.extract_channels(['T6'])



EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

PRE_EEG = EEG.copy('pre')
PRE_EEG.set_epochs_from_tags(-4, -2)

PRE_EEG.welch_mean_spectrum()

POST_EEG = EEG.copy('post')
POST_EEG.set_epochs_from_tags(0.5, 2.5)

POST_EEG.welch_mean_spectrum()
2/22:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}
EEG = saffy.SignalManager(filename=file_names['oczy_zamkniete'])
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.extract_channels(['T6'])



EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

PRE_EEG = EEG.copy('pre')
PRE_EEG.set_epochs_from_tags(-4, -2)

PRE_EEG.welch_mean_spectrum()

POST_EEG = EEG.copy('post')
POST_EEG.set_epochs_from_tags(0.5, 2.5)

POST_EEG.welch_mean_spectrum()
2/23:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}
EEG = saffy.SignalManager(filename=file_names['oczy_otwarte'])
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.extract_channels(['T6'])



EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

PRE_EEG = EEG.copy('pre')
PRE_EEG.set_epochs_from_tags(-4, -2)

PRE_EEG.welch_mean_spectrum()

POST_EEG = EEG.copy('post')
POST_EEG.set_epochs_from_tags(0.5, 2.5)

POST_EEG.welch_mean_spectrum()
2/24:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.extract_channels(['T6'])



EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

PRE_EEG = EEG.copy('pre')
PRE_EEG.set_epochs_from_tags(-4, -2)

PRE_EEG.welch_mean_spectrum()

POST_EEG = EEG.copy('post')
POST_EEG.set_epochs_from_tags(0.5, 2.5)

POST_EEG.welch_mean_spectrum()
2/25:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
2/26:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.extract_channels(('Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'))
2/27:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.extract_channels(np.array('Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'))
2/28:
import saffy
import numpy as np
2/29:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.extract_channels(np.array(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2']))
2/30:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
2/31:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
 3/1:
import saffy
import numpy as np
 3/2:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
 3/3:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
 3/4:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}
EEG = saffy.SignalManager(filename='/mateusz_oczy_zamkniete')
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
 3/5:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
 3/6:
import saffy
import numpy as np
 3/7:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
 3/8: !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master --user
 3/9:
import saffy
import numpy as np
3/10:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
3/11:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
3/12:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
#EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
3/13:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
#EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.channem_names
3/14:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
#EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.channel_names
 4/1:
import saffy
import numpy as np
 4/2:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
#EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.channel_names
 4/3:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.channel_names
 4/4:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
# EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
EEG.channel_names
 4/5:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.extract_channels([ 'O2','O1'])
# EEG.channel_names
 4/6:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.extract_channels('O2','O1')
# EEG.channel_names
 4/7:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.extract_channels(['O2','O1'])
# EEG.channel_names
 4/8:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.extract_channels([['O2','O1']])
# EEG.channel_names
 4/9:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.extract_channels(['O2','O1'])
# EEG.channel_names
4/10:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
# EEG.extract_channels(['O2','O1'])
# EEG.channel_names
EEG.history
4/11:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
# EEG.extract_channels(['O2','O1'])
EEG.channel_names
EEG.history
4/12:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
# EEG.extract_channels(['O2','O1'])
EEG.channel_names
EEG.history
4/13:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
# EEG.extract_channels(['O2','O1'])
EEG.channel_names
# EEG.history
4/14:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
# EEG.extract_channels(['O2','O1'])
EEG.channel_names
# EEG.history
4/15:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
# EEG.extract_channels(['O2','O1'])
# EEG.channel_names
EEG.history
4/16:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.extract_channels(['O2','O1'])
# EEG.channel_names
EEG.history
4/17:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
# EEG.extract_channels(['O2','O1'])
# EEG.channel_names
EEG.history
4/18:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
channel_ids = [
    EEG.channel_names.index(channel_name)for channel_name in ['O1'] 
]
# EEG.extract_channels(['O2','O1'])
# EEG.channel_names
# EEG.history
4/19:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
channel_ids = [
    EEG.channel_names.index(channel_name)for channel_name in ['O1'] 
]
EEG.extract_channels(['O2','O1'])
# EEG.channel_names
# EEG.history
4/20:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
channel_ids = [
    EEG.channel_names.index(channel_name)for channel_name in ['O1'] 
]
# EEG.extract_channels(['O2','O1'])
# EEG.channel_names
# EEG.history
4/21:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
channel_ids = [
    EEG.channel_names.index(channel_name)for channel_name in ['O1'] 
]
print(channel_ids)
# EEG.extract_channels(['O2','O1'])
# EEG.channel_names
# EEG.history
4/22:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
channel_ids = [
    EEG.channel_names.index(channel_name)for channel_name in ['O1'] 
]
print(channel_ids)
# EEG.extract_channels(['O2','O1'])
# EEG.channel_names
# EEG.history
EEG.data = EEG.data[:, channel_ids, :]
EEG.num_channels = len(channel_ids)
EEG.channel_names = list(filter(
    lambda x: EEG.channel_names.index(x) in channel_ids,
    EEG.channel_names
))
4/23:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
channel_ids = [
    EEG.channel_names.index(channel_name)for channel_name in ['O1'] 
]
print(channel_ids)
# EEG.extract_channels(['O2','O1'])
# EEG.channel_names
# EEG.history
# EEG.data = EEG.data[:, channel_ids, :]
# EEG.num_channels = len(channel_ids)
# EEG.channel_names = list(filter(
#     lambda x: EEG.channel_names.index(x) in channel_ids,
#     EEG.channel_names
# ))
print(EEG.data.shape)
4/24:
file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
channel_ids = [
    EEG.channel_names.index(channel_name)for channel_name in ['O1'] 
]
print(channel_ids)
# EEG.extract_channels(['O2','O1'])
# EEG.channel_names
# EEG.history
# EEG.data = EEG.data[:, channel_ids, :]
# EEG.num_channels = len(channel_ids)
# EEG.channel_names = list(filter(
#     lambda x: EEG.channel_names.index(x) in channel_ids,
#     EEG.channel_names
# ))
print(EEG.data.shape)
print(type(EEG.data))
4/25:
# file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
channel_ids = [
    EEG.channel_names.index(channel_name)for channel_name in ['O1'] 
]
print(channel_ids)
# EEG.extract_channels(['O2','O1'])
# EEG.channel_names
# EEG.history
# EEG.data = EEG.data[:, channel_ids, :]
# EEG.num_channels = len(channel_ids)
# EEG.channel_names = list(filter(
#     lambda x: EEG.channel_names.index(x) in channel_ids,
#     EEG.channel_names
# ))
print(EEG.data.shape)
print(type(EEG.data))
4/26:
# file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

# EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
# channel_ids = [
#     EEG.channel_names.index(channel_name)for channel_name in ['O1'] 
# ]
# print(channel_ids)
# EEG.extract_channels(['O2','O1'])
# EEG.channel_names
# EEG.history
# EEG.data = EEG.data[:, channel_ids, :]
# EEG.num_channels = len(channel_ids)
# EEG.channel_names = list(filter(
#     lambda x: EEG.channel_names.index(x) in channel_ids,
#     EEG.channel_names
# ))
# print(EEG.data.shape)
# print(type(EEG.data))
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['O2','O1'])
4/27:
# file_names = {'oczy_otwarte':'mateusz_oczy_szeroko_zamkniete','oczy_zamkniete':'mateusz_oczy_zamkniete','zadania':'mateusz_try1'}

# EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
# channel_ids = [
#     EEG.channel_names.index(channel_name)for channel_name in ['O1'] 
# ]
# print(channel_ids)
# EEG.extract_channels(['O2','O1'])
# EEG.channel_names
# EEG.history
# EEG.data = EEG.data[:, channel_ids, :]
# EEG.num_channels = len(channel_ids)
# EEG.channel_names = list(filter(
#     lambda x: EEG.channel_names.index(x) in channel_ids,
#     EEG.channel_names
# ))
# print(EEG.data.shape)
# print(type(EEG.data))
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
4/28:
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
4/29:
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])


PRE_EEG = EEG.copy('pre')
PRE_EEG
4/30:
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])

print(EEG)
4/31:
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])

print(EEG.data)
4/32:
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])

print(EEG.data.shape)
4/33:
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])

print(EEG.data[:,1,1])
4/34:
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])

print(EEG.data[:,1,0])
4/35:
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])

print(EEG.data['Fp1'])
4/36:
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])

print(EEG.['Fp1'])
4/37:
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])

print(EEG['Fp1'])
4/38:
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])

print(EEG.data[:,0,0])
4/39:
EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])

print(EEG.data[:,0,0])
4/40:
EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.shape)
print(EEG.data[:,0,0])
4/41:
EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
print(EEG.data[:,0,0])
4/42:
EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.data = np.reshape(EEG.data, (*EEG.data.shape, 1))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
print(EEG.data[0,:,0])
4/43:
EEG = saffy.SignalManager(filename='mateusz_oczy_szeroko_zamkniete')
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
print(EEG.data[0,:,0])
4/44:
EEG = saffy.SignalManager(filename='mateusz_oczy_zamkniete')
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
print(EEG.data[0,:,0])
4/45:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
print(EEG.data[0,:,0])
4/46:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
print(EEG.data[0,:,0])
EEG.welch_mean_spectrum()
4/47:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
print(EEG.data[0,:,0])
EEG..welch_mean_spectrum()
4/48:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
print(EEG.data[0,:,0])
EEG.welch_mean_spectrum()
4/49:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
print(EEG.data[0,:,0])
EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.welch_mean_spectrum()
4/50:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
print(EEG.data[0,:,0])
EEG.butter_highpass_filter(cutoff=1, order=2, fs=EEG.fs)
EEG.welch_mean_spectrum()
4/51:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
print(EEG.data[0,:,0])
4/52:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
4/53:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
4/54:
import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, delta):
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,int(Fs/2))

plt.plot(czestosci, fourier(kor, czestosci), color = "green")
4/55:
import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, delta): #delta - ile przesunięć
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,int(Fs/2))

plt.plot(czestosci, fourier(kor, czestosci), color = "green")
4/56:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
EEG_KOR = np.array([7,7])
print(EEG_KOR.shape)
# for k in EEG_KOR[0]:
#     for
4/57:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
EEG_KOR = np.array(7,7)
print(EEG_KOR.shape)
# for k in EEG_KOR[0]:
#     for
4/58:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
EEG_KOR = np.array((7,7)
print(EEG_KOR.shape)
# for k in EEG_KOR[0]:
#     for
4/59:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
EEG_KOR = np.array((7,7)
print(EEG_KOR.shape)
# for k in EEG_KOR[0]:
#     for
4/60:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
EEG_KOR = np.array((7,7))
print(EEG_KOR.shape)
# for k in EEG_KOR[0]:
#     for
4/61:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
EEG_KOR = np.array(7,7)
print(EEG_KOR.shape)
# for k in EEG_KOR[0]:
#     for
4/62:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
EEG_KOR = np.zeros([7,7])
print(EEG_KOR.shape)
# for k in EEG_KOR[0]:
#     for
4/63:
import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,int(Fs/2))

plt.plot(czestosci, fourier(kor, czestosci), color = "green")
4/64:
import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,int(Fs/2))

plt.plot(czestosci, fourier(kor, czestosci), color = "green")
4/65: # !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master --user
4/66:
import saffy
import numpy as np
import matplotlib.pyplot as plt
4/67:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.zeros((EEG_2D.shape[0],EEG_2D.shape[0]))

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        plt.plot(KORELACJE[i,j])
        plt.show()
4/68:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]))

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        plt.plot(KORELACJE[i,j])
        plt.show()
4/69:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]), dtype='void')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        plt.plot(KORELACJE[i,j])
        plt.show()
4/70:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        plt.plot(KORELACJE[i,j])
        plt.show()
4/71: !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master --user
4/72:
import saffy
import numpy as np
import matplotlib.pyplot as plt
4/73:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        plt.plot(KORELACJE[i,j])
        plt.show()
4/74: %matplotlib.pyplot
4/75: %matplotlib
4/76:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        plt.plot(KORELACJE[i,j])
        plt.show()
4/77: %matplotlib.inline
4/78:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        plt.plot(KORELACJE[i,j])
        plt.show()
4/79:
import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs

plt.plot(czestosci, fourier(kor, czestosci), color = "green")
4/80:
import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)

plt.plot(czestosci, fourier(kor, czestosci), color = "green")
4/81:
import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
plt.plot(kor)
plt.show()
plt.plot(czestosci, fourier(kor, czestosci), color = "green")
4/82:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        plt.plot(KORELACJE[i,j])
        plt.show()
4/83:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        
plt.plot(KORELACJE[1,1])
plt.show()
4/84:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        
plt.plot(KORELACJE[1,2])
plt.show()
4/85:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        
plt.plot(KORELACJE[1,2])
plt.show()
4/86: %matplotlib inline
4/87:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        
plt.plot(KORELACJE[1,2])
plt.show()
4/88:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
plt.figure()        
plt.plot(KORELACJE[1,2])
plt.show()
4/89:
import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
4/90:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
      
plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/91:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:1000] , EEG_2D[j,:1000] , EEG.fs)
      
plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/92:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:1000] , EEG_2D[j,:1000] , EEG.fs)
      
plt.plot(KORELACJE[1,2])
# plt.plot(KORELACJE[0,0])
plt.show()
4/93:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.data.shape)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:1000] , EEG_2D[j,:1000] , EEG.fs)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/94:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:1000] , EEG_2D[j,:1000] , EEG.fs)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/95:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:1000] , EEG_2D[j,:1000] , EEG.fs*5)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/96:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:1000] , EEG_2D[j,:1000] , 10*EEG.fs)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/97:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:1000] , EEG_2D[j,:1000] , EEG.fs*10)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/98:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:1000] , EEG_2D[j,:1000] , EEG.fs/10)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/99:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:1000] , EEG_2D[j,:1000] , EEG.fs/5)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/100:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:1000] , EEG_2D[j,:1000] , EEG.fs*3)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/101:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:100] , EEG_2D[j,:100] , EEG.fs*3)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/102:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs*3)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/103:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])

KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs/10)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/104:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:])
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

# for i in range(EEG_2D.shape[0]):
#     for j in range(EEG_2D.shape[0]):
#         KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
      
# # plt.plot(KORELACJE[1,2])
# plt.plot(KORELACJE[0,0])
# plt.show()
4/105:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:1024])
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

# for i in range(EEG_2D.shape[0]):
#     for j in range(EEG_2D.shape[0]):
#         KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
      
# # plt.plot(KORELACJE[1,2])
# plt.plot(KORELACJE[0,0])
# plt.show()
4/106:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]):
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:1024])
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

# for i in range(EEG_2D.shape[0]):
#     for j in range(EEG_2D.shape[0]):
#         KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
      
# # plt.plot(KORELACJE[1,2])
# plt.plot(KORELACJE[0,0])
# plt.show()
4/107:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]):
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:1024])
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/108:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]):
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
      
# plt.plot(KORELACJE[1,2])
plt.plot(KORELACJE[0,0])
plt.show()
4/109:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]):
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        
plt.plot(KORELACJE[1,2])
plt.show()
plt.plot(KORELACJE[0,0])
plt.show()
4/110:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]):
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1=plt.subplot(EEG_2D.shape[0][-1], EEG_2D.shape[0][-1], i+j)
        ax1.plot(KORELACJE[i,j])
        plt.show()

# plt.plot(KORELACJE[1,2])
# plt.show()
# plt.plot(KORELACJE[0,0])
# plt.show()
4/111:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]):
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1=plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], i+j)
        ax1.plot(KORELACJE[i,j])
        plt.show()

# plt.plot(KORELACJE[1,2])
# plt.show()
# plt.plot(KORELACJE[0,0])
# plt.show()
4/112:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]):
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1=plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], i+j+1)
        ax1.plot(KORELACJE[i,j])
        plt.show()

# plt.plot(KORELACJE[1,2])
# plt.show()
# plt.plot(KORELACJE[0,0])
# plt.show()
4/113:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]):
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], i+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()

# plt.plot(KORELACJE[1,2])
# plt.show()
# plt.plot(KORELACJE[0,0])
# plt.show()
4/114:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]):
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

fig = figure(figsize = 20,20)
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], i+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()

# plt.plot(KORELACJE[1,2])
# plt.show()
# plt.plot(KORELACJE[0,0])
# plt.show()
4/115:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]):
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

fig = figure(figsize = (20,20))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], i+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()

# plt.plot(KORELACJE[1,2])
# plt.show()
# plt.plot(KORELACJE[0,0])
# plt.show()
4/116:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]):
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]
print(EEG_2D.data.shape)
# EEG_KOR = np.zeros([7,7])
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

fig = plt.figure(figsize = (20,20))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], i+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()

# plt.plot(KORELACJE[1,2])
# plt.show()
# plt.plot(KORELACJE[0,0])
# plt.show()
4/117:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

fig = plt.figure(figsize = (20,20))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], i+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()

# plt.plot(KORELACJE[1,2])
# plt.show()
# plt.plot(KORELACJE[0,0])
# plt.show()
4/118:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

fig = plt.figure(figsize = (20,20))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], i*j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()

# plt.plot(KORELACJE[1,2])
# plt.show()
# plt.plot(KORELACJE[0,0])
# plt.show()
4/119:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

fig = plt.figure(figsize = (20,20))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i+1)*j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()

# plt.plot(KORELACJE[1,2])
# plt.show()
# plt.plot(KORELACJE[0,0])
# plt.show()
4/120:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

fig = plt.figure(figsize = (20,20))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*7)+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()

# plt.plot(KORELACJE[1,2])
# plt.show()
# plt.plot(KORELACJE[0,0])
# plt.show()
4/121:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

fig = plt.figure(figsize = (30,30))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*7)+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()

# plt.plot(KORELACJE[1,2])
# plt.show()
# plt.plot(KORELACJE[0,0])
# plt.show()
4/122:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*7)+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/123:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , EEG.fs*5)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*7)+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/124:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0]),dtype='object_')

fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , len(EEG_2D[j,:]))
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*7)+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/125:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1)

fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = np.correlate(EEG_2D[i,:,:] , EEG_2D[j,:,:] , "full")
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/126:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))

fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = np.correlate(EEG_2D[i,:,:] , EEG_2D[j,:,:] , "full")
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/127:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))

fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = np.correlate(EEG_2D[i,:] , EEG_2D[j,:] , "full")
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/128:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))

fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , 1000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/129:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],1000))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , 1000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/130:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],1001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , 1000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/131:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],1001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , 1000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        ax1.plot(KORELACJE[i,j] , ylim = [-1,1])
plt.show()
4/132:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],1001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , 1000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/133:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],1001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,:2000] , EEG_2D[j,:2000] , 1000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/134:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],1001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,:2000] , EEG_2D[j,:2000] , 1000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.hline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/135:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],1001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,:2000] , EEG_2D[j,:2000] , 1000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.hlines(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/136:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],1001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,:2000] , EEG_2D[j,:2000] , 1000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.ahline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/137:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],1001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,:2000] , EEG_2D[j,:2000] , 1000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/138:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],1001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,2000:6000] , EEG_2D[j,2000:6000] , 2000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/139:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],2001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,2000:6000] , EEG_2D[j,2000:6000] , 2000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/140:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],2001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,4000:10000] , EEG_2D[j,4000:10000] , 2000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/141:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],2001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,4000:10000] , EEG_2D[j,4000:10000] , 2000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/142:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],1001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,1000:5000] , EEG_2D[j,1000:5000] , 1000)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/143:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],1001))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,1000:5000] , EEG_2D[j,1000:5000] , 500)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/144:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
N = 500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,1000:5000] , EEG_2D[j,1000:5000] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/145:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
N = 2000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,1000:5000] , EEG_2D[j,1000:5000] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/146:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
N = 2000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/147:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
N = 10000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,:] , EEG_2D[j,:] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/148:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
N = 500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,1000:3000] , EEG_2D[j,1000:3000] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/149:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print(EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
# KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],EEG_2D.data.shape[1]*2-1))
N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0)
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
4/150:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - EEG_2D[-1,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
 5/1:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:]  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
 5/2:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
 5/3:
import saffy
import numpy as np
import matplotlib.pyplot as plt
 5/4: %matplotlib inline
 5/5:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
 5/6:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
 5/7: # !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master --user
 5/8:
import saffy
import numpy as np
import matplotlib.pyplot as plt
 5/9: %matplotlib inline
5/10:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
5/11: !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master --user!
5/12: !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master --user
5/13:
import saffy
import numpy as np
import matplotlib.pyplot as plt
5/14: %matplotlib inline
5/15:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
5/16:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
5/17: !pip3 install 'saffy=0.1.1' --force-reinstall
5/18: !pip3 install 'saffy==0.1.1' --force-reinstall
5/19:
import saffy
import numpy as np
import matplotlib.pyplot as plt
5/20: %matplotlib inline
5/21:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
5/22: !pip3 install 'saffy==0.1.1' --force-reinstall --user
5/23:
import saffy
import numpy as np
import matplotlib.pyplot as plt
5/24: %matplotlib inline
5/25:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
5/26:
import saffy
import numpy as np
import matplotlib.pyplot as plt
5/27: %matplotlib inline
5/28:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
 6/1:
import saffy
import numpy as np
import matplotlib.pyplot as plt
 6/2: %matplotlib inline
 6/3:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
 6/4: !pip3 install 'saffy==0.1.11' --force-reinstall --user
 7/1:
import saffy
import numpy as np
import matplotlib.pyplot as plt
 7/2: %matplotlib inline
 7/3:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
 7/4: !pip3 install 'saffy==0.1' --force-reinstall --user
 7/5: !pip3 install 'saffy==0.1' --force-reinstall --user
 7/6: !pip3 install 'saffy==0.1' --force-reinstall --user
 8/1:
import saffy
import numpy as np
import matplotlib.pyplot as plt
 8/2: %matplotlib inline
 8/3:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
 8/4:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
 8/5:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
 8/6:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
 8/7:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 5000
start = 1000
stop = 10000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
 8/8:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['open'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 10000
start = 1000
stop = 40000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
 8/9:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
EEG.extract_channels(['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2'])
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 10000
start = 1000
stop = 40000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
8/10:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2']
EEG.extract_channels(CH)
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 10000
start = 1000
stop = 40000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.title(CH[i] , 'x' , CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
8/11:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2']
EEG.extract_channels(CH)
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 10000
start = 1000
stop = 40000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
8/12:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2']
EEG.extract_channels(CH)
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-1,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 4000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
8/13:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2']
EEG.extract_channels(CH)
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-2,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 4000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
8/14:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2']
EEG.extract_channels(CH)
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-2,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 1000
start = 1000
stop = 3000
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
8/15:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2']
EEG.extract_channels(CH)
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-2,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
for i in range(EEG_2D.shape[0]):
    for j in range(EEG_2D.shape[0]):
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
        ax1 = plt.subplot(EEG_2D.shape[0], EEG_2D.shape[0], (i*EEG_2D.shape[0])+j+1)
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
plt.show()
8/16:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(1000):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)+1] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
    max_corr[k] = max(np.abs(corr_matrix))
print(max_corr)
8/17:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(1000):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)+1] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/18:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)+1] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/19:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(np.random.shuffle(EEG_2D[i,start:stop]) , np.random.shuffle(EEG_2D[j,start:stop]) , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)+1] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(np.random.shuffle(EEG_2D[i,start:stop]) , np.random.shuffle(EEG_2D[j,start:stop]) , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/20:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = np.random.shuffle(EEG_2D[i,start:stop])
            syg2 = np.random.shuffle(EEG_2D[j,start:stop])
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)+1] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/21:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(EEG_2D[i,start:stop])
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(EEG_2D[j,start:stop])
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)+1] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/22:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)+1] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/23:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(10):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)+1] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/24:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/25:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(10):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/26:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (start-stop) -1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')
                corr_matrix[(i*EEG_2D.shape[0])+j,int(start-stop)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/27:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')
                corr_matrix[(i*EEG_2D.shape[0])+j,int(stop-start)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/28:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')
                corr_matrix[(i*EEG_2D.shape[0])+j,int(stop-start)-1] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/29:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')
                corr_matrix[(i*EEG_2D.shape[0])+j,int(stop-start)+1] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/30:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')
                corr_matrix[(i*EEG_2D.shape[0])+j,int(stop-start)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/31:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(stop-start)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/32:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2*N-1)
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/33:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2*N-1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/34:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/35:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/36:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/37:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,len(syg1)*2-1] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/38:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,len(syg1)*2-1] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/39:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,len(syg1)*2] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/40:

N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,int(len(syg1)/2)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/41:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,int(len(syg1)/2)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/42:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,int(len(syg1)/2)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/43:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,int(len(syg1)/2)-1] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/44:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,int(len(syg1)/2)+1] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/45:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(len(syg1)/2)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/46:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/47:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
            print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/48:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
            print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/49:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(stop-start)#(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(stop-start)#(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
            print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/50:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
            print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/51:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.nomr(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.nomr(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
            print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/52:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
            print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/53:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)+1] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
            print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/54:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/55:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,int(len(corr_matrix[(i*EEG_2D.shape[0])+j,:])/2)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/56:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,int(len(corr_matrix[(i*EEG_2D.shape[0])+j,:])/2)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/57:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,int(len(corr_matrix[(i*EEG_2D.shape[0])+j,:])/2+1)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/58:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,int(len(corr_matrix[(i*EEG_2D.shape[0])+j,:])/2-1)] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/59:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/60:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/61:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/62:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/63:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/64:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-5:(stop-start)+5])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/65:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(stop-start)/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/66:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/67:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')*(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')*(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/68:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/69:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/70:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/71:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/72:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
            plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
            plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/73:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=0)*np.std(syg2,ddof=0))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
            plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
            plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/74:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=0)*np.std(syg2,ddof=0))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=0)*np.std(syg2,ddof=0))
            plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
            plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/75:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=7)*np.std(syg2,ddof=7))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=7)*np.std(syg2,ddof=7))
            plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
            plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/76:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop])
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
            plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
            plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/77:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop]))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
            plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
            plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/78:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop]))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/79:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop]))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/80:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop]))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/81:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop]) * len(EEG_2D[j,start:stop]) )
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/82:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop]) )
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/83:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop]) )
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/84:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop]) )
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/85:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/86:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/87:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/88:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2])
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/89:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)-2:int(N/2)+2])
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/90:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop]) )
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/91:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop]) )
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,-3:])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
8/92:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(1000):
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg2)
            if i == j:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)-2:int(N/2)+2])
            else:
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
 9/1:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop]) )
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full' , method = 'direct')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full' , method = 'direct')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
 9/2:
import saffy
import numpy as np
import matplotlib.pyplot as plt
 9/3: %matplotlib inline
 9/4:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
EEG = saffy.SignalManager(filename=pliki['closed'])
EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'A1','A2']
EEG.extract_channels(CH)
print('Fs;',EEG.fs)
EEG_2D = EEG.data[0,:,:]
for k in range(EEG_2D.shape[0]): 
    EEG_2D[k,:] = EEG_2D[k,:] - (EEG_2D[-1,:] + EEG_2D[-2,:])/2  #montaz, odejmujemy A1 czyli ucho
print(EEG_2D.data.shape)
EEG_2D = EEG_2D[0:-2,:]
print(EEG_2D.data.shape)
plt.plot(EEG_2D[0,:1024])
plt.show()
 9/5:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = (EEG_2D[i,start:stop] - np.mean(EEG_2D[i,start:stop]))/( np.std(EEG_2D[i,start:stop]) * len(EEG_2D[i,start:stop]) )
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = (EEG_2D[j,start:stop] - np.mean(EEG_2D[j,start:stop]))/( np.std(EEG_2D[j,start:stop]) )
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full' , method = 'direct')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full' , method = 'direct')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
 9/6:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full' , method = 'direct')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full' , method = 'direct')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
 9/7:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = (syg1 - np.mean(syg1))/ np.std(syg1)
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = (syg2 - np.mean(syg2))/ np.std(syg2)
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full' , method = 'direct')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full' , method = 'direct')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
 9/8:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = (syg1 - np.mean(syg1))/ np.std(syg1)
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = (syg2 - np.mean(syg2))/ np.std(syg2)
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
 9/9:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = (syg1 - np.mean(syg1))/ (np.std(syg1) * len(syg1))
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = (syg2 - np.mean(syg2))/ (np.std(syg2) * len(syg2))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
9/10:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
            syg1 = (syg1 - np.mean(syg1))/ (np.std(syg1) * len(syg1))
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
            syg2 = (syg2 - np.mean(syg2))/ (np.std(syg2))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full')#/(np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
9/11:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = (syg1 - np.mean(syg1))/ (np.std(syg1) * len(syg1))
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = (syg2 - np.mean(syg2))/ (np.std(syg2))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full') / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full') / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
9/12:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = (syg1 - np.mean(syg1))/ (np.std(syg1) * len(syg1))
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = (syg2 - np.mean(syg2))/ (np.std(syg2))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2, 'full') / (np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = ss.correlate(syg1 , syg2 , 'full') / (np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
9/13:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = (syg1 - np.mean(syg1))/ (np.std(syg1) * len(syg1))
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = (syg2 - np.mean(syg2))/ (np.std(syg2))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full') / (np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full') / (np.std(syg1,ddof=1)*np.std(syg2,ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
9/14:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = (syg1 - np.mean(syg1))/ (np.std(syg1) * len(syg1))
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = (syg2 - np.mean(syg2))/ (np.std(syg2))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full') / (np.std(EEG_2D[i,:],ddof=1)*np.std(EEG_2D[j,start:stop],ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full') / (np.std(EEG_2D[i,:],ddof=1)*np.std(EEG_2D[j,start:stop],ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
9/15:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = (syg1 - np.mean(syg1))/ (np.std(syg1) * len(syg1))
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = (syg2 - np.mean(syg2))/ (np.std(syg2))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2, 'full') / (np.std(EEG_2D[i,:],ddof=1)*np.std(EEG_2D[j,:],ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = np.correlate(syg1 , syg2 , 'full') / (np.std(EEG_2D[i,:],ddof=1)*np.std(EEG_2D[j,:],ddof=1))
#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
9/16:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = (syg1 - np.mean(syg1))/ (np.std(syg1) * len(syg1))
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = (syg2 - np.mean(syg2))/ (np.std(syg2))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                temp = np.correlate(syg1 , syg2, 'full')
                temp = temp / np.max(temp)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = temp #/ (np.std(EEG_2D[i,:],ddof=1)*np.std(EEG_2D[j,:],ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
#                 corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                temp = np.correlate(syg1 , syg2, 'full')
                temp = temp / np.max(temp)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = temp #/ (np.std(EEG_2D[i,:],ddof=1)*np.std(EEG_2D[j,:],ddof=1))#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
9/17:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = (syg1 - np.mean(syg1))/ (np.std(syg1) * len(syg1))
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = (syg2 - np.mean(syg2))/ (np.std(syg2))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                temp = np.correlate(syg1 , syg2, 'full')
                temp = temp / np.max(temp)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = temp #/ (np.std(EEG_2D[i,:],ddof=1)*np.std(EEG_2D[j,:],ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                temp = np.correlate(syg1 , syg2, 'full')
                temp = temp / np.max(temp)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = temp #/ (np.std(EEG_2D[i,:],ddof=1)*np.std(EEG_2D[j,:],ddof=1))#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
9/18:
import scipy.signal as ss
N = 400
start = 1000
stop = 2500
KORELACJE = np.empty((EEG_2D.shape[0],EEG_2D.shape[0],N+1))
fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)
for k in range(2):
    corr_matrix = np.zeros((EEG_2D.shape[0]**2,2 * (stop-start) -1))
#     corr_matrix = np.zeros((EEG_2D.shape[0]**2,N+1))
    for i in range(EEG_2D.shape[0]):
        for j in range(EEG_2D.shape[0]):
            syg1 = EEG_2D[i,start:stop]
#             syg1 = (syg1 - np.mean(syg1))/ (np.std(syg1) * len(syg1))
#             syg1 = syg1/np.linalg.norm(syg1)
            np.random.shuffle(syg1)
            syg2 = EEG_2D[j,start:stop]
#             syg2 = (syg2 - np.mean(syg2))/ (np.std(syg2))
#             syg2 = syg2/np.linalg.norm(syg2)
            np.random.shuffle(syg2)
            if i == j:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                temp = np.correlate(syg1 , syg2, 'full')
                temp = temp / np.mean(temp)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = temp #/ (np.std(EEG_2D[i,:],ddof=1)*np.std(EEG_2D[j,:],ddof=1))
#                 corr_matrix[(i*EEG_2D.shape[0])+j,int(N/2)] = 0
                print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-2:(stop-start)+2])
                corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+2] = 0
#                 print(corr_matrix[(i*EEG_2D.shape[0])+j,(stop-start)-1:(stop-start)+1])
            else:
#                 corr_matrix[(i*EEG_2D.shape[0])+j,:] = koreluj(syg1 , syg2 , N)
                temp = np.correlate(syg1 , syg2, 'full')
                temp = temp / np.mean(temp)
                corr_matrix[(i*EEG_2D.shape[0])+j,:] = temp #/ (np.std(EEG_2D[i,:],ddof=1)*np.std(EEG_2D[j,:],ddof=1))#             plt.plot(corr_matrix[(i*EEG_2D.shape[0])+j,:])
#             plt.show()
#             print(corr_matrix[(i*EEG_2D.shape[0])+j,:])
    max_corr[k] = np.max(np.abs(corr_matrix))
print(max_corr)
9/19:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
kor2 = np.corrcoef(s,s)
print(kor)
print(kor2)
plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
9/20:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
kor2 = np.corrcoef(s,s)
print(kor)
print(np.dot(s,s))
plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
9/21:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
kor2 = np.corrcoef(s,s)
print(kor)
print(np.convolve(s,s))
plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
9/22:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
#     delta = int(Fs/2)
#     gammy = np.zeros(2*delta+1)
#     N = len(s1)
#     for i in range(-delta, delta+1):
#         if i < 0:
#             s1_temp=s1[0:N+i]
#             s2_temp=s2[-i:N]
#         else:
#             s1_temp=s1[i:N]
#             s2_temp=s2[0:N-i]
#         gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = np.correlate(s1, s2)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
kor2 = np.corrcoef(s,s)
print(kor)
print(np.convolve(s,s))
plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
9/24:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
#     delta = int(Fs/2)
#     gammy = np.zeros(2*delta+1)
#     N = len(s1)
#     for i in range(-delta, delta+1):
#         if i < 0:
#             s1_temp=s1[0:N+i]
#             s2_temp=s2[-i:N]
#         else:
#             s1_temp=s1[i:N]
#             s2_temp=s2[0:N-i]
#         gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = np.correlate(s1, s2)
        gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
        return gammy
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
kor2 = np.corrcoef(s,s)
print(kor)
print(np.convolve(s,s))
plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
9/25:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
#     delta = int(Fs/2)
#     gammy = np.zeros(2*delta+1)
#     N = len(s1)
#     for i in range(-delta, delta+1):
#         if i < 0:
#             s1_temp=s1[0:N+i]
#             s2_temp=s2[-i:N]
#         else:
#             s1_temp=s1[i:N]
#             s2_temp=s2[0:N-i]
#         gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
    gamma = np.correlate(s1, s2)
    gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
#         gammy[delta+i] = gamma
    return gamma
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
kor2 = np.corrcoef(s,s)
print(kor)
print(np.convolve(s,s))
plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
9/26:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
#     delta = int(Fs/2)
#     gammy = np.zeros(2*delta+1)
#     N = len(s1)
#     for i in range(-delta, delta+1):
#         if i < 0:
#             s1_temp=s1[0:N+i]
#             s2_temp=s2[-i:N]
#         else:
#             s1_temp=s1[i:N]
#             s2_temp=s2[0:N-i]
#         gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
    gamma = np.correlate(s1, s2, 'full')
    gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
#         gammy[delta+i] = gamma
    return gamma
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
kor2 = np.corrcoef(s,s)
print(kor)
print(np.convolve(s,s))
plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
9/27:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
#     delta = int(Fs/2)
#     gammy = np.zeros(2*delta+1)
#     N = len(s1)
#     for i in range(-delta, delta+1):
#         if i < 0:
#             s1_temp=s1[0:N+i]
#             s2_temp=s2[-i:N]
#         else:
#             s1_temp=s1[i:N]
#             s2_temp=s2[0:N-i]
#         gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
    gamma = np.convolve(s1, s2)
    gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
#         gammy[delta+i] = gamma
    return gamma
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
kor2 = np.corrcoef(s,s)
print(kor)
print(np.convolve(s,s))
plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
9/28:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
#     delta = int(Fs/2)
#     gammy = np.zeros(2*delta+1)
#     N = len(s1)
#     for i in range(-delta, delta+1):
#         if i < 0:
#             s1_temp=s1[0:N+i]
#             s2_temp=s2[-i:N]
#         else:
#             s1_temp=s1[i:N]
#             s2_temp=s2[0:N-i]
#         gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
    gamma = np.correlate(s1, s2, 'full')
    gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
#         gammy[delta+i] = gamma
    return gamma
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
kor2 = np.corrcoef(s,s)
print(kor)

plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
9/29:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
#     delta = int(Fs/2)
#     gammy = np.zeros(2*delta+1)
#     N = len(s1)
#     for i in range(-delta, delta+1):
#         if i < 0:
#             s1_temp=s1[0:N+i]
#             s2_temp=s2[-i:N]
#         else:
#             s1_temp=s1[i:N]
#             s2_temp=s2[0:N-i]
#         gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
    gamma = np.correlate(s1, s2, 'full','direct')
    gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
#         gammy[delta+i] = gamma
    return gamma
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
kor2 = np.corrcoef(s,s)
print(kor)

plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
9/30:
                                                                                                                                                                                                        import numpy as np
import matplotlib.pyplot as plt

def koreluj(s1, s2, Fs): #delta - ile przesunięć
#     delta = int(Fs/2)
#     gammy = np.zeros(2*delta+1)
#     N = len(s1)
#     for i in range(-delta, delta+1):
#         if i < 0:
#             s1_temp=s1[0:N+i]
#             s2_temp=s2[-i:N]
#         else:
#             s1_temp=s1[i:N]
#             s2_temp=s2[0:N-i]
#         gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
    gamma = np.correlate(s1, s2, 'full',method='direct')
    gamma = gamma / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
#         gammy[delta+i] = gamma
    return gamma
    
def fourier(kor, F):
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

Fs = 64
t = np.arange(0,10,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
#with plik as open(\\home\desktop\eeg\mateusz_oczy_szeroko_zamkniete.raw):
    

czestosci = np.arange(0,Fs/2, 0.01)
kor = koreluj(s,s,Fs)
kor2 = np.corrcoef(s,s)
print(kor)

plt.plot(kor)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
14/1:
''' To co wyżej tylko dla przefiltrowanych '''
EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2000

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
14/2:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
14/3:
'''Czytanie, montowanie i obróbka sygnałów.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cut?off=50, order=1, rs=3, width=0.3, btype='bandstop')

# EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
14/4:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
14/5: !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master
14/6: !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master --user
14/7:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
14/8: %matplotlib inline
14/9:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def fourier(kor, F):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja
14/10:
'''Czytanie, montowanie i obróbka sygnałów.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cut?off=50, order=1, rs=3, width=0.3, btype='bandstop')

# EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
14/11:
''' To co wyżej tylko dla przefiltrowanych '''
EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2000

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
14/12:
''' To co wyżej tylko dla przefiltrowanych '''
EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None, fs = EEG.fs)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2000

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
14/13:
''' To co wyżej tylko dla przefiltrowanych '''
EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None, fs = EEG.fs)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2000

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
14/14:
''' To co wyżej tylko dla przefiltrowanych '''
EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.butter_bandpass_filter(fs = EEG.fs,lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2000

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
14/15:
'''Czytanie, montowanie i obróbka sygnałów.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cut?off=50, order=1, rs=3, width=0.3, btype='bandstop')

# EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
14/16:
'''Czytanie, montowanie i obróbka sygnałów.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

# EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
14/17:
'''Czytanie, montowanie i obróbka sygnałów.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

# EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
14/18:
''' To co wyżej tylko dla przefiltrowanych '''
EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.butter_bandpass_filter(fs = EEG.fs,lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2000

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
15/2: %matplotlib inline
15/3:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def fourier(kor, F):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja
15/4:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
15/5:
'''Czytanie, montowanie i obróbka sygnałów.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

# EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
15/6:
'''Czytanie, montowanie i obróbka sygnałów.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

# EEG.data = np.reshape(EEG.data, (1, *EEG.data.shape))
CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
15/7:
''' To co wyżej tylko dla przefiltrowanych '''
EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.butter_bandpass_filter(fs = EEG.fs,lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2000

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/8:
''' To co wyżej tylko dla przefiltrowanych '''
EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2000

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/9:
start = 1000
stop = 2500

fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(1000)

for k in range(1000):
    corr_matrix = np.zeros((CH_N**2,(stop-start)))
    for i in range(CH_N):
        for j in range(CH_N):
            syg1 = EEG_2D[i,start:stop]
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg1)
            np.random.shuffle(syg2)  
            corr_matrix[(i*CH_N)+j,:] = cool_koreluj(syg1 , syg2)
            
            if i == j:
                corr_matrix[(i*CH_N)+j,int((stop-start)/2)] = 0
                
    max_corr[k] = np.max(np.abs(corr_matrix))
np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}" , max_corr)
print(max_corr)
15/10:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}")
down = np.percentile(2.5, max_corr)
up = np.percentile(97.5, max_corr)
print(down, up)
15/11:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}")
down = np.percentile(2.5, max_corr)
up = np.percentile(97.5, max_corr)
print(max_corr)
15/12:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}")
down = np.percentile(2.5, max_corr)
up = np.percentile(97.5, max_corr)
print(down)
15/13:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}")
down = np.percentile(max_corr, 2.5)
up = np.percentile(max_corr, 97.5)
print(down)
15/14:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}")
down = np.percentile(max_corr, 2.5)
up = np.percentile(max_corr, 97.5)
print(down, up)
15/15:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}")
up = np.percentile(max_corr, 95)
down = -up
print(up)
15/16:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
15/17:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))

delta = 1000
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/18:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
15/19:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))

delta = 1000
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/20:
'''Poziom istotności.
    BEZ FILTRA.'''

start = 1000
stop = 2500
eN = 1000

fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(eN)

for k in range(eN):
    corr_matrix = np.zeros((CH_N**2,(stop-start)))
    for i in range(CH_N):
        for j in range(CH_N):
            syg1 = EEG_2D[i,start:stop]
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg1)
            np.random.shuffle(syg2)  
            corr_matrix[(i*CH_N)+j,:] = cool_koreluj(syg1 , syg2)
            
            if i == j:
                corr_matrix[(i*CH_N)+j,int((stop-start)/2)] = 0
                
    max_corr[k] = np.max(np.abs(corr_matrix))
np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}_noFil" , max_corr)
print(max_corr)
15/21:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}_noFil")
up = np.percentile(max_corr, 95)
down = -up
print(up)
15/22:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2000

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'g')
        plt.axhline(up, color = 'r')
        plt.axhline(down, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/23:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'g')
        plt.axhline(up, color = 'r')
        plt.axhline(down, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/24:
''' Zabawa z przefiktrowanym sygnałem'''
EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne
15/25:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/26:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
15/27:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/28:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'g')
        plt.axhline(up, color = 'r')
        plt.axhline(down, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/29:
''' Zabawa z przefiktrowanym sygnałem
                FILTROWANIE'''
EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D_F = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D_F = EEG_2D_F - (EEG_2D_F[-1,:] + EEG_2D_F[-2,:])/2 #montaz - średnia z uszu   
EEG_2D_F = EEG_2D_F[0:-2,:] #usuwamy kanały uszne
15/30:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                Z FILTREM.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = koreluj(EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/31:
'''Poziom istotności.
    Z FILTREM.'''

start = 1000
stop = 2500
eN = 1000

fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(eN)

for k in range(eN):
    corr_matrix = np.zeros((CH_N**2,(stop-start)))
    for i in range(CH_N):
        for j in range(CH_N):
            syg1 = EEG_2D_F[i,start:stop]
            syg2 = EEG_2D_F[j,start:stop]
            np.random.shuffle(syg1)
            np.random.shuffle(syg2)  
            corr_matrix[(i*CH_N)+j,:] = cool_koreluj(syg1 , syg2)
            
            if i == j:
                corr_matrix[(i*CH_N)+j,int((stop-start)/2)] = 0
                
    max_corr[k] = np.max(np.abs(corr_matrix))
np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}" , max_corr)
print(max_corr)
15/32:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}")
up = np.percentile(max_corr, 95)
down = -up
print(up)
15/33:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.
                            Z FILTREM'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2000

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/34:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.
                            Z FILTREM'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/35:
''' Zabawa z przefiktrowanym sygnałem
                FILTROWANIE'''
EEG2 = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG2.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG2.extract_channels(CH)

EEG_2D_F = EEG2.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D_F = EEG_2D_F - (EEG_2D_F[-1,:] + EEG_2D_F[-2,:])/2 #montaz - średnia z uszu   
EEG_2D_F = EEG_2D_F[0:-2,:] #usuwamy kanały uszne
15/36:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                Z FILTREM.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = koreluj(EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/37:
'''Poziom istotności.
    Z FILTREM.'''

start = 1000
stop = 2500
eN = 1000

fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(eN)

for k in range(eN):
    corr_matrix = np.zeros((CH_N**2,(stop-start)))
    for i in range(CH_N):
        for j in range(CH_N):
            syg1 = EEG_2D_F[i,start:stop]
            syg2 = EEG_2D_F[j,start:stop]
            np.random.shuffle(syg1)
            np.random.shuffle(syg2)  
            corr_matrix[(i*CH_N)+j,:] = cool_koreluj(syg1 , syg2)
            
            if i == j:
                corr_matrix[(i*CH_N)+j,int((stop-start)/2)] = 0
                
    max_corr[k] = np.max(np.abs(corr_matrix))
np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}" , max_corr)
15/38:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}")
up = np.percentile(max_corr, 95)
down = -up
print(up)
15/39:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.
                            Z FILTREM'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/40:
''' Zabawa z przefiktrowanym sygnałem
                FILTROWANIE'''
EEG2 = saffy.SignalManager(generator=svarog(pliki['closed']))
EEG.butter_highpass_filter(cutoff=1, order=2)
EEG2.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG2.extract_channels(CH)

EEG_2D_F = EEG2.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D_F = EEG_2D_F - (EEG_2D_F[-1,:] + EEG_2D_F[-2,:])/2 #montaz - średnia z uszu   
EEG_2D_F = EEG_2D_F[0:-2,:] #usuwamy kanały uszne
15/41:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                Z FILTREM.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = koreluj(EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/42:
'''Poziom istotności.
    Z FILTREM.'''

start = 1000
stop = 2500
eN = 1000

fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(eN)

for k in range(eN):
    corr_matrix = np.zeros((CH_N**2,(stop-start)))
    for i in range(CH_N):
        for j in range(CH_N):
            syg1 = EEG_2D_F[i,start:stop]
            syg2 = EEG_2D_F[j,start:stop]
            np.random.shuffle(syg1)
            np.random.shuffle(syg2)  
            corr_matrix[(i*CH_N)+j,:] = cool_koreluj(syg1 , syg2)
            
            if i == j:
                corr_matrix[(i*CH_N)+j,int((stop-start)/2)] = 0
                
    max_corr[k] = np.max(np.abs(corr_matrix))
np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}" , max_corr)
15/43:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}")
up = np.percentile(max_corr, 95)
down = -up
print(up)
15/44:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.
                            Z FILTREM'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
15/45:
''' Zabawa z przefiktrowanym sygnałem
                FILTROWANIE'''
EEG2 = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG2.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG2.extract_channels(CH)

EEG_2D_F = EEG2.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D_F = EEG_2D_F - (EEG_2D_F[-1,:] + EEG_2D_F[-2,:])/2 #montaz - średnia z uszu   
EEG_2D_F = EEG_2D_F[0:-2,:] #usuwamy kanały uszne
17/1: !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master --user
17/2:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
17/3: %matplotlib inline
17/4:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def fourier(kor, F):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja
17/5:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
17/6:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
17/7: # !pip3 install -U --upgrade --force-reinstall saffy
17/8:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
17/9:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
17/10:
'''Poziom istotności.
    BEZ FILTRA.'''

start = 1000
stop = 2500
eN = 1000

fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(eN)

for k in range(eN):
    corr_matrix = np.zeros((CH_N**2,(stop-start)))
    for i in range(CH_N):
        for j in range(CH_N):
            syg1 = EEG_2D[i,start:stop]
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg1)
            np.random.shuffle(syg2)  
            corr_matrix[(i*CH_N)+j,:] = cool_koreluj(syg1 , syg2)
            
            if i == j:
                corr_matrix[(i*CH_N)+j,int((stop-start)/2)] = 0
                
    max_corr[k] = np.max(np.abs(corr_matrix))
np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}_noFil" , max_corr)
17/11:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}_noFil")
up = np.percentile(max_corr, 95)
down = -up
print(up)
17/12:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'g')
        plt.axhline(up, color = 'r')
        plt.axhline(down, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
17/13:
''' Zabawa z przefiktrowanym sygnałem
                FILTROWANIE'''
EEG2 = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG2.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG2.extract_channels(CH)

EEG_2D_F = EEG2.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D_F = EEG_2D_F - (EEG_2D_F[-1,:] + EEG_2D_F[-2,:])/2 #montaz - średnia z uszu   
EEG_2D_F = EEG_2D_F[0:-2,:] #usuwamy kanały uszne
17/14:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                Z FILTREM.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = koreluj(EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
17/15:
'''Poziom istotności.
    Z FILTREM.'''

start = 1000
stop = 2500
eN = 1000

fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(eN)

for k in range(eN):
    corr_matrix = np.zeros((CH_N**2,(stop-start)))
    for i in range(CH_N):
        for j in range(CH_N):
            syg1 = EEG_2D_F[i,start:stop]
            syg2 = EEG_2D_F[j,start:stop]
            np.random.shuffle(syg1)
            np.random.shuffle(syg2)  
            corr_matrix[(i*CH_N)+j,:] = cool_koreluj(syg1 , syg2)
            
            if i == j:
                corr_matrix[(i*CH_N)+j,int((stop-start)/2)] = 0
                
    max_corr[k] = np.max(np.abs(corr_matrix))
np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}" , max_corr)
17/16:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}")
up = np.percentile(max_corr, 95)
down = -up
print(up)
17/17:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.
                            Z FILTREM'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
18/1: # !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master --user
18/2:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
18/3: %matplotlib inline
18/4:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def fourier(kor, F):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja
18/5:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
18/6:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
18/7: # !pip3 install -U --upgrade --force-reinstall saffy
18/8:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
18/9:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
18/10:
'''Poziom istotności.
    BEZ FILTRA.'''

start = 1000
stop = 2500
eN = 1000

fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(eN)

for k in range(eN):
    corr_matrix = np.zeros((CH_N**2,(stop-start)))
    for i in range(CH_N):
        for j in range(CH_N):
            syg1 = EEG_2D[i,start:stop]
            syg2 = EEG_2D[j,start:stop]
            np.random.shuffle(syg1)
            np.random.shuffle(syg2)  
            corr_matrix[(i*CH_N)+j,:] = cool_koreluj(syg1 , syg2)
            
            if i == j:
                corr_matrix[(i*CH_N)+j,int((stop-start)/2)] = 0
                
    max_corr[k] = np.max(np.abs(corr_matrix))
np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}_noFil" , max_corr)
18/11:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}_noFil")
up = np.percentile(max_corr, 95)
down = -up
print(up)
18/12:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'g')
        plt.axhline(up, color = 'r')
        plt.axhline(down, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
18/13:
''' Zabawa z przefiktrowanym sygnałem
                FILTROWANIE'''
EEG2 = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG2.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG2.extract_channels(CH)

EEG_2D_F = EEG2.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D_F = EEG_2D_F - (EEG_2D_F[-1,:] + EEG_2D_F[-2,:])/2 #montaz - średnia z uszu   
EEG_2D_F = EEG_2D_F[0:-2,:] #usuwamy kanały uszne
18/14:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                Z FILTREM.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = koreluj(EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
18/15:
'''Poziom istotności.
    Z FILTREM.'''

start = 1000
stop = 2500
eN = 1000

fig = plt.figure(figsize = (50,50))
max_corr = np.zeros(eN)

for k in range(eN):
    corr_matrix = np.zeros((CH_N**2,(stop-start)))
    for i in range(CH_N):
        for j in range(CH_N):
            syg1 = EEG_2D_F[i,start:stop]
            syg2 = EEG_2D_F[j,start:stop]
            np.random.shuffle(syg1)
            np.random.shuffle(syg2)  
            corr_matrix[(i*CH_N)+j,:] = cool_koreluj(syg1 , syg2)
            
            if i == j:
                corr_matrix[(i*CH_N)+j,int((stop-start)/2)] = 0
                
    max_corr[k] = np.max(np.abs(corr_matrix))
np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}" , max_corr)
18/16:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}")
up = np.percentile(max_corr, 95)
down = -up
print(up)
18/17:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.
                            Z FILTREM'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
18/18:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'g')
#         plt.axhline(up, color = 'r')
#         plt.axhline(down, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
18/19:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'g')
        plt.axhline(up, color = 'r')
        plt.axhline(down, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
18/20:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2000

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'g')
        plt.axhline(up, color = 'r')
        plt.axhline(down, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
18/21:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'g')
        plt.axhline(up, color = 'r')
        plt.axhline(down, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
18/22:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
18/23:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'g')
        plt.axhline(up, color = 'r')
        plt.axhline(down, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
18/24:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500

KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE[i,j])
        
plt.show()
18/25:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE2_1 = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE2_1[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'g')
        plt.axhline(up, color = 'r')
        plt.axhline(down, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE2_1[i,j])
        
plt.show()
18/26:
''' Zabawa z przefiktrowanym sygnałem
                FILTROWANIE'''
EEG2 = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
EEG2.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG2.extract_channels(CH)

EEG_2D_F = EEG2.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D_F = EEG_2D_F - (EEG_2D_F[-1,:] + EEG_2D_F[-2,:])/2 #montaz - średnia z uszu   
EEG_2D_F = EEG_2D_F[0:-2,:] #usuwamy kanały uszne
18/27:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                Z FILTREM.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500

KORELACJE1 = np.empty( ( CH_N ,CH_N, delta+1) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE1[i,j,:] = koreluj(EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop] , delta)
        ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j])
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE1[i,j])
        
plt.show()
18/28:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.
                            Z FILTREM'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE2_2 = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE2_2[i,j,:] = cool_koreluj( EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE2_2[i,j])
        
plt.show()
18/29:
max_corr = np.loadtxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}")
up2 = np.percentile(max_corr, 95)
down2 = -up2
print(up)
18/30:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.
                            Z FILTREM'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

KORELACJE2_2 = np.empty( ( CH_N, CH_N , (stop-start) ) )

for i in range(CH_N):
    for j in range(CH_N):
        
        KORELACJE2_2[i,j,:] = cool_koreluj( EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop ] )
        
        ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
        plt.title(f" {CH[i]} x {CH[j]}")
        plt.axhline(0, color = 'r')
        plt.axhline(up2, color = 'r')
        plt.axhline(down2, color = 'r')
        plt.ylim(-1,1)
        ax1.plot(KORELACJE2_2[i,j])
        
plt.show()
18/31:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500
def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

K = rysuje_koreluj(EEG_2D , CH , CH_N , delta , start , stop)

# KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

# for i in range(CH_N):
#     for j in range(CH_N):
        
#         KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , delta)
#         ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title(CH[i] + 'x' + CH[j])
#         plt.axhline(0, color = 'r')
#         plt.ylim(-1,1)
#         ax1.plot(KORELACJE[i,j])
        
# plt.show()
18/32:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500
def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

K = rysuj_koreluj(EEG_2D , CH , CH_N , delta , start , stop)

# KORELACJE = np.empty( ( CH_N ,CH_N, delta+1) )

# for i in range(CH_N):
#     for j in range(CH_N):
        
#         KORELACJE[i,j,:] = koreluj(EEG_2D[i,start:stop] , EEG_2D[j,start:stop] , delta)
#         ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title(CH[i] + 'x' + CH[j])
#         plt.axhline(0, color = 'r')
#         plt.ylim(-1,1)
#         ax1.plot(KORELACJE[i,j])
        
# plt.show()
18/33:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja
18/34:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                Z FILTREM.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500
K2 = rysuj_koreluj(EEG_2D_F , CH , CH_N , delta , start , stop)
# KORELACJE1 = np.empty( ( CH_N ,CH_N, delta+1) )

# for i in range(CH_N):
#     for j in range(CH_N):
        
#         KORELACJE1[i,j,:] = koreluj(EEG_2D_F[i,start:stop] , EEG_2D_F[j,start:stop] , delta)
#         ax1 = plt.subplot( CH_N, CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title(CH[i] + 'x' + CH[j])
#         plt.axhline(0, color = 'r')
#         plt.ylim(-1,1)
#         ax1.plot(KORELACJE1[i,j])
        
# plt.show()
18/35:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = None , down = None )
    KORELACJE = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            plt.axhline(0, color = 'g')
            plt.axhline(up, color = 'r')
            plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , start , stop )

# KORELACJE2_1 = np.empty( ( CH_N, CH_N , (stop-start) ) )

# for i in range(CH_N):
#     for j in range(CH_N):
        
#         KORELACJE2_1[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
#         ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
#         plt.title(f" {CH[i]} x {CH[j]}")
#         plt.axhline(0, color = 'g')
#         plt.axhline(up, color = 'r')
#         plt.axhline(down, color = 'r')
#         plt.ylim(-1,1)
#         ax1.plot(KORELACJE2_1[i,j])
        
# plt.show()
18/36:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , start , stop )

# KORELACJE2_1 = np.empty( ( CH_N, CH_N , (stop-start) ) )

# for i in range(CH_N):
#     for j in range(CH_N):
        
#         KORELACJE2_1[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
#         ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
#         plt.title(f" {CH[i]} x {CH[j]}")
#         plt.axhline(0, color = 'g')
#         plt.axhline(up, color = 'r')
#         plt.axhline(down, color = 'r')
#         plt.ylim(-1,1)
#         ax1.plot(KORELACJE2_1[i,j])
        
# plt.show()
18/37:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
start = 1000
stop = 2500

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , start , stop , up , down)

# KORELACJE2_1 = np.empty( ( CH_N, CH_N , (stop-start) ) )

# for i in range(CH_N):
#     for j in range(CH_N):
        
#         KORELACJE2_1[i,j,:] = cool_koreluj( EEG_2D[i,start:stop] , EEG_2D[j,start:stop ] )
        
#         ax1 = plt.subplot(CH_N, CH_N, ( i*CH_N) + j + 1 )
#         plt.title(f" {CH[i]} x {CH[j]}")
#         plt.axhline(0, color = 'g')
#         plt.axhline(up, color = 'r')
#         plt.axhline(down, color = 'r')
#         plt.ylim(-1,1)
#         ax1.plot(KORELACJE2_1[i,j])
        
# plt.show()
18/38:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE
18/39:
'''Poziom istotności.
    BEZ FILTRA.'''

start = 1000
stop = 2500
eN = 1000

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)

    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}_noFil" , max_corr)
    return max_corr
max_k = przedzialy(EEG_2D , CH_N , start , stop , eN)
# max_corr = np.zeros(eN)

# for k in range(eN):
#     corr_matrix = np.zeros((CH_N**2,(stop-start)))
#     for i in range(CH_N):
#         for j in range(CH_N):
#             syg1 = EEG_2D[i,start:stop]
#             syg2 = EEG_2D[j,start:stop]
#             np.random.shuffle(syg1)
#             np.random.shuffle(syg2)  
#             corr_matrix[(i*CH_N)+j,:] = cool_koreluj(syg1 , syg2)

#             if i == j:
#                 corr_matrix[(i*CH_N)+j,int((stop-start)/2)] = 0

#     max_corr[k] = np.max(np.abs(corr_matrix))
# np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}_noFil" , max_corr)
print(max_k)
18/40:
'''Poziom istotności.
    BEZ FILTRA.'''

start = 1000
stop = 2500
eN = 1000

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)

    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
#     np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}_noFil" , max_corr)
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
max_k , up , down = przedzialy(EEG_2D , CH_N , start , stop , eN)
# max_corr = np.zeros(eN)

# for k in range(eN):
#     corr_matrix = np.zeros((CH_N**2,(stop-start)))
#     for i in range(CH_N):
#         for j in range(CH_N):
#             syg1 = EEG_2D[i,start:stop]
#             syg2 = EEG_2D[j,start:stop]
#             np.random.shuffle(syg1)
#             np.random.shuffle(syg2)  
#             corr_matrix[(i*CH_N)+j,:] = cool_koreluj(syg1 , syg2)

#             if i == j:
#                 corr_matrix[(i*CH_N)+j,int((stop-start)/2)] = 0

#     max_corr[k] = np.max(np.abs(corr_matrix))
# np.savetxt(f"max_korelacje_start{start}_stop{stop}_dl{stop-start}_noFil" , max_corr)
print(max_k , up , down)
18/41:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)

    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
18/42:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)

    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
18/43:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
18/44:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
18/45: # !pip3 install -U --upgrade --force-reinstall saffy
18/46:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
18/47:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K = rysuj_koreluj(EEG_2D , CH , CH_N , DELTA , START , STOP)
18/48:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
18/49:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K = rysuj_koreluj(EEG_2D , CH , CH_N , DELTA , START , STOP)
18/50:
'''Poziom istotności.
    BEZ FILTRA.'''
eN = 1000

max_k , up , down = przedzialy(EEG_2D , CH_N , START , STOP , eN)
print(up , down)
18/51:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , START , STOP , up , down)
19/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
19/2: %matplotlib inline
19/3:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)

    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
19/4:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
19/5:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K = rysuj_koreluj(EEG_2D , CH , CH_N , DELTA , START , STOP)
19/6:
'''Poziom istotności.
    BEZ FILTRA.'''
eN = 1000

max_k , up , down = przedzialy(EEG_2D , CH_N , START , STOP , eN)
print(up , down)
19/7:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , START , STOP , up , down)
19/8:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
EEG.extract_channels(CH)
EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

fig = plt.figure(figsize = (50,50))
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , START , STOP , up , down)
19/9:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)

    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
19/10:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
19/11:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K = rysuj_koreluj(EEG_2D , CH , CH_N , DELTA , START , STOP)
19/12:
'''Poziom istotności.
    BEZ FILTRA.'''
eN = 1000

max_k , up , down = przedzialy(EEG_2D , CH_N , START , STOP , eN)
print(up , down)
19/13:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , START , STOP , up , down)
19/14:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
19/15:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K = rysuj_koreluj(EEG_2D , CH , CH_N , DELTA , START , STOP)
19/16:
'''Poziom istotności.
    BEZ FILTRA.'''
eN = 1000

max_k , up , down = przedzialy(EEG_2D , CH_N , START , STOP , eN)
print(up , down)
19/17:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , START , STOP , up , down)
20/1:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
21/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
21/2: %matplotlib inline
21/3:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
21/4:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
21/5:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K = rysuj_koreluj(EEG_2D , CH , CH_N , DELTA , START , STOP)
21/6:
'''Poziom istotności.
    BEZ FILTRA.'''
eN = 1000

max_k , up , down = przedzialy(EEG_2D , CH_N , START , STOP , eN)
print(up , down)
21/7:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , START , STOP , up , down)
21/8:
''' Zabawa z przefiktrowanym sygnałem
                FILTROWANIE'''
EEG2 = saffy.SignalManager(generator=svarog(pliki['closed']))
EEG2.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)
EEG2.extract_channels(CH)
EEG_2D_F = EEG2.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D_F = EEG_2D_F - (EEG_2D_F[-1,:] + EEG_2D_F[-2,:])/2 #montaz - średnia z uszu   
EEG_2D_F = EEG_2D_F[0:-2,:] #usuwamy kanały uszne
21/9:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                Z FILTREM.'''
fig = plt.figure(figsize = (50,50))

delta = 1500
start = 1000
stop = 2500
K_filtrowane = rysuj_koreluj(EEG_2D_F , CH , CH_N , DELTA , START , STOP)
21/10:
'''Poziom istotności.
    Z FILTREM.'''
max_k_filtrowane , up_filt , down_filt = przedzialy(EEG_2D_F , CH_N , START , STOP , eN)
21/11: print(up_filt , down_filt)
21/12:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.
                            Z FILTREM'''
fig = plt.figure(figsize = (50,50))
K2_filtrowane = rysuj_cool_koreluj(EEG_2D_F , CH , CH_N , START , STOP , up_filt , down_filt)
21/13:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
    return s

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
21/14:
F = np.arange(0 , 20, 0.25)
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        plt.plot(fourier(K2_filtrowane[i,j], F , Fs))
        plt.show()
21/15:
F = np.arange(0 , 20, 0.25)
print(F)
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        plt.plot(fourier(K2_filtrowane[i,j], F , Fs))
        plt.show()
21/16:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        plt.plot(F , fourier(K2_filtrowane[i,j], F , Fs))
        plt.show()
21/17:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        plt.plot(F , fourier(K2_filtrowane[i,j], F , Fs))
        plt.axvline(12, color = 'g')
        plt.show()
21/18:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr = fourier(K2_filtrowane[i,j], F , Fs)
        plt.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'g')
        plt.show()
21/19:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr = fourier(K2_filtrowane[i,j], F , Fs)
        plt.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'g')
        print(F[np.where(Fr == np.max(Fr))])
        plt.show()
21/20:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr = fourier(K2_filtrowane[i,j], F , Fs)
        plt.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'g')
        plt.title(str(F[np.where(Fr == np.max(Fr))]))
        plt.show()
21/21:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int(tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
21/22:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr = fourier(K2_filtrowane[i,j], F , Fs)
        ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
        plt.title(CH_names[i] + 'x' + CH_names[j] + str(F[np.where(Fr == np.max(Fr))]) )
        ax1.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        plt.show()
21/23:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr = fourier(K2_filtrowane[i,j], F , Fs)
        ax1 = plt.subplot( CH_N , CH_N , ( (i*ch) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j] + str(F[np.where(Fr == np.max(Fr))]) )
        ax1.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        plt.show()
21/24:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr = fourier(K2_filtrowane[i,j], F , Fs)
        ax1 = plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.title(CH[i] + 'x' + CH[j] + str(F[np.where(Fr == np.max(Fr))]) )
        ax1.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        plt.show()
21/25:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr = fourier(K2_filtrowane[i,j], F , Fs)
        ax1 = plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.title( str(F[np.where(Fr == np.max(Fr))]) )
        ax1.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        plt.show()
21/26:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr = fourier(K2_filtrowane[i,j], F , Fs)
        ax1 = plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
        ax1.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        plt.show()
21/27:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr = fourier(K2_filtrowane[i,j], F , Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
        plt.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        plt.show()
21/28:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
        plt.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        plt.show()
21/29:
F = np.arange(0 , 20, 0.25)

Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
        plt.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
plt.show()
21/30:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
        plt.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
plt.show()
21/31:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = Fr2.imag/Fr2.real
        print(Sigma)
plt.show()
21/32:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        print(Sigma)
plt.show()
21/33:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
plt.show()
21/34:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        print(Fr.imag)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.plot(F , Sigma)
plt.show()
21/35:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        print(Fr2.imag)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.plot(F , Sigma)
plt.show()
21/36:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
plt.show()
21/37:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/38:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/39:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/40:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
        Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/41:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
        Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/42:
F = np.arange(0 , 20,0.1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/43:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = int((tau-len(kor)/2)/Fs)
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
21/44:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/45:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
21/46:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
21/47:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/48:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2-1)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
21/49:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/50:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2+1)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
21/51:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/52:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
21/53:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
#         Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        fft = np.fft.fft(K2[i,j])
        Sigma = np.arctan(fft.imag/fft.real)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/54:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
#         Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        fft = np.fft.fft(K2[i,j])
        Sigma = np.arctan(fft.imag/fft.real)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/55:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/56:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
#         Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        fft = np.fft.fft(K2[i,j])
        Sigma = np.arctan(fft.imag/fft.real)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/57:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)

        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/58:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)
        cz = np.fft.fftfreq(len())
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/59:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')

        fft = np.fft.fft(K2[i,j])
        Sigma = np.arctan(fft.imag/fft.real)
        cz = np.fft.fftfreq(len(K2[i,j]))
#         Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
21/60:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')

        fft = np.fft.fft(K2[i,j])
        Sigma = np.arctan(fft.imag/fft.real)
        cz = np.fft.fftfreq(len(K2[i,j]),1/Fs)
#         Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/1:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
22/2:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
22/3: %matplotlib inline
22/4:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
22/5:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
22/6:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
22/7: # !pip3 install -U --upgrade --force-reinstall saffy
22/8:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
22/9:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')

        fft = np.fft.fft(K2[i,j])
        Sigma = np.angle(fft)#np.arctan(fft.imag/fft.real)
        cz = np.fft.fftfreq(len(K2[i,j]),1/Fs)
#         Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/10:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K = rysuj_koreluj(EEG_2D , CH , CH_N , DELTA , START , STOP)
22/11:
'''Poziom istotności.
    BEZ FILTRA.'''
eN = 1000

max_k , up , down = przedzialy(EEG_2D , CH_N , START , STOP , eN)
print(up , down)
22/12:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , START , STOP , up , down)
22/13:
''' Zabawa z przefiktrowanym sygnałem
                FILTROWANIE'''
EEG2 = saffy.SignalManager(generator=svarog(pliki['closed']))
EEG2.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)
EEG2.extract_channels(CH)
EEG_2D_F = EEG2.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D_F = EEG_2D_F - (EEG_2D_F[-1,:] + EEG_2D_F[-2,:])/2 #montaz - średnia z uszu   
EEG_2D_F = EEG_2D_F[0:-2,:] #usuwamy kanały uszne
22/14:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                Z FILTREM.'''
fig = plt.figure(figsize = (50,50))
K_filtrowane = rysuj_koreluj(EEG_2D_F , CH , CH_N , DELTA , START , STOP)
22/15:
'''Poziom istotności.
    Z FILTREM.'''
max_k_filtrowane , up_filt , down_filt = przedzialy(EEG_2D_F , CH_N , START , STOP , eN)
print(up_filt , down_filt)
22/16:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.
                            Z FILTREM'''
fig = plt.figure(figsize = (50,50))
K2_filtrowane = rysuj_cool_koreluj(EEG_2D_F , CH , CH_N , START , STOP , up_filt , down_filt)
22/17:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')

        fft = np.fft.fft(K2[i,j])
        Sigma = np.angle(fft)#np.arctan(fft.imag/fft.real)
        cz = np.fft.fftfreq(len(K2[i,j]),1/Fs)
#         Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/18:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')

        fft = np.fft.fft(K2[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.fftfreq(len(K2[i,j]),1/Fs)
#         Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/19:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')

        fft = np.fft.rfft(K2[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.rfftfreq(len(K2[i,j]),1/Fs)
#         Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/20:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


#         Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        fft = np.fft.fft(K2[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.fftfreq(len(K2[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/21:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


#         Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        fft = np.fft.fft(K2_filtrowane[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.fftfreq(len(K2[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/22:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


#         Fr , Fr2 = fourier(K2[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)
        fft = np.fft.fft(K2_filtrowane[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/23:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz , Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/24:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/25:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/26:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , START , STOP , up , down)
22/27:
F = np.arange(0 , 200,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/28:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/29:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/30:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        print(Fr2)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/31:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        print(i,j,":"Fr2)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/32:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        print(i,j,":",Fr2)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/33:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        print(i,j,":",Fr2)
        print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/34:
F = np.arange(0 , 20,1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        if i==0 and j == 0:
            print(i,j,":",Fr2)
            print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/35:
F = np.arange(0 , 30, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
        if i==0 and j == 0:
            print(i,j,":",Fr2)
            print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/36:
F = np.arange(0 , 30, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/37:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/38:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta)
    N = len(s1)
    for i in range(-delta, delta):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
22/39:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
22/40:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
22/41:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
22/42:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K = rysuj_koreluj(EEG_2D , CH , CH_N , DELTA , START , STOP)
22/43:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta)
    N = len(s1)
    for i in range(-delta, delta):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
22/44:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
22/45: # !pip3 install -U --upgrade --force-reinstall saffy
22/46:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
22/47:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K = rysuj_koreluj(EEG_2D , CH , CH_N , DELTA , START , STOP)
22/48:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
22/49:
'''Poziom istotności.
    BEZ FILTRA.'''
eN = 1000

max_k , up , down = przedzialy(EEG_2D , CH_N , START , STOP , eN)
print(up , down)
23/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
23/2: %matplotlib inline
23/3:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta)
    N = len(s1)
    for i in range(-delta, delta):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
23/4:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
23/5:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
23/6: # !pip3 install -U --upgrade --force-reinstall saffy
23/7:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
23/8:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K = rysuj_koreluj(EEG_2D , CH , CH_N , DELTA , START , STOP)
23/9:
'''Poziom istotności.
    BEZ FILTRA.'''
eN = 1000

max_k , up , down = przedzialy(EEG_2D , CH_N , START , STOP , eN)
print(up , down)
23/10:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , START , STOP , up , down)
23/11:
''' Zabawa z przefiktrowanym sygnałem
                FILTROWANIE'''
EEG2 = saffy.SignalManager(generator=svarog(pliki['closed']))
EEG2.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)
EEG2.extract_channels(CH)
EEG_2D_F = EEG2.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D_F = EEG_2D_F - (EEG_2D_F[-1,:] + EEG_2D_F[-2,:])/2 #montaz - średnia z uszu   
EEG_2D_F = EEG_2D_F[0:-2,:] #usuwamy kanały uszne
23/12:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                Z FILTREM.'''
fig = plt.figure(figsize = (50,50))
K_filtrowane = rysuj_koreluj(EEG_2D_F , CH , CH_N , DELTA , START , STOP)
23/13:
'''Poziom istotności.
    Z FILTREM.'''
max_k_filtrowane , up_filt , down_filt = przedzialy(EEG_2D_F , CH_N , START , STOP , eN)
print(up_filt , down_filt)
23/14:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.
                            Z FILTREM'''
fig = plt.figure(figsize = (50,50))
K2_filtrowane = rysuj_cool_koreluj(EEG_2D_F , CH , CH_N , START , STOP , up_filt , down_filt)
23/15:
F = np.arange(0 , 20, 0.25)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/16:
F = np.arange(0 , 10, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for i in range(CH_N):
    for j in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/17:
F = np.arange(0 , 10, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/18:
F = np.arange(0 , 10, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


#         Fr , Fr2 = fourier(K[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

        fft = np.fft.fft(K[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/19:
F = np.arange(0 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
        
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(F[np.where(Fr == np.max(Fr))]) )
#         plt.plot(F , Fr)
#         plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


        Fr , Fr2 = fourier(K[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/20:
F = np.arange(0 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
        Fr , Fr2 = fourier(K[i,j], F , Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.title( str(F[np.where(Fr == np.max(Fr))]) )
        plt.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


#         Fr , Fr2 = fourier(K[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/21:
F = np.arange(0 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
        Fr , Fr2 = fourier(K[i,j], F , Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.title( str(F[np.where(Fr == np.max(Fr))]) )
        plt.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


#         Fr , Fr2 = fourier(K[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.plot(Sigma)
#         plt.ylim(-np.pi , np.pi)
plt.show()
23/22:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
        Fr , Fr2 = fourier(K[i,j], F , Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.title( str(F[np.where(Fr == np.max(Fr))]) )
        plt.plot(F , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


#         Fr , Fr2 = fourier(K[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.plot(Sigma)
#         plt.ylim(-np.pi , np.pi)
plt.show()
23/23:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
        Fr = np.fft.rfft(K[i,j])
        Fr = np.abs(Fr)
        cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.title( str(F[np.where(Fr == np.max(Fr))]) )
        plt.plot(cz , Fr)
        plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')


#         Fr , Fr2 = fourier(K[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.plot(Sigma)
#         plt.ylim(-np.pi , np.pi)
plt.show()
23/24:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
        Fr = np.fft.rfft(K[i,j])
        Fr = np.abs(Fr)
        cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
        plt.plot(cz , Fr)
        plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
        plt.xlim(0,30)

#         Fr , Fr2 = fourier(K[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.plot(Sigma)
#         plt.ylim(-np.pi , np.pi)
plt.show()
23/25:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
        Fr = np.fft.rfft(K2_filtrowane[i,j])
        Fr = np.abs(Fr)
        cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
        plt.plot(cz , Fr)
        plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
        plt.xlim(0,30)

#         Fr , Fr2 = fourier(K[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.plot(Sigma)
#         plt.ylim(-np.pi , np.pi)
plt.show()
23/26:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

        Fr , Fr2 = fourier(K_filtrowane[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F,Fr)
#         plt.ylim(-np.pi , np.pi)
plt.show()
23/27:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(F,Fr)
#         plt.ylim(-np.pi , np.pi)
plt.show()
23/28:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.fft(K[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/29:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

        fft = np.fft.fft(K[i,j])
        Sigma = np.arctan(fft.real/fft.imag)#np.angle(fft)
        cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/30:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

        fft = np.fft.fft(K[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.fftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/31:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

        fft = np.fft.rfft(K[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz,Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/32:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

#         Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

        fft = np.fft.rfft(K_filtrowane[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz,Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/33:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

#         Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

        fft = np.fft.rfft(K2_filtrowane[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(cz,Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/34:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

#         Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

        fft = np.fft.rfft(K2_filtrowane[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
23/35:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

#         Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

        fft = np.fft.rfft(K2[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
24/1:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}

EEG = open(pliki[open]).read()
print(EEG.shape)
24/2:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}

EEG = open(pliki[open]+'.raw').read()
print(EEG.shape)
24/3:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}

ch = 26
Fs = 256
fin = open(pliki[open]+'.raw', 'rb') 
EEG = np.fromfile(fin, dtype='<f') 
fin.close() 
s = np.reshape(EEG,(len(EEG)//ch,ch))

print(s)
24/4:
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
import scipy.signal as sg
from  scipy.signal import freqz, group_delay, firwin, firwin2, butter, buttord, lfilter, filtfilt
24/5:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}

ch = 26
Fs = 256
fin = open(pliki[open]+'.raw', 'rb') 
EEG = np.fromfile(fin, dtype='<f') 
fin.close() 
s = np.reshape(EEG,(len(EEG)//ch,ch))

print(s)
24/6:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}

ch = 26
Fs = 256
fin = open('mateusz_oczy_zamkniete.raw', 'rb') 
EEG = np.fromfile(fin, dtype='<f') 
fin.close() 
s = np.reshape(EEG,(len(EEG)//ch,ch))

print(s)
24/7:
pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}

ch = 26
Fs = 256
fin = open('mateusz_oczy_zamkniete.raw', 'rb') 
EEG = np.fromfile(fin, dtype='<f') 
fin.close() 
s = np.reshape(EEG,(len(EEG)//ch,ch))

print(s.shape)
23/36:
print(K2[0,1])
print(K2[1,0])
23/37:
print(K2[0,1][0])
print(K2[1,0][-1])
23/38:
print(K2[0,1][0])
print(K2[1,0][-2])
23/39:
print(K2[0,1][1])
print(K2[1,0][-1])
23/40:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta)
    N = len(s1)
    for i in range(-delta, delta):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.zeros( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:(stop)] , M_syg[j,start:(stop) ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
23/41: print(np.empty(40))
23/42:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta)
    N = len(s1)
    for i in range(-delta, delta):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.zeros( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:(stop+1)] , M_syg[j,start:(stop+1) ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
23/43:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , START , STOP , up , down)
23/44:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta)
    N = len(s1)
    for i in range(-delta, delta):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.zeros( ( ch, ch , (stop-start+1) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:(stop+1)] , M_syg[j,start:(stop+1) ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
23/45:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2) + 1
    gammy = np.zeros(2*delta)
    N = len(s1)
    for i in range(-delta, delta):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.zeros( ( ch, ch , (stop-start+1) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:(stop+1)] , M_syg[j,start:(stop+1) ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
23/46: print(np.empty(40))
23/47:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
23/48:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
23/49:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+1] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.zeros( ( ch, ch , (stop-start+1) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:(stop+1)] , M_syg[j,start:(stop+1) ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
23/50: print(np.empty(40))
23/51:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
23/52:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
23/53:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta)
    N = len(s1)
    for i in range(-delta, delta):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.zeros( ( ch, ch , (stop-start+1) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:(stop+1)] , M_syg[j,start:(stop+1) ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
23/54: print(np.empty(40))
23/55:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
23/56:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
25/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
25/2: %matplotlib inline
25/3:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta)
    N = len(s1)
    for i in range(-delta, delta):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.zeros( ( ch, ch , (stop-start+1) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:(stop+1)] , M_syg[j,start:(stop+1) ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
25/4: print(np.empty(40))
25/5:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
25/6:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
25/7:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop] , M_syg[j,start:stop ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
25/8: print(np.empty(40))
25/9:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
25/10:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
25/11:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-len(kor)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start+1) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop+1] , M_syg[j,start:stop+1 ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
25/12: print(np.empty(40))
25/13:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
25/14:
'''       TESTY2

    korelacja kwadratów'''


signal = np.array([0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0])
signal2 = np.array([0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0])

signal = signal - np.mean(signal)
signal2 = signal2 - np.mean(signal2)

plt.plot(signal , color = 'red')
plt.plot(signal2)
plt.title("sygały kwadratowe, przesunięte w fazie")
plt.show()
print(f"długość sygnałów {len(signal)}")

kor = koreluj(signal, signal2,len(signal))
plt.plot(kor)
plt.title("Korelacja kwadratów (metoda z zajęć)")
plt.show()
print(f"długość korealcji z zajęć: {len(kor)}, przy delcie = {len(signal)}")

kor2 = cool_koreluj(signal,signal2)
plt.plot(kor2)
plt.title("korelacja kwadratów (metoda z scipy.stats)")
plt.show()

print(f"długość korealcji mądrej: {len(kor2)}")
25/15:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , START , STOP , up , down)
25/16:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
25/17:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K = rysuj_koreluj(EEG_2D , CH , CH_N , DELTA , START , STOP)
25/18:
'''Poziom istotności.
    BEZ FILTRA.'''
eN = 1000

max_k , up , down = przedzialy(EEG_2D , CH_N , START , STOP , eN)
print(up , down)
25/19:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej. Z przedziałami ufności.
                            Liczy sie szybko.
                            BEZ FILTRA.'''
fig = plt.figure(figsize = (50,50))
K2 = rysuj_cool_koreluj(EEG_2D , CH , CH_N , START , STOP , up , down)
25/20:
print(K2[0,1][1])
print(K2[1,0][-1])
25/21:
print(K2[0,1][0])
print(K2[1,0][-1])
25/22:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG2.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

#         Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

        fft = np.fft.rfft(K2[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
25/23:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

#         Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

        fft = np.fft.rfft(K2[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
25/24:
''' Zabawa z przefiktrowanym sygnałem
                FILTROWANIE'''
EEG2 = saffy.SignalManager(generator=svarog(pliki['closed']))
EEG2.butter_bandpass_filter(lowcut=8, highcut=12, order=5, method=None)
EEG2.extract_channels(CH)
EEG_2D_F = EEG2.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D_F = EEG_2D_F - (EEG_2D_F[-1,:] + EEG_2D_F[-2,:])/2 #montaz - średnia z uszu   
EEG_2D_F = EEG_2D_F[0:-2,:] #usuwamy kanały uszne
25/25:
'''Korelacje metodą funkcji napisanej na zajęciach.
                Długo się liczy.
                Z FILTREM.'''
fig = plt.figure(figsize = (50,50))
K_filtrowane = rysuj_koreluj(EEG_2D_F , CH , CH_N , DELTA , START , STOP)
25/26:
'''Poziom istotności.
    Z FILTREM.'''
max_k_filtrowane , up_filt , down_filt = przedzialy(EEG_2D_F , CH_N , START , STOP , eN)
print(up_filt , down_filt)
25/27:
''' Korealcje metodą mądrą z scipy.stats , normalizacją i odejmowaniem średniej.
                            Liczy sie szybko.
                            Z FILTREM'''
fig = plt.figure(figsize = (50,50))
K2_filtrowane = rysuj_cool_koreluj(EEG_2D_F , CH , CH_N , START , STOP , up_filt , down_filt)
25/28:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

#         Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
#         Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

        fft = np.fft.rfft(K2[i,j])
        Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
        cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
25/29:
print(K2[0,1][0])
print(K2[1,0][-1])
25/30:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.rfft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
25/31:
'''         TESTY

    autokorelacja sinusa'''

Fs = 64
t = np.arange(0,4,1/Fs)
s = np.sin(2*np.pi*t*5) + np.sin(2*np.pi*t*7) + np.sin(2*np.pi*t*13) 
czestosci = np.arange(0,Fs/2, 0.01)
print(f"długość sygnału sin: {len(s)}")

kor = koreluj(s,s,Fs)
print(f"długość autokorealcji z zajęć: {len(kor)}, przy delcie = {Fs}")
plt.plot(kor)
plt.show()

kor2 = cool_koreluj(s,s)
print(f"długość autokorealcji mądrej: {len(kor2)}")
plt.plot(kor2)
plt.show()
# plt.plot(czestosci, fourier(kor, czestosci), color = "green")
25/32:
print(K2[0,1][0])
print(K2[1,0][-1])
25/33:
print(len(K2[0,1]))
print(K2[0,1][0])
print(K2[1,0][-1])
25/34:
print(len(K2[0,1]))
print(K2[0,1][750])
print(K2[1,0][750])
25/35:
'''FUNKCJE'''


def koreluj(s1, s2, Fs): #delta - ile przesunięć
    
    'korelacja robiona na zajeciach z wzorów'
    s1 = s1.copy()
    s2 = s2.copy()
    delta = int(Fs/2)
    gammy = np.zeros(2*delta+1)
    N = len(s1)
    for i in range(-delta, delta+1):
        if i < 0:
            s1_temp=s1[0:N+i]
            s2_temp=s2[-i:N]
        else:
            s1_temp=s1[i:N]
            s2_temp=s2[0:N-i]
        gamma = np.sum((s1_temp - np.mean(s1)) *(s2_temp - np.mean(s2)))/(N-1)
        gamma = gamma  / (np.std(s1,ddof=1)*np.std(s2,ddof=1))
        gammy[delta+i] = gamma
    return gammy

def rysuj_koreluj(M_syg , CH_names ,  ch , delta , start , stop , up = 0, down = 0):
    KORELACJE = np.empty( ( ch , ch , delta+1) )

    for i in range(ch):
        for j in range(ch):
        
            KORELACJE[i,j,:] = koreluj(M_syg[i,start:stop] , M_syg[j,start:stop] , delta)
            ax1 = plt.subplot( ch, ch , ( (i*ch) + j+1 ) )
            plt.title(CH_names[i] + 'x' + CH_names[j])
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE[i,j])
        
    plt.show()
    return KORELACJE

def fourier(kor, F , Fs):
    
    'fourier z wzorów na zajęciach'
    
    s = np.zeros(len(F),dtype=complex)
    s2 = np.zeros(len(F),dtype=complex)
    for i,f in enumerate(F):
        a=0
        for tau, gamma in enumerate(kor):
            t = (tau-(len(kor)-1)/2)/Fs
            a += gamma*np.exp(-2*np.pi*1j*f*t)
        s[i] = np.absolute(a)
        s2[i] = a
    return s , s2

def cool_koreluj(syg1,syg2):
    
    'korelacja liczona przy pomocy dostępnych bibliotek, odpowiednio normalizowana wg wzorów.'
    
    S1 = syg1 - np.mean(syg1)
    S2 = syg2 - np.mean(syg2)
    norm = np.std(syg1) * np.std(syg2) * len(syg1)
    korelacja = ss.correlate( S1 , S2 , mode = 'same' , method = 'direct') / norm
    return korelacja

def rysuj_cool_koreluj(M_syg ,CH_names , ch , start , stop , up = 0 , down = 0 ):
    KORELACJE2 = np.empty( ( ch, ch , (stop-start+1) ) )

    for i in range(ch):
        for j in range(ch):

            KORELACJE2[i,j,:] = cool_koreluj( M_syg[i,start:stop+1] , M_syg[j,start:stop+1 ] )

            ax1 = plt.subplot(ch, ch, ( i*ch) + j + 1 )
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            
            plt.axhline(0, color = 'g')
            if up:
                plt.axhline(up, color = 'r')
            if down:
                plt.axhline(down, color = 'r')
            plt.ylim(-1,1)
            ax1.plot(KORELACJE2[i,j])
    fig = plt.figure(figsize = (50,50))
    plt.show()
    return KORELACJE2

def przedzialy(M_syg , ch , start , stop , N): 
    max_corr = np.zeros(N)
    M_syg = M_syg.copy()
    for k in range(N):
        corr_matrix = np.zeros((ch**2,(stop-start)))
        for i in range(ch):
            for j in range(ch):
                syg1 = M_syg[i,start:stop]
                syg2 = M_syg[j,start:stop]
                np.random.shuffle(syg1)
                np.random.shuffle(syg2)  
                corr_matrix[(i*ch)+j,:] = cool_koreluj(syg1 , syg2)

                if i == j:
                    corr_matrix[(i*ch)+j,int((stop-start)/2)] = 0

        max_corr[k] = np.max(np.abs(corr_matrix))
    return max_corr , np.percentile(max_corr, 95) , -np.percentile(max_corr, 95)
25/36:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

        Fr , Fr2 = fourier(K2_filtrowane[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.rfft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
25/37:
F = np.arange(1 , 30, 1)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.rfft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
25/38:
F = np.arange(1 , 30, .25)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for j in range(CH_N):
    for i in range(CH_N):
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.rfft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
25/39:
F = np.arange(1 , 30, .25)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for i in range(CH_N):
    for j in range(CH_N):
#         if 
#         Fr = np.fft.rfft(K2_filtrowane[i,j])
#         Fr = np.abs(Fr)
#         cz = np.fft.rfftfreq(len(K2_filtrowane[i,j]),1/Fs)
#         plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
#         plt.title( str(cz[np.where(Fr == np.max(Fr))]) )
#         plt.plot(cz , Fr)
#         plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
#         plt.xlim(0,30)

        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.rfft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
        plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
        plt.plot(Sigma)
        plt.ylim(-np.pi , np.pi)
plt.show()
25/40:
F = np.arange(1 , 30, .25)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        if i <= j:
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.title( str(F[np.where(Fr == np.max(Fr))]) )
            plt.plot(F , Fr)
            plt.axvline(cz[np.where(Fr == np.max(Fr))], color = 'r')
        else:
            Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.rfft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.plot(Sigma)
            plt.ylim(-np.pi , np.pi)
plt.show()
25/41:
F = np.arange(1 , 30, .25)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        if i <= j:
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.title(str(F[np.where(Fr == np.max(Fr))]) )
            plt.plot(F , Fr)
            plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        else:
            Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.rfft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.plot(Sigma)
            plt.ylim(-np.pi , np.pi)
plt.show()
25/42:
F = np.arange(1 , 30, .25)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        if i <= j:
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.title(f" {CH_names[i]} x {CH_names[j]}" + str(F[np.where(Fr == np.max(Fr))]) )
            plt.plot(F , Fr)
            plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        else:
            Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.rfft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
            plt.title(f" {CH_names[i]} x {CH_names[j]}")
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.plot(Sigma)
            plt.ylim(-np.pi , np.pi)
plt.show()
25/43:
F = np.arange(1 , 30, .25)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        if i <= j:
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.title(f" {CH[i]} x {CH[j]}" + str(F[np.where(Fr == np.max(Fr))]) )
            plt.plot(F , Fr)
            plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        else:
            Sigma = np.arctan(Fr2.imag/Fr2.real)
#         if i==0 and j == 0:
#             print(i,j,":",Fr2)
#             print(Sigma)
#         Sigma = np.angle(Fr2)

#         fft = np.fft.rfft(K2[i,j])
#         Sigma = np.arctan(fft.imag/fft.real)#np.angle(fft)
#         cz = np.fft.rfftfreq(len(K[i,j]),1/Fs)
            plt.title(f" {CH[i]} x {CH[j]}")
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.plot(Sigma)
            plt.ylim(-np.pi , np.pi)
plt.show()
25/44:
F = np.arange(1 , 30, .25)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        if i <= j:
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.title(f" {CH[i]} x {CH[j]}" +'/n' +str(F[np.where(Fr == np.max(Fr))]) )
            plt.plot(F , Fr)
            plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        else:
            Sigma = np.arctan(Fr2.imag/Fr2.real)
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.title(f" {CH[i]} x {CH[j]}")
            plt.plot(Sigma)
            plt.ylim(-np.pi , np.pi)
plt.show()
25/45:
F = np.arange(1 , 30, .25)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        if i <= j:
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.title(f" {CH[i]} x {CH[j]}" + '\n' +str(F[np.where(Fr == np.max(Fr))]) )
            plt.plot(F , Fr)
            plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        else:
            Sigma = np.arctan(Fr2.imag/Fr2.real)
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.title(f" {CH[i]} x {CH[j]}")
            plt.plot(Sigma)
            plt.ylim(-np.pi , np.pi)
plt.show()
25/46: signal = K[0,0][1000:2000]
25/47:
retardacja = 5
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
25/48:
retardacja = 5
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
corelation = koreluj(signal0, signal1, Fs)
plt.plot(corelation)
25/49:
retardacja = 0
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
corelation = koreluj(signal0, signal1, Fs)
plt.plot(corelation)
25/50:
retardacja = 0
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
corelation = koreluj(signal0, signal1, Fs)
plt.plot(corelation)
25/51:
retardacja = 5
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
corelation = koreluj(signal0, signal1, Fs)
plt.plot(corelation)
25/52:
retardacja = 5
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
corelation = koreluj(signal0, signal1, Fs)
plt.plot(corelation)
Fr , Fr2 = fourier(corelation, F , Fs)
plt.plot(F, Fr)
25/53:
retardacja = 5
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
corelation = koreluj(signal0, signal1, Fs)
plt.plot(corelation)
pl.show()
Fr , Fr2 = fourier(corelation, F , Fs)
plt.plot(F, Fr)
25/54:
retardacja = 5
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
corelation = koreluj(signal0, signal1, Fs)
plt.plot(corelation)
plt.show()
Fr , Fr2 = fourier(corelation, F , Fs)
plt.plot(F, Fr)
25/55:
F = np.arange(1 , 30, .25)
fig = plt.figure(figsize = (50,50))
Fs = EEG.fs
for i in range(CH_N):
    for j in range(CH_N):
        Fr , Fr2 = fourier(K2[i,j], F , Fs)
        if i <= j:
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.title(f" {CH[i]} x {CH[j]}" + '\n' +str(F[np.where(Fr == np.max(Fr))]) )
            plt.plot(F , Fr)
            plt.axvline(F[np.where(Fr == np.max(Fr))], color = 'r')
        else:
            Sigma = np.arctan(Fr2.imag/Fr2.real)
            plt.subplot( CH_N , CH_N , ( (i*CH_N) + j+1 ) )
            plt.title(f" {CH[i]} x {CH[j]}")
            plt.plot(F, Sigma)
            plt.ylim(-np.pi , np.pi)
plt.show()
25/56:
retardacja = 5
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
corelation = koreluj(signal0, signal1, Fs)
plt.plot(corelation)
plt.show()
Fr , Fr2 = fourier(corelation, F , Fs)
plt.plot(F, Fr)
plt.show()
Sigma = np.arctan(Fr2.imag/Fr2.real)
plt.plot(F, Sigma)
25/57:
retardacja = 0
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
corelation = koreluj(signal0, signal1, Fs)
plt.plot(corelation)
plt.show()
Fr , Fr2 = fourier(corelation, F , Fs)
plt.plot(F, Fr)
plt.show()
Sigma = np.arctan(Fr2.imag/Fr2.real)
plt.plot(F, Sigma)
25/58:
retardacja = 0
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
corelation = koreluj(signal0, signal1, Fs)
plt.plot(corelation)
plt.show()
Fr , Fr2 = fourier(corelation, F , Fs)
plt.plot(F, Fr)
plt.show()
Sigma = np.arctan(Fr2.imag/Fr2.real)
plt.plot(F, Sigma)
plt.ylim(-np.pi , np.pi)
plt.show()
25/59:
retardacja = 5
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
corelation = koreluj(signal0, signal1, Fs)
plt.plot(corelation)
plt.show()
Fr , Fr2 = fourier(corelation, F , Fs)
plt.plot(F, Fr)
plt.show()
Sigma = np.arctan(Fr2.imag/Fr2.real)
plt.plot(F, Sigma)
plt.ylim(-np.pi , np.pi)
plt.show()
25/60:
retardacja = 1
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
signal0 = EEG_2D_F[0][start:stop]
signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
corelation = koreluj(signal0, signal1, Fs)
plt.plot(corelation)
plt.show()
Fr , Fr2 = fourier(corelation, F , Fs)
plt.plot(F, Fr)
plt.show()
Sigma = np.arctan(Fr2.imag/Fr2.real)
plt.plot(F, Sigma)
plt.ylim(-np.pi , np.pi)
plt.show()
25/61:
retardacja = [0,1,2,3,4]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000

for k in retardacja:
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja:stop + retardacja]
    plt.subplot( 3 , len(retardacja) , 3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.subplot( 3 , len(retardacja) , 1+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.subplot( 3 , len(retardacja) , 2+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.ylim(-np.pi , np.pi)
plt.show()
25/62:
retardacja = [0,1,2,3,4]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000

for k in retardacja:
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja[k]:stop + retardacja[k]]
    plt.subplot( 3 , len(retardacja) , 3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.subplot( 3 , len(retardacja) , 1+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.subplot( 3 , len(retardacja) , 2+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.ylim(-np.pi , np.pi)
plt.show()
25/63:
retardacja = [0,1,2,3,4]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000

for k in retardacja:
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja[k]:stop + retardacja[k]]
    plt.subplot( 3 , len(retardacja) , 1+3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.subplot( 3 , len(retardacja) , 2+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.subplot( 3 , len(retardacja) , 3+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.ylim(-np.pi , np.pi)
plt.show()
25/64:
retardacja = [0,1,2,3,4]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
fig = plt.figure(figsize = (50,50))
for k in retardacja:
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja[k]:stop + retardacja[k]]
    plt.subplot( 3 , len(retardacja) , 1+3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.subplot( 3 , len(retardacja) , 2+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.subplot( 3 , len(retardacja) , 3+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.ylim(-np.pi , np.pi)
plt.show()
25/65:
retardacja = [0,1,2,3,4]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
fig = plt.figure(figsize = (30,50))
for k in retardacja:
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja[k]:stop + retardacja[k]]
    plt.subplot(len(retardacja),3 , 1+3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.title('przesunięcie o:f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 2+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.subplot(len(retardacja),3 , 3+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.ylim(-np.pi , np.pi)
plt.show()
25/66:
retardacja = [0,1,2,3,4]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
fig = plt.figure(figsize = (30,50))
for k in retardacja:
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja[k]:stop + retardacja[k]]
    plt.subplot(len(retardacja),3 , 1+3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.title('Autokorelacja, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 2+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.title('Widmo mocy, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 3+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.title('Przesuniecie fazowe, retardacja:' + f"{retardacja[k]}" )
    plt.ylim(-np.pi , np.pi)
plt.show()
25/67:
retardacja = [0,1,2,3,4]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
fig = plt.figure(figsize = (30,30))
for k in retardacja:
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja[k]:stop + retardacja[k]]
    plt.subplot(len(retardacja),3 , 1+3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.title('Autokorelacja, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 2+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.title('Widmo mocy, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 3+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.title('Przesuniecie fazowe, retardacja:' + f"{retardacja[k]}" )
    plt.ylim(-np.pi , np.pi)
plt.show()
25/68:
retardacja = [0,1,2,3,4]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
fig = plt.figure(figsize = (30,35))
for k in retardacja:
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja[k]:stop + retardacja[k]]
    plt.subplot(len(retardacja),3 , 1+3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.title('Autokorelacja, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 2+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.title('Widmo mocy, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 3+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.title('Przesuniecie fazowe, retardacja:' + f"{retardacja[k]}" )
    plt.ylim(-np.pi , np.pi)
plt.show()
25/69:
retardacja = [0,5,10,30]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
fig = plt.figure(figsize = (30,35))
for k in retardacja:
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja[k]:stop + retardacja[k]]
    plt.subplot(len(retardacja),3 , 1+3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.title('Autokorelacja, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 2+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.title('Widmo mocy, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 3+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.title('Przesuniecie fazowe, retardacja:' + f"{retardacja[k]}" )
    plt.ylim(-np.pi , np.pi)
plt.show()
25/70:
retardacja = [0,5,10,30]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
fig = plt.figure(figsize = (30,35))
for k in len(retardacja):
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja[k]:stop + retardacja[k]]
    plt.subplot(len(retardacja),3 , 1+3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.title('Autokorelacja, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 2+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.title('Widmo mocy, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 3+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.title('Przesuniecie fazowe, retardacja:' + f"{retardacja[k]}" )
    plt.ylim(-np.pi , np.pi)
plt.show()
25/71:
retardacja = [0,5,10,30]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
fig = plt.figure(figsize = (30,35))
for k in range(len(retardacja)):
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja[k]:stop + retardacja[k]]
    plt.subplot(len(retardacja),3 , 1+3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.title('Autokorelacja, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 2+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.title('Widmo mocy, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 3+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.title('Przesuniecie fazowe, retardacja:' + f"{retardacja[k]}" )
    plt.ylim(-np.pi , np.pi)
plt.show()
25/72:
retardacja = [0,5,10,30, Fs/2]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
fig = plt.figure(figsize = (30,35))
for k in range(len(retardacja)):
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja[k]:stop + retardacja[k]]
    plt.subplot(len(retardacja),3 , 1+3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.title('Autokorelacja, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 2+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.title('Widmo mocy, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 3+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.title('Przesuniecie fazowe, retardacja:' + f"{retardacja[k]}" )
    plt.ylim(-np.pi , np.pi)
plt.show()
25/73:
retardacja = [0,5,10,30, int(Fs/2)]
F = np.arange(1 , 30, .25)
start = 1000
stop = 3000
fig = plt.figure(figsize = (30,35))
for k in range(len(retardacja)):
    signal0 = EEG_2D_F[0][start:stop]
    signal1 = EEG_2D_F[0][start + retardacja[k]:stop + retardacja[k]]
    plt.subplot(len(retardacja),3 , 1+3*k)
    corelation = koreluj(signal0, signal1, Fs)
    plt.plot(corelation)
    plt.title('Autokorelacja, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 2+3*k)
    Fr , Fr2 = fourier(corelation, F , Fs)
    plt.plot(F, Fr)
    plt.title('Widmo mocy, retardacja:' + f"{retardacja[k]}" )
    plt.subplot(len(retardacja),3 , 3+3*k)
    Sigma = np.arctan(Fr2.imag/Fr2.real)
    plt.plot(F, Sigma)
    plt.title('Przesuniecie fazowe, retardacja:' + f"{retardacja[k]}" )
    plt.ylim(-np.pi , np.pi)
plt.show()
26/1:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return chr(a%256) + chr(a/256)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException, e:
            print "Nieprawidłowa nazwa portu lub port zajęty."
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = chr(3) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = period - bright
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = chr(4) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
            print(period)
 
        self.send(str)
26/2:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return chr(a%256) + chr(a/256)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print "Nieprawidłowa nazwa portu lub port zajęty."
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = chr(3) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = period - bright
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = chr(4) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
            print(period)
 
        self.send(str)
26/3:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return chr(a%256) + chr(a/256)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = chr(3) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = period - bright
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = chr(4) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
            print(period)
 
        self.send(str)
26/4: !pip3 install serial
26/5: !pip3 install serial --user
26/6: !pip3 install --user serial
26/7: !pip3 install serial
27/1: !pip3 install serial
27/2: !pip3 install serial
27/3:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return chr(a%256) + chr(a/256)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = chr(3) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = period - bright
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = chr(4) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
            print(period)
 
        self.send(str)
27/4:
import SerialPort as SP
sp = SP.SerialPort('/dev/ttyUSB0')
27/5:
SP = SerialPort
sp = SP.SerialPort('/dev/ttyUSB0')
27/6:
SP = SerialPort
sp = SP('/dev/ttyUSB0')
27/7:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return chr(a%256) + chr(a/256)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = chr(3) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = period - bright
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = chr(4) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
            print(period)
 
        self.send(str)
28/1:
import numpy as np
import matplotlib as plt
28/2:
import numpy as np
import matplotlib.pyplot as plt
28/3:
import numpy as np
import matplotlib as plt
28/4:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sugma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss

plt.plot(sinus(2, 0, 128, 1))
plt show()
28/5:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sugma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss

plt.plot(sinus(2, 0, 128, 1))
plt.show()
28/6:
import numpy as np
import matplotlib.pyplot as plt
28/7:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sugma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss

plt.plot(sinus(2, 0, 128, 1))
plt.show()
28/8:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sugma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()
28/9:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[0])
plt.show()
28/10:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[0])
plt.show()
28/11:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[0])
plt.show()
28/12:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[0])
plt.show()
28/13:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[0], g1(0, 0.3, 128, 1)[1])
plt.show()
28/14:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[1], g1(0, 0.3, 128, 1)[0])
plt.show()
28/15:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2)) if czas >= t0 else 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[1], g1(0, 0.3, 128, 1)[0])
plt.show()

plt.plot(g3(0, 0.3, 128, 1)[1], g3(0, 0.3, 128, 1)[0])
plt.show()
28/16:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:T*Fs] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[1], g1(0, 0.3, 128, 1)[0])
plt.show()

plt.plot(g3(0, 0.3, 128, 1)[1], g3(0, 0.3, 128, 1)[0])
plt.show()
28/17:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return gradient, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:T*Fs] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[1], g1(0, 0.3, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.show()

plt.plot(g3(0, 0.3, 128, 1)[1], g3(0, 0.3, 128, 1)[0])
plt.show()
28/18:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:T*Fs] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[1], g1(0, 0.3, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.show()

plt.plot(g3(0, 0.3, 128, 1)[1], g3(0, 0.3, 128, 1)[0])
plt.show()
28/19:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:T*Fs] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[1], g1(0, 0.3, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axhline(0)
plt.show()

plt.plot(g3(0, 0.3, 128, 1)[1], g3(0, 0.3, 128, 1)[0])
plt.show()
28/20:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:T*Fs] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[1], g1(0, 0.3, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0)
plt.show()

plt.plot(g3(0, 0.3, 128, 1)[1], g3(0, 0.3, 128, 1)[0])
plt.show()
28/21:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:T*Fs] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0, 0.3, 128, 1)[1], g1(0, 0.3, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0, 0.3, 128, 1)[1], g3(0, 0.3, 128, 1)[0])
plt.show()
28/22:
def szumuj_N(N, sygnal):
    tablica = np.zeros(N, len(syganl))
    for i in range(0, N):
        tablica[i] = sygnal + random.randn(len(sygnal))
    return np.mean(tablica, axis=1)
28/23:
def szumuj_N(N, sygnal):
    tablica = np.zeros(N, len(syganl))
    for i in range(0, N):
        tablica[i] = sygnal + random.randn(len(sygnal))
    return np.mean(tablica, axis=1)
28/24:
sygnal = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, sygnal[0])
28/25:
sygnal = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, sygnal[0])
28/26:
sygnal = sinus(2, 0, 128, 1)[0]
szumowany = szumuj_N(30, sygnal)
28/27:
signal1 = sinus(2, 0, 128, 1)[0]
szumowany = szumuj_N(30, signal1)
28/28:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, signal1)
28/29:
def szumuj_N(N, sygnal):
    tablica = np.zeros(N, len(sygnal))
    for i in range(0, N):
        tablica[i] = sygnal + random.randn(len(sygnal))
    return np.mean(tablica, axis=1)
28/30:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, signal1)
28/31:
def szumuj_N(N, sygnal):
    tablica = np.zeros(N, len(sygnal))
    for i in range(0, N):
        tablica[i] = sygnal + random.randn(len(sygnal))
    return np.mean(tablica, axis=1)
28/32:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, signal1)
28/33:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, signal1[0])
28/34:
def szumuj_N(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + random.randn(len(sygnal))
    return np.mean(tablica, axis=1)
28/35:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, signal1[0])
28/36:
def szumuj_N(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + NP.random.randn(len(sygnal))
    return np.mean(tablica, axis=1)
28/37:
def szumuj_N(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + np.random.randn(len(sygnal))
    return np.mean(tablica, axis=1)
28/38:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, signal1[0])
28/39: plt.plot(szumowany)
28/40:
def szumuj_N(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + 0.1*np.random.randn(len(sygnal))
    return np.mean(tablica, axis=1)
28/41:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, signal1[0])
28/42: plt.plot(szumowany)
28/43:
def szumuj_N(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + 0.01*np.random.randn(len(sygnal))
    return np.mean(tablica, axis=1)
28/44:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, signal1[0])
28/45: plt.plot(szumowany)
28/46:
def szumuj_N(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + 0.01*np.random.randn(len(sygnal))
    return np.mean(tablica, axis=0)
28/47:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, signal1[0])
28/48: plt.plot(szumowany)
28/49:
def szumuj_N(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + 0.1*np.random.randn(len(sygnal))
    return np.mean(tablica, axis=0)
28/50:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, signal1[0])
28/51: plt.plot(szumowany)
28/52:
def szumuj_N(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + np.random.randn(len(sygnal))
    return np.mean(tablica, axis=0)
28/53:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(30, signal1[0])
28/54: plt.plot(szumowany)
28/55:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(100, signal1[0])
28/56: plt.plot(szumowany)
28/57:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(1000, signal1[0])
28/58: plt.plot(szumowany)
28/59:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(10000, signal1[0])
28/60: plt.plot(szumowany)
28/61:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(10, signal1[0])
28/62: plt.plot(szumowany)
28/63:
def szumuj_N(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + 10*np.random.randn(len(sygnal))
    return np.mean(tablica, axis=0)
28/64:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(10, signal1[0])
28/65: plt.plot(szumowany)
28/66:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(10000, signal1[0])
28/67: plt.plot(szumowany)
28/68:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(100000, signal1[0])
28/69: plt.plot(szumowany)
28/70:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(1000000, signal1[0])
28/71: plt.plot(szumowany)
28/72:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(1, signal1[0])
28/73: plt.plot(szumowany)
28/74:
signal1 = g1(0, 0.3, 128, 1)
szumowany = szumuj_N(1, signal1[0])
28/75:
signal1 = g1(0, 0.3, 128, 1)
szumowany = szumuj_N(1, signal1[0])
plt.plot(signal1)
plt.show()
28/76:
signal1 = g1(0, 0.3, 128, 1)
szumowany = szumuj_N(1, signal1[0])
plt.plot(szumowany)
plt.show()
28/77:
signal1 = g1(0, 0.3, 128, 1)
szumowany = szumuj_N(1000, signal1[0])
plt.plot(szumowany)
plt.show()
28/78:
signal1 = g1(0, 0.3, 128, 1)
szumowany = szumuj_N(10000, signal1[0])
plt.plot(szumowany)
plt.show()
28/79:
signal1 = g1(0, 0.3, 128, 1)
szumowany = szumuj_N(100000, signal1[0])
plt.plot(szumowany)
plt.show()
28/80:
def szumuj_N(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal))
    return np.mean(tablica, axis=0)
28/81:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(1, signal1[0])
28/82: plt.plot(szumowany)
28/83:
signal1 = g1(0, 0.3, 128, 1)
szumowany = szumuj_N(100000, signal1[0])
plt.plot(szumowany)
plt.show()
28/84:
signal1 = g1(0, 0.3, 128, 1)
szumowany = szumuj_N(1, signal1[0])
plt.plot(szumowany)
plt.show()
28/85:
signal1 = g1(0, 0.3, 128, 1)
szumowany = szumuj_N(5, signal1[0])
plt.plot(szumowany)
plt.show()
28/86:
signal1 = g1(0, 0.3, 128, 1)
szumowany = szumuj_N(20, signal1[0])
plt.plot(szumowany)
plt.show()
28/87:
signal1 = g1(0, 0.1, 128, 1)
szumowany = szumuj_N(20, signal1[0])
plt.plot(szumowany)
plt.show()
28/88:
signal1 = g1(0, 0.1, 128, 1)
szumowany = szumuj_N(2000, signal1[0])
plt.plot(szumowany)
plt.show()
28/89:
signal1 = g1(0.3, 0.02, 128, 1)
szumowany = szumuj_N(2000, signal1[0])
plt.plot(szumowany)
plt.show()
28/90:
signal1 = g1(0.3, 0.02, 128, 1)
szumowany = szumuj_N(20000, signal1[0])
plt.plot(szumowany)
plt.show()
28/91:
signal1 = g1(0.3, 0.02, 128, 1)
szumowany = szumuj_N(20, signal1[0])
plt.plot(szumowany)
plt.show()
28/92:
signal1 = g1(0.3, 0.02, 128, 1)
szumowany = szumuj_N(200, signal1[0])
plt.plot(szumowany)
plt.show()
28/93:
signal1 = g1(0.3, 0.02, 128, 1)
szumowany = szumuj_N(2000, signal1[0])
plt.plot(szumowany)
plt.show()
28/94:
signal1 = g1(0.3, 0.02, 128, 1)
szumowany = szumuj_N(2000, signal1[0])
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
28/95:
signal1 = g1(0.3, 0.02, 128, 1)
szumowany = szumuj_N(2000, signal1[0])
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/96:
signal1 = g1(0.3, 0.02, 128, 1)
szumowany = szumuj_N(20000, signal1[0])
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/97:
signal1 = g1(0.3, 0.02, 128, 1)
szumowany = szumuj_N(2, signal1[0])
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/98:
signal1 = g1(0.3, 0.02, 128, 1)
wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N(2, signal1[0])
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/99:
signal1 = g1(0.3, 0.02, 128, 1)
wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N(2000, signal1[0])
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/100:
signal1 = g1(0.3, 0.02, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N(2000, signal1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/101:
signal1 = g1(0.3, 0.02, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N(20000, signal1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/102:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    for i, n in enumerate(N):
        szumowany = szumuj_N(20000, signal[0])
        plt.subplot(2,3,i)
        plt.plot(signal[1],szumowany)
        plt.title(np.var(szumowany))
    plt.show()
28/103:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    for i, n in enumerate(N):
        szumowany = szumuj_N(20000, signal[0])
        plt.subplot(2,3,i)
        plt.plot(signal[1],szumowany)
        plt.title(np.var(szumowany))
    plt.show()
28/104:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    for i, n in enumerate(N):
        szumowany = szumuj_N(20000, signal[0])
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(np.var(szumowany))
    plt.show()
28/105:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    plt.show()
    for i, n in enumerate(N):
        szumowany = szumuj_N(20000, signal[0])
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(np.var(szumowany))
    plt.show()
28/106:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    plt.show()
    for i, n in enumerate(N):
        szumowany = szumuj_N(20000, signal[0])
        fig = plt.figure(figsize = (20,12))
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(np.var(szumowany))
    plt.show()
28/107:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    plt.show()
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        fig = plt.figure(figsize = (12,20))
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(np.var(szumowany))
    plt.show()
28/108:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    plt.show()
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.figure(figsize = (12,20))
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(np.var(szumowany))
    plt.show()
28/109:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    plt.show()
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(2,3,i+1)
        plt.figure(figsize = (12,20))
        plt.plot(signal[1],szumowany)
        plt.title(np.var(szumowany))
    plt.show()
28/110:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    plt.show()
    plt.figure(figsize = (12,20))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(np.var(szumowany))
    plt.show()
28/111:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(np.var(szumowany))
    plt.show()
28/112:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(f'Wariancja przy {n} powtórzeniach: ', np.var(szumowany))
    plt.show()
28/113:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(f'Wariancja przy {n} powtórzeniach: {np.var(szumowany)}')
    plt.show()
28/114:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 2)}')
    plt.show()
28/115:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    wariancja = np.var(signal[0])
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 3)}')
    plt.show()
28/116:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 3)}')
    plt.show()
28/117:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:T*Fs] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/118:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:np.where(gauss==np.max(guass)) = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/119:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:np.where(gauss==np.max(guass))] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/120:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:np.where(gauss==np.max(gauss))] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/121:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:t0*Fs] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/122:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:int(t0*Fs)] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/123:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:int(t0*Fs)] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/124:
def szumuj_N(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal))
    return np.mean(tablica, axis=0)
28/125:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:int(t0*Fs)] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0, 0.02, 128, 1)[1], g3(0, 0.02, 128, 1)[0])
plt.show()
28/126:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:int(t0*Fs)] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/127:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(-T,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:int(t0*Fs)] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/128:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:int(t0*Fs)] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0, 0.3, 128, 1)[1], g2(0, 0.3, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/129:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:int(t0*Fs)] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0.3, 0.02, 128, 1)[1], g2(0.3, 0.02, 128, 1)[0])
plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/130:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:int(t0*Fs)] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0.3, 0.02, 128, 1)[1], g2(0.3, 0.02, 128, 1)[0])
#plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/131:
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(2,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 3)}')
    plt.show()
28/132:
N = [1, 10, 100, 1000, 10000, 100000, 1000000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(2,4,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 3)}')
    plt.show()
28/133:
N = [1, 10, 100, 1000, 10000, 100000, 1000000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(3,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 4)}')
    plt.show()
28/134:
def szumuj_N_sinus(N, sygnal, sinus):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + sinus
    return np.mean(tablica, axis=0)
28/135:
signal1 = g1(0.3, 0.02, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N(20000, signal1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/136:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(2, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1, sinus1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/137:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.3, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1, sinus1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/138:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1, sinus1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/139:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(20, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1, sinus1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/140:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1, sinus1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/141:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:int(t0*Fs)] = 0
    return gauss, czas

plt.plot(sinus(2, 0, 128, 1)[1],sinus(2, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0.3, 0.02, 128, 1)[1], g2(0.3, 0.02, 128, 1)[0])
#plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/142:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:int(t0*Fs)] = 0
    return gauss, czas

plt.plot(sinus(10, 0, 128, 1)[1],sinus(10, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0.3, 0.02, 128, 1)[1], g2(0.3, 0.02, 128, 1)[0])
#plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
28/143:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(10, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1, sinus1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/144:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(100, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1, sinus1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/145:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1, sinus1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/146:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1, sinus1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/147:
def szumuj_N_sinus(N, sygnal, sinus):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        losowy_sinus = sinus((0.1, np.random.random()*2*np.pi, 128, 1)
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + sinus
    return np.mean(tablica, axis=0)
28/148:
def szumuj_N_sinus(N, sygnal, sinus):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        losowy_sinus = sinus((0.1, np.random.random()*2*np.pi, 128, 1))
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + sinus
    return np.mean(tablica, axis=0)
28/149:
def szumuj_N_sinus(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        losowy_sinus = sinus((0.1, np.random.random()*2*np.pi, 128, 1))
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + sinus
    return np.mean(tablica, axis=0)
28/150:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/151:
def szumuj_N_sinus(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        losowy_sinus = sinus(0.1, np.random.random()*2*np.pi, 128, 1)
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + sinus
    return np.mean(tablica, axis=0)
28/152:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/153:
def szumuj_N_sinus(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = np.random.random()*2*np.pi
        losowy_sinus = sinus(0.1, faza, 128, 1)
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + sinus
    return np.mean(tablica, axis=0)
28/154:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/155:
def szumuj_N_sinus(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = np.random.random()*2*np.pi
        losowy_sinus = sinus(0.1, faza, 128, 1)[0]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + sinus
    return np.mean(tablica, axis=0)
28/156:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/157:
def szumuj_N_sinus(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = np.random.random()*2*np.pi
        losowy_sinus = sinus(0.1, faza, 128, 1)[0]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + losowy_sinus
    return np.mean(tablica, axis=0)
28/158:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(20000, signal1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/159:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(1, signal1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/160:
def szumuj_N_sinus(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = np.random.random()*2*np.pi
        losowy_sinus = sinus(1, faza, 128, 1)[0]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + losowy_sinus
    return np.mean(tablica, axis=0)
28/161:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(1, signal1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/162:
def szumuj_N_sinus(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = np.random.random()*2*np.pi
        losowy_sinus = sinus(10, faza, 128, 1)[0]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + losowy_sinus
    return np.mean(tablica, axis=0)
28/163:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(1, signal1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/164:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(N=1, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/165:
def szumuj_N_sinus(N, gauss, f, Fs, T, t0, sigma):
    sygnal = gauss(t0, sigma, Fs, T)
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = np.random.random()*2*np.pi
        losowy_sinus = sinus(f, faza, Fs, T)[0]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + losowy_sinus
    return np.mean(tablica, axis=0)
28/166:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(N=1, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/167:
def szumuj_N_sinus(N, gauss, f, Fs, T, t0, sigma):
    sygnal = gauss(t0, sigma, Fs, T)[0]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = np.random.random()*2*np.pi
        losowy_sinus = sinus(f, faza, Fs, T)[0]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + losowy_sinus
    return np.mean(tablica, axis=0)
28/168:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(N=1, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/169:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(N=100, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/170:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/171:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/172:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]
for f in czestosci:
    for signal in sygnaly:
        plt.plot(signal[1],signal[0])
        plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
        plt.show()
        plt.figure(figsize = (20,12))
        for i, n in enumerate(N):
            szumowany = szumuj_N_sinus(N=n, gauss=g1, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(3,3,i+1)
            plt.plot(signal[1],szumowany)
            plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 4)}')
        plt.show()
28/173:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
#         plt.figure(figsize = (20,12))
        for i, n in enumerate(N):
            szumowany = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(3,3,i+1)
            plt.plot(signal[1],szumowany)
            plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 4)}')
        plt.show()
28/174:
def szumuj_N_sinus(N, gauss, f, Fs, T, t0, sigma):
    sygnal = gauss(t0, sigma, Fs, T)[0]
    czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = np.random.random()*2*np.pi
        losowy_sinus = sinus(f, faza, Fs, T)[0]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + losowy_sinus
    return np.mean(tablica, axis=0), czas
28/175:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/176:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany[0])
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/177:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_N_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/178:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
#         plt.figure(figsize = (20,12))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(3,3,i+1)
            plt.plot(czas ,szumowany)
            plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 4)}')
        plt.show()
28/179:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (20,12))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(3,3,i+1)
            plt.plot(czas ,szumowany)
            plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 4)}')
        plt.show()
28/180:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (20,12))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(3,3,i+1)
            plt.plot(czas ,szumowany)
            plt.title(f'Wariancja przy {n} powtórzeniach i f sinusa {f}: {round(np.var(szumowany), 4)}')
        plt.show()
28/181:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (30,10))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(6,1,i+1)
            plt.plot(czas ,szumowany)
            plt.title(f'Wariancja przy {n} powtórzeniach i f sinusa {f}: {round(np.var(szumowany), 4)}')
        plt.show()
28/182:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (30,10))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany)
            plt.title(f'Wariancja przy {n} powtórzeniach i f sinusa {f}: {round(np.var(szumowany), 4)}')
        plt.show()
28/183:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (30,10))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany)
            plt.title(f'Wariancja przy {n} powtórzeniach i f sinusa {f}: {round(np.var(szumowany), 4)}')
        plt.show()
28/184:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (30,5))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany)
            plt.title(f'Wariancja przy {n} powtórzeniach i f sinusa {f}: {round(np.var(szumowany), 4)}')
        plt.show()
28/185:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (15,3))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany)
            plt.title(f'Wariancja przy {n} powtórzeniach i f sinusa {f}: {round(np.var(szumowany), 4)}')
        plt.show()
28/186:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (40,8))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany)
            plt.title(f'Wariancja przy {n} powtórzeniach i f sinusa {f}: {round(np.var(szumowany), 4)}')
        plt.show()
28/187:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (40,8))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany)
            plt.title(f'POWT:{n} , f: {f} VAR: {round(np.var(szumowany), 4)}')
        plt.show()
28/188:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (20,4))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany)
            plt.title(f'POWT:{n} , f: {f} VAR: {round(np.var(szumowany), 4)}')
        plt.show()
28/189:
czestosci = [0.01, 0.1, 1, 10, 100]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (20,4))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany)
            plt.title(f'POWT:{n} , f: {f} VAR: {round(np.var(szumowany), 3)}')
        plt.show()
28/190:
czestosci = [(0.01, 'r'), (0.1, 'b'), (1, 'g'), (10, 'p'), (100, 'y')]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f, c in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (20,4))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany, color = c)
            plt.title(f'POWT:{n} , f: {f} VAR: {round(np.var(szumowany), 3)}')
        plt.show()
28/191:
czestosci = [(0.01, 'r'), (0.1, 'b'), (1, 'g'), (10, 'purple'), (100, 'y')]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f, c in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (22,3))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany, color = c)
            plt.title(f'P:{n} , f: {f} VAR: {round(np.var(szumowany), 3)}')
        plt.show()
28/192:
def szumuj_N_sinus(N, gauss, f, Fs, T, t0, sigma):
    sygnal = gauss(t0, sigma, Fs, T)[0]
    czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = 0 #np.random.random()*2*np.pi
        losowy_sinus = sinus(f, faza, Fs, T)[0]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + losowy_sinus
    return np.mean(tablica, axis=0), czas
28/193:
czestosci = [(0.01, 'r'), (0.1, 'b'), (1, 'g'), (10, 'purple'), (100, 'y')]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f, c in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (22,3))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany, color = c)
            plt.title(f'P:{n} , f: {f} VAR: {round(np.var(szumowany), 3)}')
        plt.show()
28/194:
def szumuj_N_sinus(N, gauss, f, Fs, T, t0, sigma):
    sygnal = gauss(t0, sigma, Fs, T)[0]
    czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = np.random.random()*2*np.pi
        losowy_sinus = sinus(f, faza, Fs, T)[0]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + losowy_sinus
    return np.mean(tablica, axis=0), czas
28/195:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_N_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/196:
czestosci = [(0.01, 'r'), (0.1, 'b'), (1, 'g'), (10, 'purple'), (100, 'y')]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f, c in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (22,3))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany, color = c)
            plt.title(f'P:{n} , f: {f} VAR: {round(np.var(szumowany), 3)}')
        plt.show()
28/197:
def szumuj_N_sinus(N, gauss, f, Fs, T, t0, sigma, phi = None):
    sygnal = gauss(t0, sigma, Fs, T)[0]
    czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = np.random.random()*2*np.pi
        if phi not None:
            faza = phi
        losowy_sinus = sinus(f, faza, Fs, T)[0]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + losowy_sinus
    return np.mean(tablica, axis=0), czas
28/198:
def szumuj_N_sinus(N, gauss, f, Fs, T, t0, sigma, phi = None):
    sygnal = gauss(t0, sigma, Fs, T)[0]
    czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = np.random.random()*2*np.pi
        if phi is not None:
            faza = phi
        losowy_sinus = sinus(f, faza, Fs, T)[0]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + losowy_sinus
    return np.mean(tablica, axis=0), czas
28/199:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_N_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/200:
czestosci = [(0.01, 'r'), (0.1, 'b'), (1, 'g'), (10, 'purple'), (100, 'y')]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f, c in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (22,3))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany, color = c)
            plt.title(f'P:{n} , f: {f} VAR: {round(np.var(szumowany), 3)}')
        plt.show()
28/201:
czestosci = [(0.01, 'r'), (0.1, 'b'), (1, 'g'), (10, 'purple'), (100, 'y')]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f, c in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (22,3))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02, phi = 0)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany, color = c)
            plt.title(f'P:{n} , f: {f} VAR: {round(np.var(szumowany), 3)}')
        plt.show()
28/202:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma):
    sygnal = gauss(t0, sigma, Fs, T)[0]
    czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        losowy_sinus , t1 = sinus(f, faza1, Fs, T)
        sinus , t2 = sinus(f, faza2, Fs, T)
        sinus[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + sinus
    return np.mean(tablica, axis=0), czas
28/203:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, faza1, Fs, T)
        sinus , t2 = sinus(f=f, faza2, Fs, T)
        sinus[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = sinus
    return np.mean(tablica, axis=0), t1
28/204:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sinus , t2 = sinus(f=f, faza2, Fs, T)
        sinus[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = sinus
    return np.mean(tablica, axis=0), t1
28/205:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sinus , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        sinus[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = sinus
    return np.mean(tablica, axis=0), t1
28/206:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/207:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = sin
    return np.mean(tablica, axis=0), t1
28/208:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/209:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=100, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/210:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=10, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/211:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=5, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/212:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/213:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/214:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = var * 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = sin
    return np.mean(tablica, axis=0), t1
28/215:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/216:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =2)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/217:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =3)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/218:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = var * 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        sin[:int(len(losowy_sinus)/2)] = losowy_sinus[:int(len(losowy_sinus)/2)]
        tablica[i] = sin
    return np.mean(tablica, axis=0), t1
28/219:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =3)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/220:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/221:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/222:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=100000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/223:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=100, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/224:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/225:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = var * 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = sin
    return np.mean(tablica, axis=0), t1
28/226:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/227:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = var * 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = sin
    return np.mean(tablica, axis=0), t1
28/228:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/229:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = var * 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        losowy_sinus[int(len(losowy_sinus)/2):] = sin[int(len(losowy_sinus)/2):]
        tablica[i] = losowy_sinus
    return np.mean(tablica, axis=0), t1
28/230:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/231:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = var * 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = sin
    return np.mean(tablica, axis=0), t1
28/232:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/233:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/234:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = var * 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = losowy_sinus
    return np.mean(tablica, axis=0), t1
28/235:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/236:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = var * 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin))
        signal[int(len(losowy_sinus)/2):] = sin[int(len(losowy_sinus)/2):]
        signal[:int(len(losowy_sinus)/2)] = losowy_sinus[:int(len(losowy_sinus)/2)]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    return np.mean(tablica, axis=0), t1
28/237:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = var * 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin))
        signal[int(len(losowy_sinus)/2):] = sin[int(len(losowy_sinus)/2):]
        signal[:int(len(losowy_sinus)/2)] = losowy_sinus[:int(len(losowy_sinus)/2)]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    return np.mean(tablica, axis=0), t1
28/238:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = var * 10+np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin))
        signal[int(len(losowy_sinus)/2):] = sin[int(len(losowy_sinus)/2):]
        signal[:int(len(losowy_sinus)/2)] = losowy_sinus[:int(len(losowy_sinus)/2)]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    return np.mean(tablica, axis=0), t1
28/239:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/240:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=100000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/241:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin))
        signal[int(len(losowy_sinus)/2):] = sin[int(len(losowy_sinus)/2):]
        signal[:int(len(losowy_sinus)/2)] = losowy_sinus[:int(len(losowy_sinus)/2)]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    return np.mean(tablica, axis=0), t1
28/242:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=100000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/243:
N = [1, 10, 100, 1000, 10000, 100000, 1000000]
var = [0.1, 1, 10]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(3,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 4)}')
    plt.show()
28/244:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin))
        signal[int(len(losowy_sinus)/2):] = sin[int(len(losowy_sinus)/2):]
        signal[:int(len(losowy_sinus)/2)] = losowy_sinus[:int(len(losowy_sinus)/2)]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    return np.mean(tablica, axis=1), t1
28/245:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/246:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin))
        signal[int(len(losowy_sinus)/2):] = sin[int(len(losowy_sinus)/2):]
        signal[:int(len(losowy_sinus)/2)] = losowy_sinus[:int(len(losowy_sinus)/2)]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = sin
    return np.mean(tablica, axis=0), t1
28/247:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/248:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin))
        signal[int(len(losowy_sinus)/2):] = sin[int(len(losowy_sinus)/2):]
        signal[:int(len(losowy_sinus)/2)] = losowy_sinus[:int(len(losowy_sinus)/2)]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = losowy_sinus
    return np.mean(tablica, axis=0), t1
28/249:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/250:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin))
        signal[int(len(losowy_sinus)/2):] = sin[int(len(losowy_sinus)/2):]
        signal[:int(len(losowy_sinus)/2)] = losowy_sinus[:int(len(losowy_sinus)/2)]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = sin
    return np.mean(tablica, axis=0), t1
28/251:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/252:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin))
        signal[int(len(losowy_sinus)/2):] = sin[:int(len(losowy_sinus)/2)]
        signal[:int(len(losowy_sinus)/2)] = losowy_sinus[:int(len(losowy_sinus)/2)]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    return np.mean(tablica, axis=0), t1
28/253:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/254:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin)*2)
        signal[int(len(losowy_sinus)):] = sin[:int(len(losowy_sinus))]
        signal[:int(len(losowy_sinus))] = losowy_sinus[:int(len(losowy_sinus))]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    return np.mean(tablica, axis=0), t1
28/255:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/256:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot( szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/257:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin)*2)
        signal[int(len(losowy_sinus)):] = sin[:int(len(losowy_sinus))]
        signal[:int(len(losowy_sinus))] = losowy_sinus[:int(len(losowy_sinus))]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    czas = np.arange(0, T*2, 1/FS)
    return np.mean(tablica, axis=0), t1
28/258:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin)*2)
        signal[int(len(losowy_sinus)):] = sin[:int(len(losowy_sinus))]
        signal[:int(len(losowy_sinus))] = losowy_sinus[:int(len(losowy_sinus))]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    czas = np.arange(0, T*2, 1/Fs)
    return np.mean(tablica, axis=0), t1
28/259:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/260:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin)*2)
        signal[int(len(losowy_sinus)):] = sin[:int(len(losowy_sinus))]
        signal[:int(len(losowy_sinus))] = losowy_sinus[:int(len(losowy_sinus))]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    czas = np.arange(0, T*2, 1/Fs)
    return np.mean(tablica, axis=0), czas
28/261:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/262:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal))*2)
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin)*2)
        signal[int(len(losowy_sinus)):] = sin[:int(len(losowy_sinus))]
        signal[:int(len(losowy_sinus))] = losowy_sinus[:int(len(losowy_sinus))]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    czas = np.arange(0, T*2, 1/Fs)
    return np.mean(tablica, axis=0), czas
28/263:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/264:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal))*2)
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin)*2)
        signal[int(len(losowy_sinus)):] = sin[:int(len(losowy_sinus))]
        signal[:int(len(losowy_sinus))] = losowy_sinus[:int(len(losowy_sinus))]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    czas = np.arange(0, T*2, 1/Fs)
    return np.mean(tablica, axis=0), czas
28/265:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/266:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, Fs*T*2)
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin)*2)
        signal[int(len(losowy_sinus)):] = sin[:int(len(losowy_sinus))]
        signal[:int(len(losowy_sinus))] = losowy_sinus[:int(len(losowy_sinus))]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    czas = np.arange(0, T*2, 1/Fs)
    return np.mean(tablica, axis=0), czas
28/267:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, Fs*T*2))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin)*2)
        signal[int(len(losowy_sinus)):] = sin[:int(len(losowy_sinus))]
        signal[:int(len(losowy_sinus))] = losowy_sinus[:int(len(losowy_sinus))]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    czas = np.arange(0, T*2, 1/Fs)
    return np.mean(tablica, axis=0), czas
28/268:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/269:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/270:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=100, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/271:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/272:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =0.5)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
28/273:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
29/1:
N = [1, 10, 100, 1000, 10000, 100000, 1000000]
var = [0.1, 1, 10]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(3,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 4)}')
    plt.show()
30/1:
import numpy as np
import matplotlib.pyplot as plt
30/2:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:int(t0*Fs)] = 0
    return gauss, czas

plt.plot(sinus(10, 0, 128, 1)[1],sinus(10, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0.3, 0.02, 128, 1)[1], g2(0.3, 0.02, 128, 1)[0])
#plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
30/3:
def szumuj_N(N, sygnal):
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal))
    return np.mean(tablica, axis=0)
30/4:
signal1 = sinus(2, 0, 128, 1)
szumowany = szumuj_N(1, signal1[0])
30/5: plt.plot(szumowany)
30/6:
signal1 = g1(0.3, 0.02, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany = szumuj_N(20000, signal1)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
30/7:
N = [1, 10, 100, 1000, 10000, 100000, 1000000]
sygnaly = [g1(0.3, 0.02, 128, 1), g2(0.3, 0.02, 128, 1), g3(0.3, 0.02, 128, 1)]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(3,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 4)}')
    plt.show()
30/8:
def szumuj_N_sinus(N, gauss, f, Fs, T, t0, sigma, phi = None):
    sygnal = gauss(t0, sigma, Fs, T)[0]
    czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, len(sygnal)))
    for i in range(0, N):
        faza = np.random.random()*2*np.pi
        if phi is not None:
            faza = phi
        losowy_sinus = sinus(f, faza, Fs, T)[0]
        tablica[i] = sygnal + 5*np.random.randn(len(sygnal)) + losowy_sinus
    return np.mean(tablica, axis=0), czas
30/9:
signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_N_sinus(N=10000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02)
plt.plot(szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
30/10:
czestosci = [(0.01, 'r'), (0.1, 'b'), (1, 'g'), (10, 'purple'), (100, 'y')]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f, c in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (22,3))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany, color = c)
            plt.title(f'P:{n} , f: {f} VAR: {round(np.var(szumowany), 3)}')
        plt.show()
30/11:
czestosci = [(0.01, 'r'), (0.1, 'b'), (1, 'g'), (10, 'purple'), (100, 'y')]
N = [1, 10, 100, 1000, 10000, 100000]
sygnaly = [g1, g2, g3]
for f, c in czestosci:
    for signal in sygnaly:
#         plt.plot(signal[1],signal[0])
#         plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
#         plt.show()
        plt.figure(figsize = (22,3))
        for i, n in enumerate(N):
            szumowany, czas = szumuj_N_sinus(N=n, gauss=signal, f=f, Fs=128, T=1, t0=0.3, sigma=0.02, phi = 0)
            plt.subplot(1,6,i+1)
            plt.plot(czas ,szumowany, color = c)
            plt.title(f'P:{n} , f: {f} VAR: {round(np.var(szumowany), 3)}')
        plt.show()
30/12:
def szumuj_pol_sinus(N, gauss, f, Fs, T, t0, sigma, var):
#     sygnal = gauss(t0, sigma, Fs, T)[0]
#     czas = gauss(t0, sigma, Fs, T)[1]
    tablica = np.zeros((N, Fs*T*2))
    for i in range(0, N):
        faza1 = np.random.random()*2*np.pi
        faza2 = 0
        f = 10+var*np.random.randn()
        losowy_sinus , t1 = sinus(f=f, phi=faza1, Fs=Fs,T=T)
        sin , t2 = sinus(f=f, phi = faza2, Fs = Fs, T = T)
        signal = np.zeros(len(sin)*2)
        signal[int(len(losowy_sinus)):] = sin[:int(len(losowy_sinus))]
        signal[:int(len(losowy_sinus))] = losowy_sinus[:int(len(losowy_sinus))]
        
#         sin[int(len(losowy_sinus)/2):] = losowy_sinus[int(len(losowy_sinus)/2):]
        tablica[i] = signal
    czas = np.arange(0, T*2, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/13:

signal1 = g1(0.3, 0.02, 128, 1)[0]
sinus1 = sinus(0.1, 0, 128, 1)[0]

wariancja = np.var(signal1)
print(wariancja)
szumowany, czas = szumuj_pol_sinus(N=1000, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =1)
plt.plot(czas, szumowany)
plt.show()
wariancja = np.var(szumowany)
print(wariancja)
30/14:
N = [1, 10, 100, 1000, 10000, 100000, 1000000]
var = [0.1, 1, 10]

for signal in sygnaly:
    plt.plot(signal[1],signal[0])
    plt.title(f'Wariancja sygnału: {round(np.var(signal[0]), 3)}')
    plt.show()
    plt.figure(figsize = (20,12))
    for i, n in enumerate(N):
        szumowany = szumuj_N(n, signal[0])
        plt.subplot(3,3,i+1)
        plt.plot(signal[1],szumowany)
        plt.title(f'Wariancja przy {n} powtórzeniach: {round(np.var(szumowany), 4)}')
    plt.show()
30/15:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.1, 1, 10]

for v in var:
    for i, n in enumerate(N):
        szumowany , t= szumuj_pol_sinus(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =v)
        plt.subplot(3,6,i+1)
        plt.plot(t,szumowany)
        plt.title(f'Średnia przy {n} powtórzeniach: {round(np.mean(szumowany), 4)}')
    plt.show()
30/16:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.1, 1, 10]

for v in var:
    plt.figure(figsize = (9,18))
    for i, n in enumerate(N):
        szumowany , t= szumuj_pol_sinus(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =v)
        plt.subplot(3,6,i+1)
        plt.plot(t,szumowany)
        plt.title(f'Średnia przy {n} powtórzeniach: {round(np.mean(szumowany), 4)}')
    plt.show()
30/17:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.1, 1, 10]

for v in var:
    plt.figure(figsize = (20,7))
    for i, n in enumerate(N):
        szumowany , t= szumuj_pol_sinus(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =v)
        plt.subplot(3,6,i+1)
        plt.plot(t,szumowany)
        plt.title(f'Średnia przy {n} powtórzeniach: {round(np.mean(szumowany), 4)}')
    plt.show()
30/18:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.1, 1, 10]

for v in var:
    plt.figure(figsize = (20,7))
    for i, n in enumerate(N):
        szumowany , t= szumuj_pol_sinus(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =v)
        plt.subplot(3,6,i+1)
        plt.plot(t,szumowany)
        plt.title(f'Średnia przy {n} powt.: {round(np.mean(szumowany), 4)}')
    plt.show()
30/19:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.1, 1, 10]

for v in var:
    plt.figure(figsize = (20,7))
    for i, n in enumerate(N):
        szumowany , t= szumuj_pol_sinus(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =v)
        plt.subplot(3,6,i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt.: {round(np.mean(szumowany), 4)}')
    plt.show()
30/20:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.1, 1, 5, 10]

for v in var:
    plt.figure(figsize = (20,7))
    for i, n in enumerate(N):
        szumowany , t= szumuj_pol_sinus(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt.: {round(np.mean(szumowany), 4)}')
    plt.show()
30/21:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.01, 0.1, 1, 3]

for v in var:
    plt.figure(figsize = (20,7))
    for i, n in enumerate(N):
        szumowany , t= szumuj_pol_sinus(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt.: {round(np.mean(szumowany), 4)}')
    plt.show()
30/22:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.01, 0.1, 1, 3, 5]

for v in var:
    plt.figure(figsize = (20,7))
    for i, n in enumerate(N):
        szumowany , t= szumuj_pol_sinus(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt.: {round(np.mean(szumowany), 4)}')
    plt.show()
30/23:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.01, 0.1, 1, 3, 5]

for v in var:
    plt.figure(figsize = (20,2*len(var)))
    for i, n in enumerate(N):
        szumowany , t= szumuj_pol_sinus(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt.: {round(np.mean(szumowany), 4)}')
    plt.show()
30/24:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.01, 0.1, 1, 3, 5]

for v in var:
    plt.figure(figsize = (20,2.5*len(var)))
    for i, n in enumerate(N):
        szumowany , t= szumuj_pol_sinus(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var =v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt.: {round(np.mean(szumowany), 4)}')
    plt.show()
30/25:
def fluktuacja(N, gauss, f, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T*2))
    for i in range(0, N):
        t0 = t0 + var_t0*np.random.randn()
        signal, czas = gauss(t0, sigma, Fs, T)
        tablica[i] = signal
    return np.mean(tablica, axis=0), czas
30/26:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.01, 0.1, 1, 3, 5]

for v in var:
    plt.figure(figsize = (20,2.5*len(var)))
    for i, n in enumerate(N):
        szumowany , t = fluktuacja(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0, sigma=0.02, var_t0=v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt.: {round(np.mean(szumowany), 4)}')
    plt.show()
30/27:
def fluktuacja(N, gauss, f, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t0 = t0 + var_t0*np.random.randn()
        signal, czas = gauss(t0, sigma, Fs, T)
        tablica[i] = signal
    return np.mean(tablica, axis=0), czas
30/28:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.01, 0.1, 1, 3, 5]

for v in var:
    plt.figure(figsize = (20,2.5*len(var)))
    for i, n in enumerate(N):
        szumowany , t = fluktuacja(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0, sigma=0.02, var_t0=v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt.: {round(np.mean(szumowany), 4)}')
    plt.show()
30/29:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.01, 0.1, 1, 3, 5]

for v in var:
    plt.figure(figsize = (20,2.5*len(var)))
    for i, n in enumerate(N):
        szumowany , t = fluktuacja(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0, sigma=0.02, var_t0=v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt., var = {var}')
    plt.show()
30/30:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.01, 0.1, 1, 3, 5]

for v in var:
    plt.figure(figsize = (20,2.5*len(var)))
    for i, n in enumerate(N):
        szumowany , t = fluktuacja(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0, sigma=0.02, var_t0=v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt., var = {v}')
    plt.show()
30/31:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.01, 0.1, 1, 3, 5]

for v in var:
    plt.figure(figsize = (20,2.5*len(var)))
    for i, n in enumerate(N):
        szumowany , t = fluktuacja(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0, sigma=0.02, var_t0=v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt., var: {v}')
    plt.show()
30/32:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.01, 0.1, 1, 3, 5]

for v in var:
    plt.figure(figsize = (20,2.5*len(var)))
    for i, n in enumerate(N):
        szumowany , t = fluktuacja(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt., var: {v}')
    plt.show()
30/33:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]

for v in var:
    plt.figure(figsize = (20,2.5*len(var)))
    for i, n in enumerate(N):
        szumowany , t = fluktuacja(N=n, gauss=g1, f=10, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt., var: {v}')
    plt.show()
30/34:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t0 = t0 + var_t0*np.random.randn()
        signal, czas = gauss(t0, sigma, Fs, T)
        tablica[i] = signal
    return np.mean(tablica, axis=0), czas
30/35:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]

for v in var:
    plt.figure(figsize = (20,2.5*len(var)))
    for i, n in enumerate(N):
        szumowany , t = fluktuacja(N=n, gauss=g1, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt., var: {v}')
    plt.show()
30/36:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]

for v in var:
    plt.figure(figsize = (20,2.5*len(var)))
    for i, n in enumerate(N):
        szumowany , t = fluktuacja(N=n, gauss=g2, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
        plt.subplot(len(var),len(N),i+1)
        plt.plot(t,szumowany)
        plt.title(f'Śr. przy {n} powt., var: {v}')
    plt.show()
30/37:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'r') ,(g2, 'g'),(g3, 'b')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/38:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'r') ,(g2, 'g'),(g3, 'b')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.ylim(0,1.2)
            plt.plot(t ,szumowany, color = c)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/39:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'r') ,(g3, 'b')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.ylim(0,1.2)
            plt.plot(t ,szumowany, color = c)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/40:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'r') ,(g2, 'g'),(g3, 'b')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/41:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.0001, 0.001, 0.01]
funkcje = [(g1,'r') ,(g2, 'g'),(g3, 'b')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/42:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.0001, 0.001, 0.01]
funkcje = [(g1,'r') ,(g2, 'g'),(g3, 'b')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/43:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.0001, 0.001, 0.01]
funkcje = [(g1,'r') ,(g3, 'b')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/44:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t0 = t0 + var_t0**(1/2) * np.random.randn()
        signal, czas = gauss(t0, sigma, Fs, T)
        tablica[i] = signal
    return np.mean(tablica, axis=0), czas
30/45:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.0001, 0.001, 0.01]
funkcje = [(g1,'r') ,(g3, 'b')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/46:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t0 = t0 + var_t0**2 * np.random.randn()
        signal, czas = gauss(t0, sigma, Fs, T)
        tablica[i] = signal
    return np.mean(tablica, axis=0), czas
30/47:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.0001, 0.001, 0.01]
funkcje = [(g1,'r') ,(g3, 'b')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/48:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'r') ,(g3, 'b')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/49:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.01, 0.1, 1]
funkcje = [(g1,'r') ,(g3, 'b')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/50:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'r') ,(g3, 'b')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/51:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/52:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t0 = t0 + var_t0**2 * np.random.randn()
        signal, = gauss(t0, sigma, Fs, T)
        tablica[i] = signal
    czas = np.arange(0, T, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/53:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/54:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t0 = t0 + var_t0**2 * np.random.randn()
        signal, z = gauss(t0, sigma, Fs, T)
        tablica[i] = signal
    czas = np.arange(0, T, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/55:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/56:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t0 = np.random.normal(t0, var_t0)
        signal, z = gauss(t0, sigma, Fs, T)
        tablica[i] = signal
    czas = np.arange(0, T, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/57:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/58:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=10, t0=5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/59:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=4, t0=2, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/60:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/61:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        #t0 = np.random.normal(t0, var_t0)
        t0 = t0 + np.random.randn() * sigma**2
        signal, z = gauss(t0, sigma, Fs, T)
        tablica[i] = signal
    czas = np.arange(0, T, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/62:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.3, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/63:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/64:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.2, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/65:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/66:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t0 = t0 + np.random.randn() * var_t0**(1/2)
        signal, z = gauss(t0, sigma, Fs, T)
        tablica[i] = signal
    czas = np.arange(0, T, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/67:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/68:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t0 = np.random.normal(t0, var_t0**(1/2)) 
        signal, z = gauss(t0, sigma, Fs, T)
        tablica[i] = signal
    czas = np.arange(0, T, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/69:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/70:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t1 = np.random.normal(t0, var_t0**(1/2)) 
        signal, z = gauss(t1, sigma, Fs, T)
        tablica[i] = signal
    czas = np.arange(0, T, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/71:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/72:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t1 = np.random.normal(t0, var_t0**(1/2)) 
        signal, z = gauss(t1, sigma, Fs, T)
        tablica[i] = signal
    czas = np.arange(0, T, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/73:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/74:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t1 = np.random.normal(t0, var_t0**(1/2)) 
        signal, z = gauss(t1, sigma, Fs, T)
        tablica[i] = signal
    czas = np.arange(0, T, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/75:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            szumowany , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,szumowany, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/76:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for n in N:
            flukt , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,flukt, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/77:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for n in N:
            flukt , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,flukt, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/78:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            flukt , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,flukt, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/79:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t1 = np.random.normal(t0, var_t0**(1/2)) 
        signal, z = gauss(t1, sigma, Fs, T)
        #tablica[i] = signal
        tablica[i] += signal
    czas = np.arange(0, T, 1/Fs)
    #return np.mean(tablica, axis=0), czas
    return tablica/N, czas
30/80:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            flukt , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,flukt, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/81:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t1 = np.random.normal(t0, var_t0**(1/2)) 
        signal, z = gauss(t1, sigma, Fs, T)
        #tablica[i] = signal
        tablica += signal
    czas = np.arange(0, T, 1/Fs)
    #return np.mean(tablica, axis=0), czas
    return tablica/N, czas
30/82:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            flukt , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,flukt, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/83:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t1 = np.random.normal(t0, var_t0**(1/2)) 
        signal, z = gauss(t1, sigma, Fs, T)
        tablica[i] = signal
    czas = np.arange(0, T, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/84:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            flukt , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,flukt, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/85:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t1 = np.random.normal(t0, var_t0) 
        signal, z = gauss(t1, sigma, Fs, T)
        tablica[i] = signal
    czas = np.arange(0, T, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/86:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            flukt , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,flukt, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/87:
def fluktuacja(N, gauss, Fs, T, t0, sigma, var_t0):
    tablica = np.zeros((N, Fs*T))
    for i in range(0, N):
        t1 = np.random.normal(t0, var_t0**(1/2)) 
        signal, z = gauss(t1, sigma, Fs, T)
        tablica[i] = signal
    czas = np.arange(0, T, 1/Fs)
    return np.mean(tablica, axis=0), czas
30/88:
N = [1, 10, 100, 1000, 10000, 100000]
var = [0.001, 0.01, 0.1]
funkcje = [(g1,'b') ,(g3, 'g')]

for fun, c in funkcje:
    for v in var:
        plt.figure(figsize = (20,2.5*len(var)))
        for i, n in enumerate(N):
            flukt , t = fluktuacja(N=n, gauss=fun, Fs=128, T=1, t0=0.5, sigma=0.02, var_t0=v)
            plt.subplot(len(var),len(N),i+1)
            plt.plot(t ,flukt, color = c)
            plt.ylim(0,1.2)
            plt.title(f'Śr. przy {n} powt., var: {v}')
        plt.show()
30/89:
import numpy as np
import matplotlib.pyplot as plt
from  scipy.signal import freqz, group_delay, firwin, firwin2, butter, buttord, lfilter, filtfilt
30/90:
import numpy as np
import matplotlib.pyplot as plt
import scipy.signal as ss
30/91:
    #Parametry filtrów:
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, /(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
f,e =  ss.cheby2(1, /(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
charkterystyki(a,b,f,T,Fs,Fs/2)
30/92:
    #Parametry filtrów:
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
f,e =  ss.cheby2(1, /(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
charkterystyki(a,b,f,T,Fs,Fs/2)
30/93:
    #Parametry filtrów:
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
charkterystyki(a,b,f,T,Fs,Fs/2)
30/94:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = py.figure()
    py.subplot(2,1,1)
    py.title('moduł transmitancji')
    py.plot(f,20*np.log10(m))
    py.ylabel('[dB]')
    py.ylim(-ylim,0)
    py.grid('on')
    
    py.subplot(2,1,2)
    py.title('odpowiedź impulsowa')
    py.plot(t, x)
    py.plot(t, y)
    py.xlim([-T/2,T])
    py.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    py.show()
30/95:
    #Parametry filtrów:
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
charkterystyki(a,b,f,T,Fs,Fs/2)
30/96:
    #Parametry filtrów:
Fs=128
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
charkterystyki(a,b,f,T,Fs,Fs/2)
30/97:
    #Parametry filtrów:
Fs=128
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
charkterystyki(a,b,f,T,Fs,Fs/2)
30/98:
    #Parametry filtrów:
Fs=128
T = 1
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
charkterystyki(a,b,f,T,Fs,Fs/2)
30/99:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = py.figure()
    plt.subplot(2,1,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(2,1,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
30/100:
    #Parametry filtrów:
Fs=128
T = 1
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
charkterystyki(a,b,f,T,Fs,Fs/2)
30/101:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = py.figure()
    plt.subplot(2,1,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(2,1,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
30/102:
    #Parametry filtrów:
Fs=128
T = 1
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
charkterystyki(a,b,f,T,Fs,Fs/2)
30/103:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = plt.figure()
    plt.subplot(2,1,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(2,1,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
30/104:
    #Parametry filtrów:
Fs=128
T = 1
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
charkterystyki(a,b,f,T,Fs,Fs/2)
30/105:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = plt.figure(figsize = (10,5))
    plt.subplot(2,1,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(2,1,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
30/106:
    #Parametry filtrów:
Fs=128
T = 1
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
charkterystyki(a,b,f,T,Fs,Fs/2)
30/107:
    #Parametry filtrów:
cz_dol = (30,40,50)
cz_gor = (0.1, 0.5, 2 , 5)
rzędy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
for f in cz_dol:
    for rz in rzędy:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
30/108:
    #Parametry filtrów:
cz_dol = (30,40,50)
cz_gor = (0.1, 0.5, 2 , 5)
rzędy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
for f in cz_dol:
    for rz in rzędy:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
30/109:
    #Parametry filtrów:
cz_dol = (30,40,50)
cz_gor = (0.1, 0.5, 2 , 5)
rzędy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
for f in cz_dol:
    for rz in rzędy:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
30/110:
    #Parametry filtrów:
cz_dol = (30,40,50)
cz_gor = (0.1, 0.5, 2 , 5)
rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')

# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
for f in cz_dol:
    for rz in rzedy:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
30/111:
    #Parametry filtrów:
cz_dol = (30,40,50)
cz_gor = (0.1, 0.5, 2 , 5)
rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')

# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
for f in cz_dol:
    for rz in rzedy:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
30/112:
    #Parametry filtrów:
cz_dol = (30,40,50)
cz_gor = (0.1, 0.5, 2 , 5)
rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,Fs/2,0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')

# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
30/113:
    #Parametry filtrów:
cz_dol = (30,40,50)
cz_gor = (0.1, 0.5, 2 , 5)
rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')

# f,e =  ss.cheby2(1, 4/(Fs/2), btype = 'lowpass')
# trainData[j][k] = filtfilt(d,c,(filtfilt(b,a,trainData[j][k])))
# trainData[j][k] = (filtfilt(b,a,trainData[j][k]))
for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
30/114:
    #Parametry filtrów:
cz_dol = (30,40,50)
cz_gor = (0.1, 0.5, 2 , 5)
rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')


for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
30/115:
    #Parametry filtrów:
cz_dol = (30,40,50)
cz_gor = (0.1, 0.5, 2 , 5)
rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')


for rz in rzedy:
    
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
31/1:
    #Parametry filtrów:
cz_dol = (30,40,50)
cz_gor = (0.1, 0.5, 2 , 5)
rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')


for rz in rzedy:
    
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
31/2:
import numpy as np
import matplotlib.pyplot as plt
import scipy.signal as ss
31/3:
def sinus(f, phi, Fs, T):
    czas = np.arange(0,T,1/Fs)
    syg = np.sin(czas*f*2*np.pi + phi)
    return syg, czas

def g1(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    return gauss, czas

def g2(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    grad = np.gradient(gauss)
    return grad, czas

def g3(t0, sigma, Fs, T):
    czas = np.arange(0,T,1/Fs)  
    gauss = np.exp(-((czas-t0)**2) / (2*sigma**2))
    gauss[:int(t0*Fs)] = 0
    return gauss, czas

plt.plot(sinus(10, 0, 128, 1)[1],sinus(10, 0, 128, 1)[0])
plt.show()

plt.plot(g1(0.3, 0.02, 128, 1)[1], g1(0.3, 0.02, 128, 1)[0])
plt.show()

plt.plot(g2(0.3, 0.02, 128, 1)[1], g2(0.3, 0.02, 128, 1)[0])
#plt.axvline(0, color = 'g')
plt.show()

plt.plot(g3(0.3, 0.02, 128, 1)[1], g3(0.3, 0.02, 128, 1)[0])
plt.show()
31/4:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = plt.figure(figsize = (10,5))
    plt.subplot(2,1,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(2,1,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
31/5:
    #Parametry filtrów:
cz_dol = (30,40,50)
cz_gor = (0.1, 0.5, 2 , 5)
rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')


for rz in rzedy:
    
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
31/6:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')


for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
31/7:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = SS.freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = plt.figure(figsize = (10,5))
    plt.subplot(2,1,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(2,1,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
31/8:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = ss.freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = plt.figure(figsize = (10,5))
    plt.subplot(2,1,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(2,1,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
31/9:     #Parametry filtrów:
31/10:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')


for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
31/11:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = ss.freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = ss.lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = ss.lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = plt.figure(figsize = (10,5))
    plt.subplot(2,1,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(2,1,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
31/12:     #Parametry filtrów:
31/13:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')


for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
31/14:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
# b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')


for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs/2)
31/15:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
# b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')


for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/16:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
# b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
charkterystyki(c,d,f,T,Fs,Fs)

for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
#         charkterystyki(c,d,f,T,Fs,Fs)
31/17:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
charkterystyki(a,b,f,T,Fs,Fs)

for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
#         charkterystyki(c,d,f,T,Fs,Fs)
31/18:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# charkterystyki(a,b,f,T,Fs,Fs)

for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/19:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = ss.freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = ss.lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = ss.lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = plt.figure(figsize = (10,5))
    plt.subplot(2,1,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(2,1,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
31/20:     #Parametry filtrów:
31/21:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# charkterystyki(a,b,f,T,Fs,Fs)

for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/22:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
charkterystyki(a,b,f,T,Fs,Fs)

for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/23:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
charkterystyki(a,b,f,T,Fs,Fs)

for rz in rzedy:
    for f in cz_dol:
        d,c = ss.butter(rz, f/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/24:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
charkterystyki(a,b,f,T,Fs,Fs)

for rz in rzedy:
    for fs in cz_dol:
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/25:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# charkterystyki(a,b,f,T,Fs,Fs)

for rz in rzedy:
    for fs in cz_dol:
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/26:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# charkterystyki(a,b,f,T,Fs,Fs)

for fs in cz_dol:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/27:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = ss.freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = ss.lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = ss.lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = plt.figure(figsize = (10,5))
    plt.subplot(1,2,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(1,2,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
31/28:     #Parametry filtrów:
31/29:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# charkterystyki(a,b,f,T,Fs,Fs)

for fs in cz_dol:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/30:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = ss.freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = ss.lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = ss.lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = plt.figure(figsize = (5,10))
    plt.subplot(1,2,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(1,2,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
31/31:     #Parametry filtrów:
31/32:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# charkterystyki(a,b,f,T,Fs,Fs)

for fs in cz_dol:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/33:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = ss.freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = ss.lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = ss.lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = plt.figure(figsize = (15,5))
    plt.subplot(1,2,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(1,2,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
31/34:     #Parametry filtrów:
31/35:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# charkterystyki(a,b,f,T,Fs,Fs)

for fs in cz_dol:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/36:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = ss.freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = ss.lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = ss.lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = plt.figure(figsize = (12,3))
    plt.subplot(1,2,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,0)
    plt.grid('on')
    
    plt.subplot(1,2,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
31/37:     #Parametry filtrów:
31/38:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# charkterystyki(a,b,f,T,Fs,Fs)

for fs in cz_dol:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/39:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# charkterystyki(a,b,f,T,Fs,Fs)
print('BUTTERWORTH DOLNOPRZEPUSTOWY')
for fs in cz_dol:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
        
print('BUTTERWORTH GORNOPRZEPUSTOWY')
for fs in cz_gor:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'highpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/40:
def charkterystyki(a,b,f,T,Fs,ylim):
    # przyda nam się oś czasu od -T do T sekund
    t = np.arange(-T, T, 1/Fs)
    
    # oś częstości przeliczamy na radiany
    wr = 2*np.pi* f/Fs
    
    # obliczamy transmitancję
    w, h = ss.freqz(b, a, worN=wr) 
    
    # obliczamy moduł transmitancji
    m = np.abs(h)
        
    # obliczamy fazę i "rozwijamy" ją   
    faza = np.unwrap(np.angle(h))

    # obliczamy opóźnienie fazowe
    opoznienieFazowe = - faza/w
    
    # obliczamy opóźnienie grupowe
    df = np.diff(faza)
    idx, = np.where(np.abs(df-np.pi)<0.05) #to zabezpieczenie na błędy przy "rozwijaniu" fazy
    df[idx] = (df[idx+1]+df[idx-1])/2
    grupowe = - df/np.diff(w)
    
    # obliczamy odpowiedź impulsową
    x = np.zeros(len(t))
    x[len(t)//2] = 1 # impuls
    y = ss.lfilter(b,a,x) # przepuszczamy impuls przez filtr i obserwujemy odpowiedź impulsową
    
    # obliczamy odpowiedź schodkową
    s = np.zeros(len(t))
    s[len(t)//2:] = 1 # schodek
    ys = ss.lfilter(b,a,s) # przepuszczamy schodek przez filtr i obserwujemy odpowiedź schodkową
    
    # rysujemy
    fig = plt.figure(figsize = (12,3))
    plt.subplot(1,2,1)
    plt.title('moduł transmitancji')
    plt.plot(f,20*np.log10(m))
    plt.ylabel('[dB]')
    plt.ylim(-ylim,ylim)
    plt.grid('on')
    
    plt.subplot(1,2,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/2,T])
    plt.grid('on')
    
    
    fig.subplots_adjust(hspace=.5)
    plt.show()
31/41:     #Parametry filtrów:
31/42:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# charkterystyki(a,b,f,T,Fs,Fs)
print('BUTTERWORTH DOLNOPRZEPUSTOWY')
for fs in cz_dol:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
        
print('BUTTERWORTH GORNOPRZEPUSTOWY')
for fs in cz_gor:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'highpass')
        charkterystyki(c,d,f,T,Fs,Fs)
31/43:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# charkterystyki(a,b,f,T,Fs,Fs)
print('BUTTERWORTH DOLNOPRZEPUSTOWY')
for fs in cz_dol:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
        
print('BUTTERWORTH GORNOPRZEPUSTOWY')
for fs in cz_gor:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'highpass')
        charkterystyki(c,d,f,T,Fs,Fs)
        
print('CHYBYSZEW NOTCH')
wp = 49/(Fs/2)
ws = 51/(Fs/2)
gpass = 1 
gstop = 25
analog=0
rp = gpass
rs = gstop
# for fs in cz_gor:
for rz in range(1,4):
    print(f'czestosc: {fs} , rząd: {rz}')
    [n,Wn]=cheb2ord(wp, ws, gpass, gstop, analog=0);
    [b,a]=cheby2(rz, rs, Wn, btype='low', analog=0, output='ba')
    charkterystyki(a,b,f,T,Fs,30)
    print('Czebyszewa II Typu: rząd: {}, częstość odcięcia {:.3f}'.format(n,Wn*Fs/2))
31/44:
cz_dol = (30,40,50)

cz_gor = (0.1, 0.5, 2 , 5)

rzedy = (1,2,3,4,5)
Fs=128
T = 1
f = np.arange(0.01,(Fs/2),0.01) 
# d,c = ss.butter(1, 3/(Fs/2), btype = 'lowpass')
b,a = ss.butter(5, 10/(Fs/2), btype = 'highpass')
# charkterystyki(a,b,f,T,Fs,Fs)
print('BUTTERWORTH DOLNOPRZEPUSTOWY')
for fs in cz_dol:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'lowpass')
        charkterystyki(c,d,f,T,Fs,Fs)
        
print('BUTTERWORTH GORNOPRZEPUSTOWY')
for fs in cz_gor:
    for rz in rzedy:
        print(f'czestosc: {fs} , rząd: {rz}')
        d,c = ss.butter(rz, fs/(Fs/2), btype = 'highpass')
        charkterystyki(c,d,f,T,Fs,Fs)
        
print('CHYBYSZEW NOTCH')
wp = 49/(Fs/2)
ws = 51/(Fs/2)
gpass = 1 
gstop = 25
analog=0
rp = gpass
rs = gstop
# for fs in cz_gor:
for rz in range(1,4):
    print(f'czestosc: {fs} , rząd: {rz}')
    [n,Wn]=ss.cheb2ord(wp, ws, gpass, gstop, analog=0);
    [b,a]=ss.cheby2(rz, rs, Wn, btype='low', analog=0, output='ba')
    charkterystyki(a,b,f,T,Fs,30)
    print('Czebyszewa II Typu: rząd: {}, częstość odcięcia {:.3f}'.format(n,Wn*Fs/2))
33/1: !pip3 install serial
33/2:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return chr(a%256) + chr(a/256)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = chr(3) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = period - bright
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = chr(4) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
            print(period)
 
        self.send(str)
33/3:
SP = SerialPort
sp = SP('/dev/ttyUSB0')
33/4:
SP = SerialPort
sp = SP('/dev/ttyUSB0')
33/5:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return chr(a%256) + chr(a/256)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = chr(3) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = period - bright
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = chr(4) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
            print(period)
 
        self.send(str)
33/6:
SP = SerialPort
sp = SP('/dev/ttyUSB0')
33/7:
SP = SerialPort
sp = SP.SerialPort('/dev/ttyUSB0')
33/8: sp = SP.SerialPort('/dev/ttyUSB0')
33/9: sp = SerialPort('/dev/ttyUSB0')
33/10: import MySerialPort as SP
33/11: sp = SP.MySerialPort('/dev/ttyUSB0')
33/12: sp = SP.SerialPort('/dev/ttyUSB0')
34/1: import MySerialPort as SP
34/2: sp = SP.MySerialPort('/dev/ttyUSB0')
34/3: sp = SP.SerialPort('/dev/ttyUSB0')
35/1: import MySerialPort as SP
35/2: sp = SP.SerialPort('/dev/ttyUSB0')
35/3: sp = SP.MySerialPort('/dev/ttyUSB0')
36/1: import MySerialPort as SP
36/2: sp = SP.MySerialPort('/dev/ttyUSB0')
36/3: dir(SP)
36/4: import MySerialPort as SP
36/5: sp = SP.SerialPort('/dev/ttyUSB0')
36/6: import SerialPort as SP
36/7: sp = SP.SerialPort('/dev/ttyUSB0')
37/1: import SerialPort as SP
37/2: sp = SP.SerialPort('/dev/ttyUSB0')
37/3: import serial
37/4: dir(SP)
37/5: dir(serial)
37/6: !pip install serial
37/7: !pip install pyserial
37/8: !pip3 install pyserial
37/9: !pip3 install serial
37/10:
pip install pipenv
pipenv run pip install pip==18.0
pipenv install
37/11:
pipenv run pip install pip==18.0
pipenv install
37/12:
!pip install pipenv
!pipenv run pip install pip==18.0
!|pipenv install
37/13:
!pip install pipenv
!pipenv run pip install pip==18.0
!pipenv install
37/14: !pip3 install pyserial
37/15: !pip3 install pyserial
37/16: !pip install pyserial
37/17: dir(serial)
37/18: !pip install pyserial
37/19: !pip install numpy
37/20: !python -m pip install serial --user
37/21: !python -m pip3 install serial --user
37/22: !python -m install pip --user
37/23: !python -m pip3 install pip --user
38/1:      import serial_port as SP
38/2:  sp = SP.SerialPort(nazwa_pliku)
38/3:  sp = SP.SerialPort('/dev/ttyUSB0')
38/4: import serial
38/5: serial.__file__
38/6: dir(serial)
38/7: import serial
38/8: dir(serial)|
38/9: import serial
38/10: serial.__file__
39/1:      import serial_port as SP
39/2:  sp = SP.SerialPort('/dev/ttyUSB0')
39/3: import serial
39/4: serial.__file__
39/5: dir(serial)|
39/6: dir(serial)
39/7:  sp = SP.SerialPort('/dev/ttyUSB0')
39/8:  sp = SP.SerialPort('/dev/ttyUSB0')
39/9:      sp.open()
39/10:
dir(serial)
     sp.blinkP300([0, 0])
39/11:      sp.blinkP300([0, 0])
39/12:      sp.blinkSSVEP([10, 0],1,1)
39/13:
     sp.blinkP300([1, 1
                  ])
39/14: sp.blinkP300([0, 500])
39/15: sp.blinkP300([0, 500])
39/16: sp.blinkSSVEP([10, 0],1,1)
40/1:      import serial_port as SP
40/2:  sp = SP.SerialPort('/dev/ttyUSB0')
40/3:      sp.open()
40/4: import serial
40/5: serial.__file__
40/6:
dir(serial)
     sp.blinkP300([0, 0])
40/7: sp.blinkSSVEP([10, 0],1,1)
41/1: import saffy
41/2:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
41/3:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'open':'mateusz_oczy_szeroko_zamkniete', 'closed':'mateusz_oczy_zamkniete', 'inne':'mateusz_try1'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['closed']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/4:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/5:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2','A1','A2']
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/6:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/7:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
# EEG.butter_highpass_filter(cutoff=1, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
# EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/8:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=5)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
# EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/9:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
# EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/10:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
# EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/11:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=2)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
# EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/12:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=3)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
# EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/13:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=1)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
# EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/14:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=3)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
# EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 1024

DELTA = 1500
START = 1000
STOP = 2500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/15:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=3)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
# EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 1024

START = 0
STOP = 8500

plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/16:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=3)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
# EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 10 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/17:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=3)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - (EEG_2D[-1,:] + EEG_2D[-2,:])/2 #montaz - średnia z uszu   
# EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/18:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=3)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - EEG_2D[-3,:] #montaz - średnia z uszu   
# EEG_2D = EEG_2D[0:-2,:] #usuwamy kanały uszne

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/19:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=3)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/20:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/21:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=5)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/22:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=5)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/23:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)
# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/24:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')




CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/25:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')




CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=5)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/26:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (50,20))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

# EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop')




CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/27:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,15))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 3 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/28:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,15))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 4 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/29:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 4 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/30:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG.data = EEG.data - EEG.data[0,-1,:]
# EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 4 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/31:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 4 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/32:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

# EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 4 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/33:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 4 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/34:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

# EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 4 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/35:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = 4 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/36:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -1 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/37:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/38:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/39: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
41/40: FUNNY_EEG
41/41: FUNNY_EEG.data
41/42: FUNNY_EEG.data.shape
41/43: plt.plot(FUNNY_EEG.data[0,1,:])
41/44: plt.plot(FUNNY_EEG.data[0,:,:])
41/45: plt.plot(FUNNY_EEG.data[2,:,:])
41/46: plt.plot(FUNNY_EEG.data[:100,2,:])
41/47: plt.plot(np.mean(FUNNY_EEG.data[:100,2,:]))
41/48: plt.plot(np.mean(FUNNY_EEG.data[:100,2,:], axis=1))
41/49: plt.plot(np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
41/50: plt.plot(np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
41/51:
plt.plot(np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/52:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t, np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t, np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/53:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[:-2], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/54:
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[4,0,:], axis=0))
plt.show()
41/55:
plt.plot(t[:-2],FUNNY_EEG.data[4,0,:])
plt.show()
41/56:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/57:
plt.plot(t[:-2],FUNNY_EEG.data[1,0,:])
plt.show()
41/58:
plt.plot(t[:-2],FUNNY_EEG.data[2,0,:])
plt.show()
41/59:
plt.plot(t[:-2],FUNNY_EEG.data[4,0,:])
plt.show()
41/60:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/61:
plt.plot(t[:-2],FUNNY_EEG.data[3,0,:])
plt.show()
41/62:
plt.plot(t[:-2],FUNNY_EEG.data[4,0,:])
plt.show()
41/63:
plt.plot(t[:-2],FUNNY_EEG.data[6,0,:])
plt.show()
41/64:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/65: FUNNY_EEG.data.shape
41/66:
clean_data = []
for fragment in FUNNY_EEG.data:
    plt.plot(t[:-2],fragment)
    plt.show()
41/67:
clean_data = []
for fragment in FUNNY_EEG.data:
    plt.plot(t[:-2],fragment[0])
    plt.show()
41/68:
clean_data = []
for fragment in FUNNY_EEG.data:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data.append(fragment)
41/69: clean_data
41/70: clean_data.shape
41/71:
clean_data = []
for fragment in FUNNY_EEG.data:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data.append(fragment)
clean_data = np.array(clean_data)
41/72: clean_data.shape
41/73:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/74:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/75:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/76: clean_data_first.shape
41/77:
plt.plot(t[:-2], np.mean(clean_data_first[:,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(clean_data_second[:,2,:], axis=0))
plt.show()
41/78:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=2)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/79: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
41/80:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[:-2], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/81:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/82:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/83:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/84: clean_data_first.shape
41/85:
plt.plot(t[:-2], np.mean(clean_data_first[:,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(clean_data_second[:,2,:], axis=0))
plt.show()
41/86:
plt.plot(t[:-2], np.mean(clean_data_first[:,7,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(clean_data_second[:,7,:], axis=0))
plt.show()
41/87:
plt.plot(t[:-2], np.mean(clean_data_first[:,7,:], axis=0))
plt.plot(t[:-2], np.mean(clean_data_second[:,7,:], axis=0))
plt.show()
41/88:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=2)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/89: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
41/90:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[:-2], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/91:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/92:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/93:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/94: clean_data_first.shape
41/95:
plt.plot(t[:-2], np.mean(clean_data_first[:,7,:], axis=0))
plt.plot(t[:-2], np.mean(clean_data_second[:,7,:], axis=0))
plt.show()
41/96:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=2)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/97: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
41/98:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[:-2], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/99:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/100:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/101:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/102: clean_data_first.shape
41/103:
plt.plot(t[:-2], np.mean(clean_data_first[:,7,:], axis=0))
plt.plot(t[:-2], np.mean(clean_data_second[:,7,:], axis=0))
plt.show()
41/104:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=1)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/105: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
41/106:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[:-2], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/107:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/108:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/109:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/110: clean_data_first.shape
41/111:
plt.plot(t[:-2], np.mean(clean_data_first[:,7,:], axis=0))
plt.plot(t[:-2], np.mean(clean_data_second[:,7,:], axis=0))
plt.show()
41/112:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/113: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
41/114:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[:-2], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/115:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/116:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/117:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/118: clean_data_first.shape
41/119:
plt.plot(t[:-2], np.mean(clean_data_first[:,7,:], axis=0))
plt.plot(t[:-2], np.mean(clean_data_second[:,7,:], axis=0))
plt.show()
41/120:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
# EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/121: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
41/122:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[:-2], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/123:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/124:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/125:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/126: clean_data_first.shape
41/127:
plt.plot(t[:-2], np.mean(clean_data_first[:,7,:], axis=0))
plt.plot(t[:-2], np.mean(clean_data_second[:,7,:], axis=0))
plt.show()
41/128:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
# EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.butter_highpass_filter(cutoff=1, order=2)
EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/129: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
41/130:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[:-2], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/131:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/132:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/133:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/134: clean_data_first.shape
41/135:
plt.plot(t[:-2], np.mean(clean_data_first[:,7,:], axis=0))
plt.plot(t[:-2], np.mean(clean_data_second[:,7,:], axis=0))
plt.show()
41/136:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/137: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
41/138:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[:-2], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/139:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/140:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/141:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/142: clean_data_first.shape
41/143:
plt.plot(t[:-2], np.mean(clean_data_first[:,7,:], axis=0))
plt.plot(t[:-2], np.mean(clean_data_second[:,7,:], axis=0))
plt.show()
41/144:
while k < 19:
    plt.subplot(4,5,k)
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
plt.show()
41/145:
k=0
while k < 19:
    plt.subplot(4,5,k)
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
41/146:
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
41/147:

plt.figure(figsize(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
41/148:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
41/149:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
41/150:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
41/151:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=40, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/152: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
41/153:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[:-2], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/154:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/155:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/156:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/157: clean_data_first.shape
41/158:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
41/159:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

# EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/160: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
41/161:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[:-2], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/162:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/163:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/164:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/165: clean_data_first.shape
41/166:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
41/167:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/168:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/169:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 
kanał2 = -2
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
plt.plot(EEG_2D[kanał2,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/170:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = 60 * EEG.fs


plt.plot(EEG_2D[kanał,:próbki])
# plt.plot(EEG_2D[kanał2,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/171:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = 60 * EEG.fs


# plt.plot(EEG_2D[kanał,:próbki])
plt.plot(EEG_2D[kanał2,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/172:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = 60 * EEG.fs


# plt.plot(EEG_2D[kanał,:próbki])
plt.plot(EEG_2D[kanał2,:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/173: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
41/174:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[:-2], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[:-2], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/175:
plt.plot(t[:-2],FUNNY_EEG.data[5,0,:])
plt.show()
41/176:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/177:
clean_data_first = []
for fragment in first_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < 80 and np.max(fragment[4,:]) < 80:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/178: clean_data_first.shape
41/179:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
41/180:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = 4 * 60 * EEG.fs
pstart = 3.5* 60 * EEG.fs


plt.plot(EEG_2D[kanał,pstart:próbki])
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/181:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(4 * 60 * EEG.fs)
pstart = int(3.5* 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki])
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/182:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(4 * 60 * EEG.fs)
pstart = int(3.5* 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki])
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/183:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(4 * 60 * EEG.fs)
pstart = int(3.5* 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/184:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(4 * 60 * EEG.fs)
pstart = int(3.5* 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki])
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/185:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(4 * 60 * EEG.fs)
pstart = int(3.5* 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki])
plt.plot(EEG_2D[kanał2,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/186:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(4 * 60 * EEG.fs)
pstart = int(3.5* 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/187:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(4 * 60 * EEG.fs)
pstart = int(3.5* 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki]+1, color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/188:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(4 * 60 * EEG.fs)
pstart = int(3.5* 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki]+10, color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/189:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(4 * 60 * EEG.fs)
pstart = int(3.5* 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki]-100000, color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/190:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki]-100000, color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/191:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki]-100000, color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/192:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


# plt.plot(EEG_2D[kanał,pstart:próbki]-100000, color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/193:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki]-100000, color = 'g')
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/194:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/195:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
41/196:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
41/197:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
41/198:
clean_data_first = []
cutoff = 70
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/199: clean_data_first.shape
41/200:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
41/201:
clean_data_first = []
cutoff = 70
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/202: clean_data_first.shape
41/203:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
41/204: clean_data_first.shape
41/205:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
41/206:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
44/2:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/3: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/4:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/5:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/6:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
44/7:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/8: clean_data_first.shape
44/9:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
44/10:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/11: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/12:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/13:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/14:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
44/15:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/16: clean_data_first.shape
44/17:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
44/18:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/19: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/20:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/21:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/22:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
44/23:
clean_data_first = []
cutoff = 70
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/24: clean_data_first.shape
44/25:
clean_data_first = []
cutoff = 50
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/26: clean_data_first.shape
44/27:
clean_data_first = []
cutoff = 100
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/28: clean_data_first.shape
44/29:
clean_data_first = []
cutoff = 30
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/30: clean_data_first.shape
44/31:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/32: clean_data_first.shape
44/33:
clean_data_first = []
cutoff = 70
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/34: clean_data_first.shape
44/35:
clean_data_first = []
cutoff = 40
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/36: clean_data_first.shape
44/37:
clean_data_first = []
cutoff = 30
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/38: clean_data_first.shape
44/39:
clean_data_first = []
cutoff = 50
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/40: clean_data_first.shape
44/41:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/42: clean_data_first.shape
44/43:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
44/44:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-2,:] = -EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/45: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/46:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/47:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/48:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
44/49:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/50: clean_data_first.shape
44/51:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
44/52:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-3,:] = -EEG.data[0,-3,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/53:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-3,:] = -EEG.data[0,-3,:]
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/54: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/55:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/56:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/57:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
44/58:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/59: clean_data_first.shape
44/60:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
44/61:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-3,:] = -EEG.data[0,-3,:]
EEG.data[0,-2,:] = -EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/62:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-3,:] = -EEG.data[0,-3,:]
EEG.data[0,-2,:] = -EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/63: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/64:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/65:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/66:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/67:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-3,:] = -EEG.data[0,-3,:]
EEG.data[0,-2,:] = -EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/68: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/69:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/70:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/71:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/72:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-3,:] = -EEG.data[0,-3,:]
EEG.data[0,-2,:] = -EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int( 2* 60 * EEG.fs)
pstart = int( 60 * EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/73: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/74:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/75:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/76:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
44/77:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/78: clean_data_first.shape
44/79:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
44/80:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-3,:] = -EEG.data[0,-3,:]
EEG.data[0,-2,:] = -EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(60 * EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/81:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-3,:] = -EEG.data[0,-3,:]
EEG.data[0,-2,:] = -EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(2 * EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/82:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-3,:] = -EEG.data[0,-3,:]
EEG.data[0,-2,:] = -EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5 * EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/83:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-3,:] = -EEG.data[0,-3,:]
EEG.data[0,-2,:] = -EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5 * EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
# plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/84:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-3,:] = -EEG.data[0,-3,:]
EEG.data[0,-2,:] = -EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5 * EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/85:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
EEG.data[0,-3,:] = -EEG.data[0,-3,:]
EEG.data[0,-2,:] = -EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
# EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5 * EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/86:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
# EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5 * EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/87: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/88:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/89:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/90:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
44/91:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/92: clean_data_first.shape
44/93:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5 * EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/94: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/95:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/96:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/97:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
44/98:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/99: clean_data_first.shape
44/100:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
44/101:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5 * EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/102: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/103:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/104:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/105:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
44/106:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/107: clean_data_first.shape
44/108:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
44/109:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
# EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5 * EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/110:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
# EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5 * EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/111:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
# EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(60*5 * EEG.fs)
pstart = int(60*4.5*EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/112:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig1')

EEG.data = EEG.data - EEG.data[0,-1,:]
# EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/113:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
# EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/114: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/115:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/116:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/117:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
44/118:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/119: clean_data_first.shape
44/120:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
44/121:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['Fp1', 'P3', 'Pz', 'P4', 'Fp2', 'O1', 'O2', 'T5','T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'trig1', 'trig2', 'ref'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]
EEG.set_tags_from_channel('trig2')

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
44/122: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
44/123:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
44/124:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
44/125:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
44/126:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
44/127: clean_data_first.shape
44/128:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
45/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
45/2:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1', 'O2','T5','P3', 'Pz', 'P4', 'T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'Fp1', 'Fp2','ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]

                # TRZEBA CIĄĆ RECZNIE
                # EEG.set_tags_from_channel('trig2') 

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
45/3:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1', 'O2','T5','P3', 'Pz', 'P4', 'T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'Fp1', 'Fp2','ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]

                # TRZEBA CIĄĆ RECZNIE
                # EEG.set_tags_from_channel('trig2') 

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 #trig1
kanał2 = -1 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
45/4:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1', 'O2','T5','P3', 'Pz', 'P4', 'T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'Fp1', 'Fp2','ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]

                # TRZEBA CIĄĆ RECZNIE
EEG.set_tags_from_channel('trig1') 

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 #trig1
kanał2 = -1 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
45/5: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
45/6:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
45/7:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
45/8:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
45/9:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
45/10: clean_data_first.shape
45/11:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
45/12:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1', 'O2','T5','P3', 'Pz', 'P4', 'T6', 'T3', 'C3', 'Cz', 'C4', 'T4', 'F7', 'F3', 'Fz', 'F4', 'F8', 'Fp1', 'Fp2','ref', 'trig1', 'trig2'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]

                # TRZEBA CIĄĆ RECZNIE
EEG.set_tags_from_channel('trig2') 

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -2 #trig1
kanał2 = -1 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
45/13: FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
45/14:
t = np.arange(-0.3, 0.4, 1/EEG.fs)

plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[:100,2,:], axis=0))
plt.show()
plt.plot(t[1:-1], np.mean(FUNNY_EEG.data[100:200,2,:], axis=0))
plt.show()
45/15:
plt.plot(t[1:-1],FUNNY_EEG.data[5,0,:])
plt.show()
45/16:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG.data[:100, :, :]
second_part = FUNNY_EEG.data[100:, :, :]
45/17:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
45/18: clean_data_first.shape
45/19:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t[:-2], np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t[:-2], np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
46/1:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]

                # TRZEBA CIĄĆ RECZNIE
                # EEG.set_tags_from_channel('trig2') 

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
46/2:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
46/3:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]

                # TRZEBA CIĄĆ RECZNIE
                # EEG.set_tags_from_channel('trig2') 

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-1,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
46/4:
trigger_index =- 2
EEG.data.shape
start = -0.3
stop = 0.4
fragments = np.zeros((200, 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
46/5:
# FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
FUNNY_EEG = fragments
46/6:
t = np.arange(-0.3, 0.4-1/EEG.fs, 1/EEG.fs)

plt.plot(t, np.mean(FUNNY_EEG[:100,2,:], axis=0))
plt.show()
plt.plot(t, np.mean(FUNNY_EEG[100:200,2,:], axis=0))
plt.show()
46/7:
plt.plot(t,FUNNY_EEG[5,0,:])
plt.show()
46/8:
# FUNNY_EEG.data.shape
first_part = FUNNY_EEG[:100, :, :]
second_part = FUNNY_EEG[100:, :, :]
46/9:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
46/10: clean_data_first.shape
46/11:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t, np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t, np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
46/12:
FUNNY_EEG.data.shape
first_part = FUNNY_EEG[:100, :, :]
second_part = FUNNY_EEG[100:, :, :]
46/13:
print(FUNNY_EEG.data.shape)
first_part = FUNNY_EEG[:100, :, :]
second_part = FUNNY_EEG[100:, :, :]
46/14:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[0,:]) < cutoff and np.max(fragment[4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
46/15: clean_data_first.shape
46/16:
print(FUNNY_EEG.data.shape)
first_part = FUNNY_EEG[:100, :, :]
second_part = FUNNY_EEG[100:, :, :]
46/17:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
46/18: clean_data_first.shape
46/19:
clean_data_first = []
cutoff = 60
for fragment in first_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
46/20: clean_data_first.shape
46/21:
clean_data_first = []
cutoff = 60
for fragment in first_part:
    print( np.max(fragment[-5,:]))
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
46/22:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]

                # TRZEBA CIĄĆ RECZNIE
                # EEG.set_tags_from_channel('trig2') 

EEG.data = EEG.data - EEG.data[0,-1,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
EEG_2D = EEG_2D - EEG_2D[-3,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
46/23:
trigger_index =- 2
EEG.data.shape
start = -0.3
stop = 0.4
fragments = np.zeros((200, 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
46/24:
# FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
FUNNY_EEG = fragments
46/25:
t = np.arange(-0.3, 0.4-1/EEG.fs, 1/EEG.fs)

plt.plot(t, np.mean(FUNNY_EEG[:100,2,:], axis=0))
plt.show()
plt.plot(t, np.mean(FUNNY_EEG[100:200,2,:], axis=0))
plt.show()
46/26:
plt.plot(t,FUNNY_EEG[5,0,:])
plt.show()
46/27:
print(FUNNY_EEG.data.shape)
first_part = FUNNY_EEG[:100, :, :]
second_part = FUNNY_EEG[100:, :, :]
46/28:
clean_data_first = []
cutoff = 60
for fragment in first_part:
    print( np.max(fragment[-5,:]))
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
46/29:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]

                # TRZEBA CIĄĆ RECZNIE
                # EEG.set_tags_from_channel('trig2') 

EEG.data = EEG.data - EEG.data[0,-3,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-3,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
46/30:
trigger_index =- 2
EEG.data.shape
start = -0.3
stop = 0.4
fragments = np.zeros((200, 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
46/31:
# FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
FUNNY_EEG = fragments
46/32:
t = np.arange(-0.3, 0.4-1/EEG.fs, 1/EEG.fs)

plt.plot(t, np.mean(FUNNY_EEG[:100,2,:], axis=0))
plt.show()
plt.plot(t, np.mean(FUNNY_EEG[100:200,2,:], axis=0))
plt.show()
46/33:
plt.plot(t,FUNNY_EEG[5,0,:])
plt.show()
46/34:
print(FUNNY_EEG.data.shape)
first_part = FUNNY_EEG[:100, :, :]
second_part = FUNNY_EEG[100:, :, :]
46/35:
clean_data_first = []
cutoff = 60
for fragment in first_part:
    print( np.max(fragment[-5,:]))
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
46/36:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    print( np.max(fragment[-5,:]))
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
46/37:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
46/38: clean_data_first.shape
46/39:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t, np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t, np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
46/40:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.4
fragments = np.zeros((200, 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
46/41:
# FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
FUNNY_EEG = fragments
46/42:
t = np.arange(-0.3, 0.4-1/EEG.fs, 1/EEG.fs)

plt.plot(t, np.mean(FUNNY_EEG[:100,2,:], axis=0))
plt.show()
plt.plot(t, np.mean(FUNNY_EEG[100:200,2,:], axis=0))
plt.show()
46/43:
plt.plot(t,FUNNY_EEG[5,0,:])
plt.show()
46/44:
print(FUNNY_EEG.data.shape)
first_part = FUNNY_EEG[:100, :, :]
second_part = FUNNY_EEG[100:, :, :]
46/45:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
46/46: clean_data_first.shape
46/47:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t, np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t, np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
46/48:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-6,6)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.plot(t, np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t, np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
46/49:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-6,6)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.axhline(0, color = 'g')
    plt.plot(t, np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t, np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
46/50:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-7,7)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.axhline(0, color = 'g')
    plt.plot(t, np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t, np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
46/51:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.axhline(0, color = 'g')
    plt.plot(t, np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t, np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
46/52:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.2)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    plt.plot(t, np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t, np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
46/53:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axvline(0, color = 'g')
    plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    plt.plot(t, np.mean(clean_data_first[:,k,:], axis=0))
    plt.plot(t, np.mean(clean_data_second[:,k,:], axis=0))
    k+=1
plt.show()
46/54:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    sygmin = np.min(syg)
    sygmax = np.max(syg)
    N2 = np.where(syg == sygmin) + int(0.3*Fs)
    P2 = np.where(syg == sygmax) + int(0.3*Fs)
    return N2, P2
46/55:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    sygmin = np.min(syg)
    sygmax = np.max(syg)
    N2 = np.where(syg == sygmin) + int(0.3*Fs)
    P2 = np.where(syg == sygmax) + int(0.3*Fs)
    return (N2,sygmin), (P2,sygmax)
46/56:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    plt.scatter(N2f)
    k+=1
plt.show()
46/57:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    sygmin = np.min(syg)
    sygmax = np.max(syg)
    N2 = np.where(syg == sygmin)[0] + int(0.3*Fs)
    P2 = np.where(syg == sygmax)[0] + int(0.3*Fs)
    return (N2,sygmin), (P2,sygmax)
46/58:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    plt.scatter(N2f)
    k+=1
plt.show()
46/59:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    plt.plot(N2f)
    k+=1
plt.show()
46/60:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    plt.plot(N2f, 'ro')
    k+=1
plt.show()
46/61:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f)
    plt.plot(N2f, 'rx')
    k+=1
plt.show()
46/62:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f)
    plt.scatter(N2f[0],N2f[1])
    k+=1
plt.show()
46/63:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0])
    plt.scatter(N2f[0],N2f[1])
    k+=1
plt.show()
46/64:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0][0])
    plt.scatter(N2f[0],N2f[1])
    k+=1
plt.show()
46/65:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0])
    plt.scatter(N2f[0][0],N2f[1])
    k+=1
plt.show()
46/66:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0])
    plt.plot(N2f[0][0],N2f[1])
    k+=1
plt.show()
46/67:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0])
    plt.plot(N2f[0][0],N2f[1], marker='o', markersize=3, color="red")
    k+=1
plt.show()
46/68:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0][0],N2f[1])
    plt.plot(N2f[0][0],N2f[1], marker='o', markersize=3, color="red")
    k+=1
plt.show()
46/69:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0][0],N2f[1])
    plt.plot(N2f[0][0]/EEG.fs,N2f[1], marker='o', markersize=3, color="red")
    k+=1
plt.show()
46/70:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0][0],N2f[1])
    plt.plot(0,N2f[1], marker='o', markersize=3, color="red")
    
    k+=1
plt.show()
46/71:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0][0],N2f[1])
    plt.plot(0,N2f[1], marker='o', markersize=8, color="red")
    
    k+=1
plt.show()
46/72:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0][0],N2f[1])
    plt.plot(N2f[0][0],N2f[1], marker='o', markersize=8, color="red")
    
    k+=1
plt.show()
46/73:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0][0],N2f[1])
    plt.plot(N2f[0][0]/EEG.fs,N2f[1], marker='o', markersize=8, color="red")
    
    k+=1
plt.show()
46/74:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0][0],N2f[1])
    plt.plot(N2f[0][0]/EEG.fs,N2f[1], marker='o', markersize=8, color="red")
    
    k+=1
plt.show()
46/75:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0][0],N2f[1])
    plt.plot(N2f[0][0]*EEG.fs,N2f[1], marker='o', markersize=8, color="red")
    
    k+=1
plt.show()
46/76:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    sygmin = np.min(syg)
    sygmax = np.max(syg)
    N2 = np.where(syg == sygmin)[0] #+ int(0.3*Fs)
    P2 = np.where(syg == sygmax)[0] #+ int(0.3*Fs)
    return (N2,sygmin), (P2,sygmax)
46/77:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0][0],N2f[1])
    plt.plot(N2f[0][0]*EEG.fs,N2f[1], marker='o', markersize=8, color="red")
    
    k+=1
plt.show()
46/78:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    sygmin = np.min(syg)
    sygmax = np.max(syg)
    N2 = np.where(syg == sygmin)[0] + int(0.3*Fs)
    P2 = np.where(syg == sygmax)[0] + int(0.3*Fs)
    return (N2,sygmin), (P2,sygmax)
46/79:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0][0],N2f[1])
    plt.plot(N2f[0][0]*EEG.fs,N2f[1], marker='o', markersize=8, color="red")
    
    k+=1
plt.show()
46/80:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    sygmin = np.min(syg)
    sygmax = np.max(syg)
    N2 = np.where(syg == sygmin)[0][0] + int(0.3*Fs)
    P2 = np.where(syg == sygmax)[0][0] + int(0.3*Fs)
    return (N2,sygmin), (P2,sygmax)
46/81:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0],N2f[1])
    plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    
    k+=1
plt.show()
46/82:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(0.1,N2f[1], marker='o', markersize=8, color="red")
    
    k+=1
plt.show()
46/83:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    sygmin = np.min(syg)
    sygmax = np.max(syg)
    N2 = np.where(syg == sygmin)[0][0] #+ int(0.3*Fs)
    P2 = np.where(syg == sygmax)[0][0] #+ int(0.3*Fs)
    return (N2/Fs,sygmin), (P2/Fs,sygmax)
46/84:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(0.1,N2f[1], marker='o', markersize=8, color="red")
    
    k+=1
plt.show()
46/85:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    
    k+=1
plt.show()
46/86:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    k+=1
plt.show()
46/87:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='x', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='x', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='x', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='x', markersize=9, color="green")
    k+=1
plt.show()
46/88:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/89:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    sygmin = np.min(syg)
    sygmax = np.max(syg)
    N2 = np.where(syg[:40] == sygmin)[0][0] #+ int(0.3*Fs)
    P2 = np.where(syg == sygmax)[0][0] #+ int(0.3*Fs)
    return (N2/Fs,sygmin), (P2/Fs,sygmax)
46/90:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/91:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    sygmin = np.min(syg[:40])
    sygmax = np.max(syg)
    N2 = np.where(syg == sygmin)[0][0] #+ int(0.3*Fs)
    P2 = np.where(syg == sygmax)[0][0] #+ int(0.3*Fs)
    return (N2/Fs,sygmin), (P2/Fs,sygmax)
46/92:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/93:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    sygmin = ss.argrelmin(syg)[0]
    sygmax = ss.argrelmax(syg)[0]
    N2 = np.where(syg == sygmin)[0][0] #+ int(0.3*Fs)
    P2 = np.where(syg == sygmax)[0][0] #+ int(0.3*Fs)
    return (N2/Fs,sygmin), (P2/Fs,sygmax)
46/94:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/95:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    sygmin = ss.argrelmin(syg)[0]
    sygmax = ss.argrelmax(syg)[0]
    print(sygmin,sygmax)
    N2 = np.where(syg == sygmin)[0][0] #+ int(0.3*Fs)
    P2 = np.where(syg == sygmax)[0][0] #+ int(0.3*Fs)
    return (N2/Fs,sygmin), (P2/Fs,sygmax)
46/96:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/97:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    sygmin = ss.argrelmin(syg)[0][0]
    sygmax = ss.argrelmax(syg)[0][0]
    print(sygmin,sygmax)
    N2 = np.where(syg == sygmin)[0][0] #+ int(0.3*Fs)
    P2 = np.where(syg == sygmax)[0][0] #+ int(0.3*Fs)
    return (N2/Fs,sygmin), (P2/Fs,sygmax)
46/98:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/99:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.3*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    P2 = ss.argrelmax(syg)[0][0]
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
46/100:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/101:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.35*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    P2 = ss.argrelmax(syg)[0][0]
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
46/102:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/103:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.33*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    P2 = ss.argrelmax(syg)[0][0]
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
46/104:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/105:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.33*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    P2 = ss.argrelmax(syg)[0][0]
    print(N2,P2)
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
46/106:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/107:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.33*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    P2 = ss.argrelmax(syg)[0][0]
    print(N2,P2)
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
46/108:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/109:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.32*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    P2 = ss.argrelmax(syg)[0][0]
    print(N2,P2)
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
46/110:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/111:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    P2 = ss.argrelmax(syg)[0][0]
    print(N2,P2)
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
46/112:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/113:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
    except IndexError:
        pass
#     print(N2f[0],N2f[1])
#     plt.plot(N2f[0],N2f[1], marker='o', markersize=8, color="red")
    plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
    plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
    plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    k+=1
plt.show()
46/114:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        except IndexError:
        pass
    k+=1
plt.show()
46/115:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    except IndexError:
        pass
    k+=1
plt.show()
46/116:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="green")
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="red")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    except IndexError:
        pass
    k+=1
plt.show()
46/117:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i > N2:
            P2 = i
    print(N2,P2)
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
46/118:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="green")
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="red")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    except IndexError:
        pass
    k+=1
plt.show()
46/119:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i > N2:
            P2 = i
            break
    print(N2,P2)
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
46/120:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="green")
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="red")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    except IndexError:
        pass
    k+=1
plt.show()
46/121:

plt.figure(figsize=(40,40))
k=0
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
#     plt.axvline(0, color = 'g')
#     plt.axvline(0.1, color = 'r')
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
    try:
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
    except IndexError:
        pass
    k+=1
plt.show()
46/122:

plt.figure(figsize=(40,40))
k=0
SI = []
SII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        SI.append(P2f[1]-N2f[1])
    except IndexError:
        pass
    try:
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        SII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
    k+=1
plt.show()
print(SI,SII)
46/123:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i > N2:
            P2 = i
            break
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
46/124:

plt.figure(figsize=(40,40))
k=0
SI = []
SII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        SI.append(P2f[1]-N2f[1])
    except IndexError:
        pass
    try:
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        SII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
    k+=1
plt.show()
print(SI,SII)
46/125:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
#     try:


#     except IndexError:
#         pass
    k+=1
plt.show()
print(SI,SII)
46/126:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
#     try:


#     except IndexError:
#         pass
    k+=1
plt.show()
print(PI,PII)
46/127:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
#     try:


#     except IndexError:
#         pass
    k+=1
plt.show()
print(np.abs(np.array(PI)-np.array(PII)))
46/128:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
#     try:


#     except IndexError:
#         pass
    k+=1
plt.show()
print((np.array(PII)-np.array(PI))
46/129:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
#     try:


#     except IndexError:
#         pass
    k+=1
plt.show()
print((np.array(PII)-np.array(PI)))
46/130:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
#     try:


#     except IndexError:
#         pass
    k+=1
plt.show()
S = np.array(PII)-np.array(PI)
plt.plot(S)
plt.show()
print(S)
46/131:
ALL = np.concatenate(np.array(PII),np.array(PI))
print(ALL)
46/132:
ALL = np.concatenate((np.array(PII),np.array(PI)))
print(ALL)
46/133:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(1000):
    mieszane = np.random.shuffle(ALL)
    pI = mieszane[:len(PII)]
    pII = mieszane[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
print(random)
46/134:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(1000):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
print(random)
46/135:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(1000):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
print(random)
plt.hist(random)
plt.plot()
46/136:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(1000):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
46/137:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(1000):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
print(lewy,prawy)
46/138:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(1000):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S)
plt.axhline(lewy,'r')
plt.axhline(prawy,'r')

plt.show()
print(lewy,prawy)
46/139:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(1000):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S)
plt.axhline((lewy,prawy),'r')
# plt.axhline(prawy,'r')

plt.show()
print(lewy,prawy)
46/140:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(1000):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S)
plt.axhline(prawy,'r')
# plt.axhline(prawy,'r')

plt.show()
print(lewy,prawy)
46/141:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(1000):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S)
plt.axhline(prawy,color='r')
# plt.axhline(prawy,'r')

plt.show()
print(lewy,prawy)
46/142:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(1000):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S)
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/143:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(1000):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S,'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/144:
N = 4000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S,'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/145:
N = 50000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S,'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/146:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII - pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S,'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/147:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S,'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/148:
N = 1000
ALL = np.concatenate(clean_data_first[:,4,:],clean_data_second[:,4,:] , axis = 0)
random = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(clean_data_first)]
    pII = mieszać[len(clean_data_first):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S,'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/149:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(clean_data_first)]
    pII = mieszać[len(clean_data_first):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S,'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/150:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)
random2 = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    N2f, P2f = find_N2_P2(first,EEG.fs)
    N2s, P2s = find_N2_P2(second,EEG.fs)
    random[i]=(P2s[1]-N2s[1])-(P2f[1]-N2f[1])
#     random2[i]=(P2s[1]-N2s[1])
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S,'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/151:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)
random2 = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=(P2s[1]-N2s[1])-(P2f[1]-N2f[1])
    except IndexError:
        pass
#     random2[i]=(P2s[1]-N2s[1])
# print(random)
plt.hist(random)
plt.show()
# prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
# plt.plot(S,'b.')
# plt.axhline(prawy,color='r')
# plt.axhline(lewy,color='r')

# plt.show()
# print(lewy,prawy)
46/152:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)
random2 = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=(P2s[1]-N2s[1])-(P2f[1]-N2f[1])
    except IndexError:
        pass
#     random2[i]=(P2s[1]-N2s[1])
# print(random)
print(random)
plt.hist(random)
plt.show()
# prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
# plt.plot(S,'b.')
# plt.axhline(prawy,color='r')
# plt.axhline(lewy,color='r')

# plt.show()
# print(lewy,prawy)
46/153:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)
random2 = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    plt.plot(first)
    plt.plot(second)
    plt.show()
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=(P2s[1]-N2s[1])-(P2f[1]-N2f[1])
    except IndexError:
        pass
#     random2[i]=(P2s[1]-N2s[1])
# print(random)
print(random)
plt.hist(random)
plt.show()
# prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
# plt.plot(S,'b.')
# plt.axhline(prawy,color='r')
# plt.axhline(lewy,color='r')

# plt.show()
# print(lewy,prawy)
46/154:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)
random2 = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    plt.plot(first)
    plt.plot(second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=(P2s[1]-N2s[1])-(P2f[1]-N2f[1])
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
    plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)
print(random)
plt.hist(random)
plt.show()
# prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
# plt.plot(S,'b.')
# plt.axhline(prawy,color='r')
# plt.axhline(lewy,color='r')

# plt.show()
# print(lewy,prawy)
46/155:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)
random2 = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=(P2s[1]-N2s[1])-(P2f[1]-N2f[1])
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
    plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)
print(random)
plt.hist(random)
plt.show()
# prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
# plt.plot(S,'b.')
# plt.axhline(prawy,color='r')
# plt.axhline(lewy,color='r')

# plt.show()
# print(lewy,prawy)
46/156:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)
random2 = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=(P2s[1]-N2s[1])-(P2f[1]-N2f[1])
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)
print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S,'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/157:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=(P2s[1]-N2s[1])-(P2f[1]-N2f[1])
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S[4],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/158:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=(P2s[1]-N2s[1])-(P2f[1]-N2f[1])
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
    plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S[4],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/159:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1])
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
    plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S[4],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/160:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1])
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
    plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,95) , np.percentile(random,5)
plt.plot(S[4],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/161:
N = 1000
ALL = np.concatenate((clean_data_first[:,4,:],clean_data_second[:,4,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1])
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)

plt.show()
dobre = random[random!=0]
print(len(dobre),len(random))
prawy,lewy=np.percentile(dobre,95) , np.percentile(dobre,5)
plt.plot(S[4],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/162:
N = 1000
ALL = np.concatenate((clean_data_first[:,3,:],clean_data_second[:,3,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1])
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)

plt.show()
dobre = random[random!=0]
print(len(dobre),len(random))
prawy,lewy=np.percentile(dobre,95) , np.percentile(dobre,5)
plt.plot(S[4],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/163:
N = 1000
ALL = np.concatenate((clean_data_first[:,3,:],clean_data_second[:,3,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1])
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)

plt.show()
dobre = random[random!=0]
print(len(dobre),len(random))
prawy,lewy=np.percentile(dobre,95) , np.percentile(dobre,5)
plt.plot(S[3],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/164:
N = 1000
ALL = np.concatenate((clean_data_first[:,0,:],clean_data_second[:,0,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1])
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)

plt.show()
dobre = random[random!=0]
print(len(dobre),len(random))
prawy,lewy=np.percentile(dobre,95) , np.percentile(dobre,5)
plt.plot(S[0],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/165:
N = 1000
ch = 4
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1])
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)

plt.show()
dobre = random[random!=0]
print(len(dobre),len(random))
prawy,lewy=np.percentile(dobre,95) , np.percentile(dobre,5)
plt.plot(S[ch],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/166:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1])
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)

plt.show()
dobre = random[random!=0]
print(len(dobre),len(random))
prawy,lewy=np.percentile(dobre,95) , np.percentile(dobre,5)
plt.plot(S[ch],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/167:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1])
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)

plt.show()
dobre = random[random!=0]
print(len(dobre),len(random))
prawy,lewy=np.percentile(dobre,95) , np.percentile(dobre,5)
plt.plot(S[ch],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
46/168:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)

plt.show()
dobre = random[random!=0]
print(len(dobre),len(random))
prawy,lewy=np.percentile(dobre,95) , np.percentile(dobre,5)
plt.plot(S[ch],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
48/1: # !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master
48/2:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
48/3:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]

                # TRZEBA CIĄĆ RECZNIE
                # EEG.set_tags_from_channel('trig2') 

EEG.data = EEG.data - EEG.data[0,-3,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-3,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
48/4:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.4
fragments = np.zeros((200, 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
48/5:
# FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
FUNNY_EEG = fragments
48/6:
t = np.arange(-0.3, 0.4-1/EEG.fs, 1/EEG.fs)

plt.plot(t, np.mean(FUNNY_EEG[:100,2,:], axis=0))
plt.show()
plt.plot(t, np.mean(FUNNY_EEG[100:200,2,:], axis=0))
plt.show()
48/7:
plt.plot(t,FUNNY_EEG[5,0,:])
plt.show()
48/8:
print(FUNNY_EEG.data.shape)
first_part = FUNNY_EEG[:100, :, :]
second_part = FUNNY_EEG[100:, :, :]
48/9:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
48/10: clean_data_first.shape
48/11:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i > N2:
            P2 = i
            break
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
48/12:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
#     try:


#     except IndexError:
#         pass
    k+=1
plt.show()

S = np.array(PII)-np.array(PI)
plt.plot(S)
plt.show()
print(S)
48/13:
N = 1000
ALL = np.concatenate((np.array(PII),np.array(PI)))
random = np.zeros(N)
for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    pI = mieszać[:len(PII)]
    pII = mieszać[len(PII):]
    random[i] = np.mean(pII) - np.mean(pI)
# print(random)
plt.hist(random)
plt.show()
prawy,lewy=np.percentile(random,97.5) , np.percentile(random,2.5)
plt.plot(S,'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
48/14:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)

plt.show()
dobre = random[random!=0]
print(len(dobre),len(random))
prawy,lewy=np.percentile(dobre,95) , np.percentile(dobre,5)
plt.plot(S[ch],'b.')
plt.axhline(prawy,color='r')
plt.axhline(lewy,color='r')

plt.show()
print(lewy,prawy)
48/15:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)

plt.hist(random)

plt.show()
dobre = random[random!=0]
print(len(dobre),len(random))
gorny=np.percentile(dobre,95) #, np.percentile(dobre,5)
plt.plot(S[ch],'b.')
plt.axhline(gorny,color='r')
# plt.axhline(lewy,color='r')

plt.show()
print(gorny)
48/16:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)


dobre = random[random!=0]
print(len(dobre),len(random))
gorny=np.percentile(dobre,95) #, np.percentile(dobre,5)
plt.plot(S[ch],'b.')
# plt.axhline(gorny,color='r')
# plt.axhline(lewy,color='r')
plt.hist(random)
plt.axvline(gorny,color='r')
plt.show()
print(gorny)
48/17:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)


dobre = random[random!=0]
print(len(dobre),len(random))
gorny=np.percentile(dobre,95) #, np.percentile(dobre,5)
plt.plot(S[ch],'g.')
# plt.axhline(gorny,color='r')
# plt.axhline(lewy,color='r')
plt.hist(random)
plt.axvline(gorny,color='r')
plt.show()
print(gorny)
48/18:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)


dobre = random[random!=0]
print(len(dobre),len(random))
gorny=np.percentile(dobre,95) #, np.percentile(dobre,5)
# plt.plot(S[ch],'g.')
# plt.axhline(gorny,color='r')
plt.axvline(S[ch],color='g')
plt.hist(random)
plt.axvline(gorny,color='r')
plt.show()
print(gorny)
48/19:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
#     plt.plot(t, first)
#     plt.plot(t, second)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
#         plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
#         plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
#         plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
#         plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
    except IndexError:
        pass
#     plt.show()
#     random2[i]=(P2s[1]-N2s[1])
# print(random)


dobre = random[random!=0]
print(len(dobre),len(random))
gorny=np.percentile(dobre,95) #, np.percentile(dobre,5)
# plt.plot(S[ch],'g.')
# plt.axhline(gorny,color='r')
plt.axvline(abs(S[ch]),color='g')
plt.hist(random)
plt.axvline(gorny,color='r')
plt.show()
print(gorny)
48/20:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
print(len(dobre),len(random))
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random)
plt.axvline(gorny,color='r')
plt.show()
print(gorny)
48/21:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
print(len(dobre),len(random))
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random)
plt.axvline(gorny,color='r')
plt.show()
print(abs(S[ch]))
print(gorny)
48/22:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random)
plt.axvline(gorny,color='r')
plt.show()
print(abs(S[ch]))
print(gorny)
48/23:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random)
plt.axvline(gorny,color='r')
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {abs(S[ch])}')
print(gorny)
48/24:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random)
plt.axvline(gorny,color='r')
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {abs(S[ch])}')
print("Granica dla 95 percentyla: {gorny}')
48/25:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random)
plt.axvline(gorny,color='r')
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {abs(S[ch])}')
print(f'Granica dla 95 percentyla: {gorny}')
48/26:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random)
plt.axvline(gorny,color='r')
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
48/27:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r')
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
48/28:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r')
plt.aytitle('s')
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
48/29:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r')
plt.xlabel('Różnice amplitud')
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
48/30:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r')
plt.title('Różnice amplitud')
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
48/31:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r',title ='przedział')
plt.title('Rozkład różnic amplitud')
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
48/32:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r',label ='przedział')
plt.title('Rozkład różnic amplitud')
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
48/33:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass



dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r',label ='przedział')
plt.title('Rozkład różnic amplitud')
plt.legend()
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
48/34:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass


plt.figure(figsize=(20,10))
dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r',label ='przedział')
plt.title('Rozkład różnic amplitud')
plt.legend()
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
48/35:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass


plt.figure(figsize=(20,10))
dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
plt.title('Rozkład różnic amplitud')
plt.legend()
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
48/36:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass


plt.figure(figsize=(20,10))
dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
plt.title('Rozkład różnic amplitud')
plt.legend()
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
49/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
49/2:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data = EEG.data - EEG.data[0,-3,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
49/3:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data = EEG.data - EEG.data[0,-3,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
49/4:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.4
fragments = np.zeros((200, 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
49/5:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.4

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
48/37:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.4

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
49/6:
FUNNY_EEG = fragments
for i in fragments:
    plt.plot(i)
49/7:
FUNNY_EEG = fragments
for i in fragments[:20]:
    plt.plot(i[3])
    plt.show()
49/8:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
48/38:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]

                # TRZEBA CIĄĆ RECZNIE
                # EEG.set_tags_from_channel('trig2') 

EEG.data[0,:-2,:] = EEG.data - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-3,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
48/39:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]

                # TRZEBA CIĄĆ RECZNIE
                # EEG.set_tags_from_channel('trig2') 

EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-3,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
50/1: # !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master
50/2:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
50/3:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))
# EEG.data[0,-3,:] = EEG.data[0,-3,:]
# EEG.data[0,-2,:] = EEG.data[0,-2,:]

                # TRZEBA CIĄĆ RECZNIE
                # EEG.set_tags_from_channel('trig2') 

EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych
# EEG_2D = EEG_2D - EEG_2D[-3,:] #montaz - od referencji   
# EEG_2D = EEG_2D[0:-1,:] #usuwamy referencje

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
50/4:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.4

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
50/5:
# FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
FUNNY_EEG = fragments
50/6:
t = np.arange(-0.3, 0.4-1/EEG.fs, 1/EEG.fs)

plt.plot(t, np.mean(FUNNY_EEG[:100,2,:], axis=0))
plt.show()
plt.plot(t, np.mean(FUNNY_EEG[100:200,2,:], axis=0))
plt.show()
50/7:
plt.plot(t,FUNNY_EEG[5,0,:])
plt.show()
50/8:
print(FUNNY_EEG.data.shape)
first_part = FUNNY_EEG[:100, :, :]
second_part = FUNNY_EEG[100:, :, :]
50/9:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
50/10: clean_data_first.shape
50/11:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i > N2:
            P2 = i
            break
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
50/12:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
#     try:


#     except IndexError:
#         pass
    k+=1
plt.show()

S = np.array(PII)-np.array(PI)
plt.plot(S)
plt.show()
print(S)
50/13:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i > N2:
            P2 = i
            break
        else:
            P2 = i
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
50/14:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
    k+=1
plt.show()

S = np.array(PII)-np.array(PI)
plt.plot(S)
plt.show()
print(S)
50/15:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i > N2:
            P2 = i
            break
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
50/16:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i >= N2:
            P2 = i
            break
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
50/17:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i >= N2:
            P2 = i
            break
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
50/18:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.42*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i >= N2:
            P2 = i
            break
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
50/19:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
    k+=1
plt.show()

S = np.array(PII)-np.array(PI)
plt.plot(S)
plt.show()
print(S)
50/20:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass


plt.figure(figsize=(20,10))
dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
plt.title('Rozkład różnic amplitud')
plt.legend()
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
50/21:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.45*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i > N2:
            P2 = i
            break
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
50/22:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
    k+=1
plt.show()

S = np.array(PII)-np.array(PI)
plt.plot(S)
plt.show()
print(S)
50/23:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.45*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i > N2:
            P2 = i
            break
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
50/24:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
    k+=1
plt.show()

S = np.array(PII)-np.array(PI)
plt.plot(S)
plt.show()
print(S)
50/25:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.55*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i > N2:
            P2 = i
            break
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
50/26:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
    k+=1
plt.show()

S = np.array(PII)-np.array(PI)
plt.plot(S)
plt.show()
print(S)
50/27:
N = 1000
ch = 3
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass


plt.figure(figsize=(20,10))
dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
plt.title('Rozkład różnic amplitud')
plt.legend()
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
50/28:
N = 1000
ch = 1
ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
random = np.zeros(N)

for i in range(N):
    mieszać = np.copy(ALL)
    np.random.shuffle(mieszać)
    first_shuffeld = mieszać[:clean_data_first.shape[0],:]
    second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
    first = np.mean(first_shuffeld, axis=0)
    second = np.mean(second_shuffeld, axis=0)
    
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
    except IndexError:
        pass


plt.figure(figsize=(20,10))
dobre = random[random!=0]
gorny=np.percentile(dobre,95)
plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}')
plt.hist(random, bins = 20)
plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
plt.title('Rozkład różnic amplitud')
plt.legend()
plt.show()
print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
50/29:


for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass


    plt.figure(figsize=(20,10))
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
    plt.title('Rozkład różnic amplitud')
    plt.legend()
    plt.show()
    print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
    print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
50/30:


for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    plt.subplot(3,2,ch+1)
    plt.figure(figsize=(20,10))
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
    plt.title('Rozkład różnic amplitud')
    plt.legend()
    plt.show()
    print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
    print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
50/31:


for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    plt.subplot(3,2,ch+1)
    plt.figure(figsize=(20,10))
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
    plt.title('Rozkład różnic amplitud')
    plt.legend()
    plt.show()
    print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
    print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
50/32:


for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    plt.figure(figsize=(20,10))
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
    plt.title('Rozkład różnic amplitud')
    plt.legend()
    plt.show()
    print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
    print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
50/33:
plt.figure(figsize=(20,10))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
    plt.title('Rozkład różnic amplitud')
    plt.legend()
    plt.show()
    print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
    print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
50/34:
plt.figure(figsize=(20,10))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
    plt.title('Rozkład różnic amplitud')
    plt.legend()
    print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
    print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
50/35:
plt.figure(figsize=(50,30))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
    plt.title('Rozkład różnic amplitud')
    plt.legend()
    print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
    print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
50/36:
plt.figure(figsize=(40,22))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label ='Granica istotności statystycznej')
    plt.title('Rozkład różnic amplitud')
    plt.legend()
    print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
    print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
50/37:
plt.figure(figsize=(40,22))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label ='Granica istotności statystycznej: {round(gorny, 2)}')
    plt.title('Rozkład różnic amplitud')
    plt.legend()
#     print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
#     print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
50/38:
plt.figure(figsize=(40,22))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label =f'Granica istotności statystycznej: {round(gorny, 2)}')
    plt.title('Rozkład różnic amplitud')
    plt.legend()
#     print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
#     print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
50/39:
plt.figure(figsize=(40,22))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud: {round(abs(S[ch]), 2)}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label =f'Granica istotności statystycznej: {round(gorny, 2)}')
    plt.title('Rozkład różnic amplitud  dla kanłu {CH[ch]}')
    plt.legend()
#     print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
#     print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
50/40:
plt.figure(figsize=(40,22))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud: {round(abs(S[ch]), 2)}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label =f'Granica istotności statystycznej: {round(gorny, 2)}')
    plt.title(f'Rozkład różnic amplitud  dla kanłu {CH[ch]}')
    plt.legend()
#     print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
#     print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
50/41:
plt.figure(figsize=(40,27))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud: {round(abs(S[ch]), 2)}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label =f'Granica istotności statystycznej: {round(gorny, 2)}')
    plt.title(f'Rozkład różnic amplitud  dla kanłu {CH[ch]}')
    plt.legend()
#     print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
#     print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
50/42:
plt.figure(figsize=(40,27))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud: {round(abs(S[ch]), 2)}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label =f'Granica istotności statystycznej: {round(gorny, 2)}')
    plt.title(f'Rozkład różnic amplitud  dla kanłu {CH[ch]}')
    plt.legend()
#     print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
#     print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
49/9:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
49/10:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
49/11:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)+1]
49/12:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)-1]
49/13:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)-1]
print(fragments.shape)
49/14:
EEG1 = fragments[:900,:,:]
EEG2 =fragments[900:,:,:]
print(EEG1.shape , EEG2.shape)
49/15:
EEG1 = fragments[:900,:,:]
EEG2 = fragments[900:,:,:]
print(EEG1.shape , EEG2.shape)
EEG1.reshape((60,15,22,460))
49/16:
EEG1 = fragments[:900,:,:]
EEG2 = fragments[900:,:,:]
print(EEG1.shape , EEG2.shape)
EEG1.reshape((60,15,22,460))
print(EEG1.shape)
49/17:
EEG1 = fragments[:900,:,:]
EEG2 = fragments[900:,:,:]
print(EEG1.shape , EEG2.shape)
EEG1 = EEG1.reshape((60,15,22,460))
print(EEG1.shape)
49/18:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/19:
trigger_index = -2
EEG.data.shape
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/20:
trigger_index = -1
EEG.data.shape
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/21:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/22:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((543552 -2048, 543552))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/23:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((543552 -2*2048, 543552-1*543552))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/24:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((543552 -2*2048, 543552-1*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/25:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((543552 -4*2048, 543552-3*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/26:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/27:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/28:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.5))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/29:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.9))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/30:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.8))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/31:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.7))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/32:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.65))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/33:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.62))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/34:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.6))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/35:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.63))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/36:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.64))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/37:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.65))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/38:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.66))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/39:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.67))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/40:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.68))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/41:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.69))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/42:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.685))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/43:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.684))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/44:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.681))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/45:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.689))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/46:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.69))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/47:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.685))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/48:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.68))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/49:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.688))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/50:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.681))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/51:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.68))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/52:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.6805))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/53:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.6809))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/54:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.6801))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/55:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.68001))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/56:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/57:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],90))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/58:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],50))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/59:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],90))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/60:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],90),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/61:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/62:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs-1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/63:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
49/64: EEG1 = fragments.reshape((60,15,22,461))
49/65: print(EEG1.shape)
49/66:
plt.plot(EEG1[0,0,4,:])
plt.show()
49/67:
plt.plot(EEG1[0,0,4,:])
plt.show()
plt.plot(fragments[0,4,:])
plt.show()
49/68:
plt.plot(EEG1[0,0,4,:])
plt.plot(fragments[0,4,:])
plt.show()
49/69:
plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[16,4,:])
plt.show()
49/70:
plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[1,4,:])
plt.show()
49/71:
plt.plot(EEG1[0,1,4,:])
plt.plot(fragments[1,4,:])
plt.show()
49/72:
plt.plot(EEG1[0,15,4,:])
plt.plot(fragments[15,4,:])
plt.show()
49/73:
plt.plot(EEG1[0,14,4,:])
plt.plot(fragments[15,4,:])
plt.show()
49/74:
plt.plot(EEG1[0,1,4,:])
plt.plot(fragments[15,4,:])
plt.show()
49/75:
plt.plot(EEG1[1,1,4,:])
plt.plot(fragments[15,4,:])
plt.show()
49/76:
plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[15,4,:])
plt.show()
49/77:
lista = [1,2,3,4]
np.mean(lista)
49/78:
lista = [1,2,3,4, np.nan]
np.mean(lista)
49/79:
lista = [1,2,3,4, np.nan]
np.nanmean(lista)
49/80:
clean_data = []
cutoff = 80
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        fragments[i,:,:] = np.nan

EEG1 = fragments.reshape((60,15,22,461))
49/81: print(EEG1.shape)
49/82: print(EEG1)
49/83:
clean_data = []
cutoff = 80
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff and any(abs(fragment[:,:])) > 75:
        fragments[i,:,:] = np.nan

EEG1 = fragments.reshape((60,15,22,461))
49/84:


plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[15,4,:])
plt.show()
49/85:
clean_data = []
cutoff = 80
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff and any(abs(fragment[:-3,:])) > 75:
        fragments[i,:,:] = np.nan

EEG1 = fragments.reshape((60,15,22,461))
49/86:


plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[15,4,:])
plt.show()
49/87:
clean_data = []
cutoff = 80
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff and any(abs(fragment[:-4,:])) > 75:
        fragments[i,:,:] = np.nan

EEG1 = fragments.reshape((60,15,22,461))
49/88:


plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[15,4,:])
plt.show()
49/89: EEG1.shape
49/90: print(EEG1)
49/91:


plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[15,4,:])
plt.show()
49/92:


plt.plot(EEG1[0,0,4,:])
plt.plot(fragments[0,4,:])
plt.show()
49/93:
clean_data = []
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff and any(abs(fragment[:-4,:])) > 75:
        fragments[i,:,:] = np.nan
        ile +=1
EEG1 = fragments.reshape((60,15,22,461))
49/94: print(ile)
49/95:
clean_data = []
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff and any(abs(fragment[:-4,:])) > 75:
        fragments[i,:,:] = np.nan
        ile +=1
EEG1 = fragments.reshape((60,15,22,461))
49/96: print(ile)
49/97:
clean_data = []
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or any(abs(fragment[:-4,:])) > 75:
        fragments[i,:,:] = np.nan
        ile +=1
EEG1 = fragments.reshape((60,15,22,461))
49/98:
clean_data = []
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(abs(fragment[:-4,:])) > 75:
        fragments[i,:,:] = np.nan
        ile +=1
EEG1 = fragments.reshape((60,15,22,461))
49/99: print(ile)
49/100:
clean_data = []
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(abs(fragment[:-4,:])) > 75:
        fragments[i,:,:] = np.nan
        ile +=1
EEG1 = fragments.reshape((60,15,22,461))
49/101: print(ile)
49/102:


plt.plot(EEG1[0,0,4,:])
plt.plot(fragments[0,4,:])
plt.show()
49/103:
EEG

plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[15,4,:])
plt.show()
49/104:
clean_data = []
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments):
    ile +=1
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(abs(fragment[:-4,:])) > 75:
        fragments[i,:,:] = np.nan
EEG1 = fragments.reshape((60,15,22,461))
49/105: print(ile)
49/106:
clean_data = []
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(abs(fragment[:-4,:])) > 75:
        ile +=1
        fragments[i,:,:] = np.nan
EEG1 = fragments.reshape((60,15,22,461))
49/107: print(ile)
49/108:
clean_data = []
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments[i,:,:] = np.nan
EEG1 = fragments.reshape((60,15,22,461))
49/109: print(ile)
49/110:
clean_data = []
cutoff = 80

for i, fragment in enumerate(fragments):
    ile = 0
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(abs(fragment[:-4,:])) > 75:
        ile +=1
        fragments[i,:,:] = np.nan
EEG1 = fragments.reshape((60,15,22,461))
49/111: print(ile)
49/112:
clean_data = []
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(abs(fragment[:-4,:])) > 75:
        ile +=1
        print('dupa ciapki')
        fragments[i,:,:] = np.nan
EEG1 = fragments.reshape((60,15,22,461))
49/113:
clean_data = []
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(abs(fragment[:-4,:])) > 75:
        ile +=1
        print('dupa ciapki')
        fragments[i,:,:] = np.nan
EEG1 = fragments.reshape((60,15,22,461))
49/114: print(ile)
52/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
52/2:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
52/3:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
52/4:
clean_data = []
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(abs(fragment[:-4,:])) > 75:
        ile +=1
        print('dupa ciapki')
        fragments[i,:,:] = np.nan
EEG1 = fragments.reshape((60,15,22,461))
52/5: print(ile)
52/6:
EEG

plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[15,4,:])
plt.show()
52/7:
lista = [1,2,3,4, np.nan]
np.nanmean(lista)
53/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
53/2:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
53/3:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
53/4:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(abs(fragment[:-4,:])) > 75:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/5: print(ile)
53/6:
EEG

plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[15,4,:])
plt.show()
53/7:
lista = [1,2,3,4, np.nan]
np.nanmean(lista)
53/8:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff: # or np.any(abs(fragment[:-4,:])) > 75:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/9: print(ile)
53/10:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff: # or np.any(abs(fragment[:-4,:])) > 75:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/11: print(ile)
53/12:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(abs(fragment[:-4,:])) > 75:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/13: print(ile)
53/14:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(abs(fragment[:-4,:])) > 55:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/15: print(ile)
53/16:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(abs(fragment[:-4,:])) > 25:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/17: print(ile)
53/18:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(fragment[:-4,:]) > 15:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/19: print(ile)
53/20:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(fragment[:-4,:] > 15):
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/21: print(ile)
53/22:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(fragment[:-4,:] > 75):
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/23: print(ile)
53/24:
EEG

plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[15,4,:])
plt.show()
53/25:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(fragment[:-4,:] > 40):
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/26: print(ile)
53/27:
EEG

plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[15,4,:])
plt.show()
53/28:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 40):
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/29: print(ile)
53/30:
EEG

plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[15,4,:])
plt.show()
53/31:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 35):
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/32: print(ile)
53/33:
EEG

plt.plot(EEG1[1,0,4,:])
plt.plot(fragments[15,4,:])
plt.show()
53/34:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 35):
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/35: print(ile)
53/36:
EEG

plt.plot(EEG1[1,0,4,:])
plt.plot(fragments_copy[15,4,:])
plt.show()
53/37:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/38: print(ile)
53/39:
EEG

plt.plot(EEG1[1,0,4,:])
plt.plot(fragments_copy[15,4,:])
plt.show()
53/40:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/41: print(ile)
53/42:
EEG

plt.plot(EEG1[0,0,4,:])
plt.plot(fragments_copy[0,4,:])
plt.show()
53/43:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 45):
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/44: print(ile)
53/45:
EEG

plt.plot(EEG1[0,0,4,:])
plt.plot(fragments_copy[0,4,:])
plt.show()
53/46:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/47: print(ile)
53/48:
EEG

plt.plot(EEG1[0,0,4,:])
plt.plot(fragments_copy[0,4,:])
plt.show()
53/49: np.nanmean(fragments_copy,axis=1)
53/50:
np.nanmean(fragments_copy,axis=1)
print(fragments_copy.shape)
53/51:
cos = np.nanmean(fragments_copy,axis=1)
print(cos.shape)
53/52:
cos = np.nanmean(fragments_copy,axis=0)
print(cos.shape)
53/53:
cos = np.nanmean(EEG1,axis=0)
print(cos.shape)
53/54:
cos = np.nanmean(EEG1,axis=1)
print(cos.shape)
53/55:
cos = np.nanmean(EEG1,axis=0)
print(cos.shape)
53/56:
for i in cos:
    plt.plot(i[3])
plt.show()
53/57:
for i in cos:
    plt.plot(i[3])
    plt.show()
53/58:
for i in cos:
    plt.plot(i[0])
    plt.show()
53/59:
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.plot(syg[0,:])
    plt.show()
53/60:
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.plot(syg[0,:])
plt.show()
53/61:
plt.figure(figsize=(15,15))
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.plot(syg[0,:])
plt.show()
53/62:
plt.figure(figsize=(15,15))
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.plot(syg[0,:])
plt.show()
53/63:
plt.figure(figsize=(15,15))
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.plot(syg[2,:])
plt.show()
53/64:
plt.figure(figsize=(25,25))
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.plot(syg[2,:])
plt.show()
53/65:
plt.figure(figsize=(25,25))
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.title(f'(błysk nr {i}))
    plt.plot(syg[2,:])
plt.show()
53/66:
plt.figure(figsize=(25,25))
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.title(f'(błysk nr {i})')
    plt.plot(syg[2,:])
plt.show()
53/67:
plt.figure(figsize=(25,25))
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.title(f'Błysk nr {i+1}')
    plt.plot(syg[2,:])
plt.show()
53/68:
plt.figure(figsize=(25,25))
t = np.arange(-0.3,0.6,1/Fs)
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/69:
plt.figure(figsize=(25,25))
t = np.arange(-0.3,0.6,1/EEG.Fs)
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/70:
plt.figure(figsize=(25,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/71:
plt.figure(figsize=(25,25))
t = np.arange(-300,600,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/72:
plt.figure(figsize=(25,25))
t = np.linspace(-300,600,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/73:
plt.figure(figsize=(25,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/74:
plt.figure(figsize=(25,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.ahvline(0)
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/75:
plt.figure(figsize=(25,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0)
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/76:
plt.figure(figsize=(25,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(4,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/77:
plt.figure(figsize=(25,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(5,3,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/78:
plt.figure(figsize=(40,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(3,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/79:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
53/80:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
53/81:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/82: print(ile)
53/83:
EEG

plt.plot(EEG1[0,0,4,:])
plt.plot(fragments_copy[0,4,:])
plt.show()
53/84:
cos = np.nanmean(EEG1,axis=0)
print(cos.shape)
53/85:
plt.figure(figsize=(40,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(3,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/86: print(ile)
53/87:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/88: print(ile)
53/89:

plt.plot(EEG1[0,0,4,:])
plt.plot(fragments_copy[0,4,:])
plt.show()
53/90:
cos = np.nanmean(EEG1,axis=0)
print(cos.shape)
53/91:
plt.figure(figsize=(40,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(3,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/92:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
53/93:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
53/94:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
53/95: print(ile)
53/96:

plt.plot(EEG1[0,0,4,:])
plt.plot(fragments_copy[0,4,:])
plt.show()
53/97:
cos = np.nanmean(EEG1,axis=0)
print(cos.shape)
53/98:
plt.figure(figsize=(40,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(3,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
53/99: EEG.welch_mean_spectrum()
53/100: print(EEG.welch_mean_spectrum())
53/101: EEG.graphics_spectrum_plot()
53/102:
fig, ax = plt.figure()
EEG.graphics_spectrum_plot()
53/103:
fig, ax = plt.subplots()
EEG.graphics_spectrum_plot()
53/104:
fig, ax = plt.subplots()
EEG.graphics_spectrum_plot(fig, ax)
53/105:
fig, ax = plt.subplots(
    nrows=max([EEG.num_channels, EEG.num_channels]),
    ncols=1,
    sharex=True,
    sharey=True,
    figsize=(10, 10)
)
EEG.graphics_spectrum_plot(fig, ax)
53/106:
fig, ax = plt.subplots(
    nrows=max([EEG.num_channels, EEG.num_channels]),
    ncols=1,
    sharex=True,
    sharey=True,
    figsize=(50, 10)
)
EEG.graphics_spectrum_plot(fig, ax)
53/107:
fig, ax = plt.subplots(
    nrows=max([EEG.num_channels, EEG.num_channels]),
    ncols=1,
    sharex=True,
    sharey=True,
    figsize=(10, 50)
)
EEG.graphics_spectrum_plot(fig, ax)
53/108:
fig, ax = plt.subplots(
    nrows=max([EEG.num_channels, EEG.num_channels]),
    ncols=1,
    sharex=True,
    sharey=True,
    ylim=(0,70)
    figsize=(10, 50)
)
EEG.graphics_spectrum_plot(fig, ax)
53/109:
fig, ax = plt.subplots(
    nrows=max([EEG.num_channels, EEG.num_channels]),
    ncols=1,
    sharex=True,
    sharey=True,
    ylim=(0,70),
    figsize=(10, 50)
)
EEG.graphics_spectrum_plot(fig, ax)
53/110:
fig, ax = plt.subplots(
    nrows=max([EEG.num_channels, EEG.num_channels]),
    ncols=1,
    sharex=True,
    sharey=True,
    figsize=(10, 50)
)
plt.ylim=(0,70)
EEG.graphics_spectrum_plot(fig, ax)
53/111:
fig, ax = plt.subplots(
    nrows=max([EEG.num_channels, EEG.num_channels]),
    ncols=1,
    sharex=True,
    sharey=True,
    figsize=(10, 50)
)
plt.ylim(0,70)
EEG.graphics_spectrum_plot(fig, ax)
53/112:
fig, ax = plt.subplots(
    nrows=max([EEG.num_channels, EEG.num_channels]),
    ncols=1,
    sharex=True,
    sharey=True,
    figsize=(10, 50)
)

plt.ylim(0,70)
EEG.graphics_spectrum_plot(fig, ax)
53/113:
fig, ax = plt.subplots(
    nrows=max([EEG.num_channels, EEG.num_channels]),
    ncols=1,
    sharex=True,
    sharey=True,
    figsize=(10, 50)
)

# plt.ylim(0,70)
EEG.graphics_spectrum_plot(fig, ax)
54/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
54/2:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
54/3:
fig, ax = plt.subplots(
    nrows=max([EEG.num_channels, EEG.num_channels]),
    ncols=1,
    sharex=True,
    sharey=True,
    figsize=(10, 50)
)

plt.ylim(0,70)
EEG.graphics_spectrum_plot(fig, ax)
54/4:
fig, ax = plt.subplots(
    nrows=max([EEG.num_channels, EEG.num_channels]),
    ncols=1,
    sharex=True,
    sharey=True,
    figsize=(10, 50)
)

# plt.ylim(0,70)
EEG.graphics_spectrum_plot(fig, ax)
54/5:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
54/6:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
54/7:
fig, ax = plt.subplots(
    nrows=max([EEG.num_channels, EEG.num_channels]),
    ncols=1,
    sharex=True,
    sharey=True,
    figsize=(10, 50)
)

# plt.ylim(0,70)
EEG.graphics_spectrum_plot(fig, ax)
55/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
55/2:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
55/3:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
55/4: EEG2D[0,0,:]
55/5: EEG_2D[0,0,:]
55/6: EEG_2D[0,:]
55/7:
x = EEG_2D[2,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.semilogy(f, Pxx_den)
plt.ylim([0.5e-3, 1])
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/8:
x = EEG_2D[2,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.semilogy(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/9:
x = EEG_2D[2,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.semilogy(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/10:
x = EEG_2D[2,:]
f, Pxx_den = ss.welch(x, EEG.fs)
plt.semilogy(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/11:
x = EEG_2D[2,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.semilogy(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/12:
x = EEG_2D[2,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/13:
x = EEG_2D[0,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/14:
plt.figure(figsize=(16,16))
x = EEG_2D[0,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/15:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
55/16:
plt.figure(figsize=(16,16))
x = EEG_2D[0,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/17:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
55/18:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
55/19: print(ile)
55/20:

plt.plot(EEG1[0,0,4,:])
plt.plot(fragments_copy[0,4,:])
plt.show()
55/21:
cos = np.nanmean(EEG1,axis=0)
print(cos.shape)
55/22:
plt.figure(figsize=(40,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(3,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
55/23:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
55/24: print(ile)
55/25:

plt.plot(EEG1[0,0,4,:])
plt.plot(fragments_copy[0,4,:])
plt.show()
55/26:
cos = np.nanmean(EEG1,axis=0)
print(cos.shape)
55/27:
plt.figure(figsize=(40,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(3,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
55/28:
plt.figure(figsize=(16,16))
x = EEG_2D[len(EEG_2D[0,:])//2:,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/29:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])//2
x = EEG_2D[0,start:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/30:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])//(2/3)
x = EEG_2D[0,start:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/31:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])//int(2/3)
x = EEG_2D[0,start:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/32:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])//(2/3)
x = EEG_2D[0,start:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/33:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])//(2/3)
print(start)
x = EEG_2D[0,start:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/34:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])//(2/3)
print(start)
x = EEG_2D[0,int(start):]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/35:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])//(3/2)
x = EEG_2D[0,start:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/36:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,int(start):]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/37:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,int(start):]
x = EEG_2D[0,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
# plt.ylim([0.5e-3, 1])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/38:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,int(start):]
x = EEG_2D[0,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
plt.ylim([0,44])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
55/39:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
plt.ylim([0,44])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')

start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,int(start):]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
plt.ylim([0,44])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
58/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
58/2:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
58/3:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
58/4:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = 1 
kanał2 = -1 
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
58/5:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
58/6:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
58/7:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
58/8:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
58/9:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 200)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
from scipy import signal
60/2:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = 1 
kanał2 = -1 
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
60/3:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 200)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/4:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.5),distance = 200)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/5:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = 1 
kanał2 = -1 
próbki = int(20000)
pstart = int(150000)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
60/6:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = 1 
kanał2 = -2 
próbki = int(20000)
pstart = int(150000)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
60/7:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = 1 
kanał2 = -2 
próbki = int(170000)
pstart = int(150000)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
60/8:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.9),distance = 200)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/9:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.9),distance = 200)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/10:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.9),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/11:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.5),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/12:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.5),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/13:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.9),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/14:
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG.data[0, trigger_index2, :], height=np.percentile(EEG.data[0, trigger_index2, :],99),distance = 100)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/15: gragments2
60/16: fragments2
60/17:
t
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG.data[0, trigger_index2, :], height=np.percentile(EEG.data[0, trigger_index2, :],99),distance = 100)
print(peaks2)
# peaks2
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/18:
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG.data[0, trigger_index2, :], height=np.percentile(EEG.data[0, trigger_index2, :],99),distance = 100)
print(peaks2)
# peaks2
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/19:
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG.data[0, trigger_index2, :], height=np.percentile(EEG.data[0, trigger_index2, :],99),distance = 100)
print(peaks2)
peaks2 = peaks2 - peaks1
print(peaks2)
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/20:
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG.data[0, trigger_index2, :], height=np.percentile(EEG.data[0, trigger_index2, :],99),distance = 100)
print(peaks2)
peaks2 = peaks2 - peaks
print(peaks2)
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/21:
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG.data[0, trigger_index2, :], height=np.percentile(EEG.data[0, trigger_index2, :],99),distance = 100)
print(peaks2)
peaks2 = set(peaks2) - set(peaks)
print(peaks2)
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/22:
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG.data[0, trigger_index2, :], height=np.percentile(EEG.data[0, trigger_index2, :],99),distance = 100)
print(peaks2)
peaks2 = set(peaks2) - set(peaks)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/23:
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG.data[0, trigger_index2, :], height=np.percentile(EEG.data[0, trigger_index2, :],99),distance = 100)
print(peaks2)
peaks2 = set(peaks2) - set(peaks-1) 
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/24:
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG.data[0, trigger_index2, :], height=np.percentile(EEG.data[0, trigger_index2, :],99),distance = 100)
print(peaks2)
peaks2 = set(peaks2) - set(peaks-1) - set(peaks) 
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/25:
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG.data[0, trigger_index2, :], height=np.percentile(EEG.data[0, trigger_index2, :],99),distance = 100)
print(peaks2)
peaks2 = set(peaks2) - set(peaks-1) - set(peaks) - set(peaks+1)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/26:
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG.data[0, trigger_index2, :], height=np.percentile(EEG.data[0, trigger_index2, :],99),distance = 100)
print(peaks2)
peaks2 = set(peaks2) - set(peaks-1) - set(peaks) - set(peaks+1)- set(peaks+2)- set(peaks-2)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/27:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = 1 
kanał2 = -2 
próbki = int(170000)
pstart = int(0)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki]-EEG_2D[-1,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
60/28:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = 1 
kanał2 = -1
próbki = int(170000)
pstart = int(0)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki]-EEG_2D[-2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
60/29:
EEG_Trig = EEG_2D[-1,:,:] - EEG_2D[-2,:,:] 
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG_Trig, height=np.percentile(EEG_Trig,99),distance = 100)
print(peaks2)
# peaks2 = set(peaks2) - set(peaks-1) - set(peaks) - set(peaks+1)- set(peaks+2)- set(peaks-2)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/30:
EEG_Trig = EEG_2D[-1,:] - EEG_2D[-2,:] 
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG_Trig, height=np.percentile(EEG_Trig,99),distance = 100)
print(peaks2)
# peaks2 = set(peaks2) - set(peaks-1) - set(peaks) - set(peaks+1)- set(peaks+2)- set(peaks-2)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/31:
EEG_Trig = EEG_2D[-1,:] - EEG_2D[-2,:] 
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG_Trig, height=np.percentile(EEG_Trig,99),distance = 100)
print(peaks2)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/32:
EEG_Trig = EEG_2D[-1,:] - EEG_2D[-2,:] 
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG_Trig, height=np.percentile(EEG_Trig,99),distance = 100)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index2, :])
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/33:
EEG_Trig = EEG_2D[-1,:] - EEG_2D[-2,:] 
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG_Trig, height=np.percentile(EEG_Trig,99),distance = 100)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG_Trig)
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/34:
EEG_Trig = EEG_2D[-1,:] - EEG_2D[-2,:] 
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG_Trig, height=np.percentile(EEG_Trig,99),distance = 100)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG_Trig)
plt.plot(peaks2, EEG_Trig, "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/35:
EEG_Trig = EEG_2D[-1,:] - EEG_2D[-2,:] 
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG_Trig, height=np.percentile(EEG_Trig,99),distance = 100)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG_Trig)
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/36:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
60/37:
fragments2_copy = fragments2.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments2_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments2_copy[i,:,:] = np.nan
60/38:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
print(fragments_copy.shape)
60/39:
fragments2_copy = fragments2.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments2_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments2_copy[i,:,:] = np.nan
print(fragments2_copy.shape)
60/40:
fragments_copy = fragments.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
print(fragments_copy.shape)
60/41:
fragments2_copy = fragments2.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments2_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments2_copy[i,:,:] = np.nan
print(fragments2_copy.shape)
60/42:
fragments_copy = fragments.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
print(fragments_copy.shape)
print(ile)
60/43:
fragments2_copy = fragments2.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments2_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments2_copy[i,:,:] = np.nan
print(fragments2_copy.shape)
print(ile)
60/44:
cos1 = np.nanmean(fragments_copy,axis=0)
print(cos1.shape)
cos2 = np.nanmean(fragments2_copy,axis=0)
plt.figure(figsize=(40,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(cos):
    plt.subplot(4,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
60/45:
for i, syg1, syg2 in enumerate(zip(cos1, cos2)):
    print(i, syg1, syg2)
60/46:
for i, syg in enumerate(zip(cos1, cos2)):
    print(i, syg[0], syg[1])
60/47:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(40,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(4,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0])
    plt.plot(t,syg[1])
plt.show()
60/48:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(40,30))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(4,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0])
    plt.plot(t,syg[1])
plt.show()
60/49:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(40,30))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(4,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    plt.legend()
plt.show()
60/50:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(40,30))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    plt.legend()
plt.show()
60/51:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(40,50))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    plt.legend()
plt.show()
60/52:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(40,50))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    plt.set_facecolor('xkcd:salmon')
    plt.legend()
plt.show()
60/53:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(40,50))
t = np.arange(-0.3,0.6,1/EEG.fs)
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    plt.gcf().set_facecolor('xkcd:salmon')
    plt.legend()
plt.show()
60/54:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(40,50))
t = np.arange(-0.3,0.6,1/EEG.fs)
plt.gcf().set_facecolor('xkcd:salmon')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/55:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
import matplotlib as mpl
from scipy import signal
60/56:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(40,50))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/57:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
56/1:
plt.figure(figsize=(40,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
    plt.subplot(3,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
66/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
import matplotlib as mpl
from scipy import signal
66/2:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
66/3:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
plt.ylim([0,44])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')

start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,int(start):]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
plt.ylim([0,44])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
66/4:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
66/5:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
66/6: print(ile)
66/7:

plt.plot(EEG1[0,0,4,:])
plt.plot(fragments_copy[0,4,:])
plt.show()
66/8:
cos = np.nanmean(EEG1,axis=0)
print(cos.shape)
66/9:
plt.figure(figsize=(40,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
    plt.subplot(3,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
66/10:
plt.figure(figsize=(20,12))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
    plt.subplot(3,5,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
66/11:
plt.figure(figsize=(20,12))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
    plt.subplot(5,3,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
66/12:
plt.figure(figsize=(20,15))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
    plt.subplot(5,3,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
66/13:
plt.figure(figsize=(15,20))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
    plt.subplot(5,3,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
66/14:
plt.figure(figsize=(15,20))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
    plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
66/15:
mpl.style.use('default')
plt.plot(EEG1[0,0,4,:])
plt.plot(fragments_copy[0,4,:])
plt.show()
66/16:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
import matplotlib as mpl
from scipy import signal
mpl.style.use('default')
66/17:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
66/18:
plt.figure(figsize=(16,16))
start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
plt.ylim([0,44])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')

start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,int(start):]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
plt.ylim([0,44])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
66/19:
trigger_index = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
66/20:
fragments_copy = fragments.copy()
cutoff = 80
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
EEG1 = fragments_copy.reshape((60,15,22,461))
66/21:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (12,6))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
66/22:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)

fig = plt.figure(figsize = (15,8))
plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (15,8))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
66/23:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['2']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)

fig = plt.figure(figsize = (15,6))
plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (15,6))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
66/24:
plt.figure(figsize=(10,10))
start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
plt.ylim([0,44])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')

start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,int(start):]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
plt.ylim([0,44])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
66/25:
plt.figure(figsize=(5,5))
start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,:]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
plt.ylim([0,44])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')

start = len(EEG_2D[0,:])*(2/3)
x = EEG_2D[0,int(start):]
f, Pxx_den = ss.welch(x, EEG.fs, nperseg=1024)
plt.plot(f, Pxx_den)
plt.ylim([0,44])
plt.xlim(0,20)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
57/1:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
import matplotlib as mpl
from scipy import signal
mpl.style.use('default')
67/1: # !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master
67/2:
'''IMPORTY'''

import numpy as np
from scipy.stats import pearsonr
import scipy.signal as ss
import scipy.stats as scst
import saffy
from saffy.generators.svarog import svarog
import matplotlib.pyplot as plt
import matplotlib as mpl
from scipy import signal
mpl.style.use('default')
67/3:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))

EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
67/4:
trigger_index =- 1
EEG.data.shape
start = -0.3
stop = 0.4

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99))
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
plt.xlim((0, 2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
67/5:
# FUNNY_EEG = EEG.set_epochs_from_tags(-0.3, 0.4)
FUNNY_EEG = fragments
67/6:
t = np.arange(-0.3, 0.4-1/EEG.fs, 1/EEG.fs)

plt.plot(t, np.mean(FUNNY_EEG[:100,2,:], axis=0))
plt.show()
plt.plot(t, np.mean(FUNNY_EEG[100:200,2,:], axis=0))
plt.show()
67/7:
plt.plot(t,FUNNY_EEG[5,0,:])
plt.show()
67/8:
print(FUNNY_EEG.data.shape)
first_part = FUNNY_EEG[:100, :, :]
second_part = FUNNY_EEG[100:, :, :]
67/9:
clean_data_first = []
cutoff = 80
for fragment in first_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_first.append(fragment)
clean_data_first = np.array(clean_data_first)

clean_data_second = []
for fragment in second_part:
    if np.max(fragment[-5,:]) < cutoff and np.max(fragment[-4,:]) < cutoff:
        clean_data_second.append(fragment)
clean_data_second = np.array(clean_data_second)
67/10: clean_data_first.shape
67/11:
def find_N2_P2(sygnal,Fs):
    syg = sygnal[int(0.30*Fs):int(0.55*Fs)]
    N2 = ss.argrelmin(syg)[0][0]
    for i in ss.argrelmax(syg)[0]:
        if i > N2:
            P2 = i
            break
    return (N2/Fs,syg[N2]), (P2/Fs,syg[P2])
67/12:

plt.figure(figsize=(40,40))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
    k+=1
plt.show()

S = np.array(PII)-np.array(PI)
plt.plot(S)
plt.show()
print(S)
67/13:
plt.figure(figsize=(40,27))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud: {round(abs(S[ch]), 2)}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label =f'Granica istotności statystycznej: {round(gorny, 2)}')
    plt.title(f'Rozkład różnic amplitud  dla kanłu {CH[ch]}')
    plt.legend()
#     print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
#     print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
67/14:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['1']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))

EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery

EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = -3 #trig1
kanał2 = -2 #trig2
# próbki = int(60*5 * EEG.fs)
# pstart = int(60*4.5*EEG.fs)
próbki = int(5* EEG.fs)
pstart = int(EEG.fs)

fig = plt.figure(figsize = (15,6))
plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (15,6))
plt.plot(EEG_2D[kanał2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
67/15:

plt.figure(figsize=(20,20))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
    k+=1
plt.show()

S = np.array(PII)-np.array(PI)
plt.plot(S)
plt.show()
print(S)
67/16:

plt.figure(figsize=(20,20))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(4,5,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
    k+=1
plt.show()

# S = np.array(PII)-np.array(PI)
# plt.plot(S)
# plt.show()
# print(S)
67/17:
plt.figure(figsize=(20,15))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud: {round(abs(S[ch]), 2)}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label =f'Granica istotności statystycznej: {round(gorny, 2)}')
    plt.title(f'Rozkład różnic amplitud  dla kanłu {CH[ch]}')
    plt.legend()
#     print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
#     print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
67/18:
plt.figure(figsize=(18,12))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud: {round(abs(S[ch]), 2)}')
    plt.hist(random, bins = 20)
    plt.axvline(gorny,color='r',label =f'Granica istotności statystycznej: {round(gorny, 2)}')
    plt.title(f'Rozkład różnic amplitud  dla kanłu {CH[ch]}')
    plt.legend()
#     print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
#     print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
67/19:
plt.figure(figsize=(18,12))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud: {round(abs(S[ch]), 2)}')
    plt.hist(random, bins = 30)
    plt.axvline(gorny,color='r',label =f'Granica istotności statystycznej: {round(gorny, 2)}')
    plt.title(f'Rozkład różnic amplitud  dla kanłu {CH[ch]}')
    plt.legend()
#     print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
#     print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
67/20:
plt.figure(figsize=(18,12))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud: {round(abs(S[ch]), 2)}')
    plt.hist(random, bins = 25)
    plt.axvline(gorny,color='r',label =f'Granica istotności statystycznej: {round(gorny, 2)}')
    plt.title(f'Rozkład różnic amplitud  dla kanłu {CH[ch]}')
    plt.legend()
#     print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
#     print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
67/21:

plt.figure(figsize=(20,20))
k=0
PI = []
PII = []
while k < 19:
    plt.subplot(5,4,k+1)
    plt.ylim(-8,8)
    plt.xlim(-0.1, 0.3)
    plt.title(CH[k])
    plt.axhline(0, color = 'g')
    first = np.mean(clean_data_first[:,k,:], axis=0)
    second = np.mean(clean_data_second[:,k,:], axis=0)
    plt.plot(t, first)
    plt.plot(t, second)
    try:
        N2f, P2f = find_N2_P2(first,EEG.fs)
        N2s, P2s = find_N2_P2(second,EEG.fs)
        plt.plot(N2s[0],N2s[1], marker='o', markersize=9, color="green")
        plt.plot(P2s[0],P2s[1], marker='o', markersize=9, color="green")
        plt.plot(N2f[0],N2f[1], marker='o', markersize=9, color="red")
        plt.plot(P2f[0],P2f[1], marker='o', markersize=9, color="red")
        PI.append(P2f[1]-N2f[1])
        PII.append(P2s[1]-N2s[1])
    except IndexError:
        pass
    k+=1
plt.show()

# S = np.array(PII)-np.array(PI)
# plt.plot(S)
# plt.show()
# print(S)
60/58:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.fill_betweenx(0, 0.25, 0.35, color = 'red', label = 'P300')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/59:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    x = np.arange(0.25,0.35,1/EEG.fs)
    plt.fill_between(0, -10, 10, color = 'red', label = 'P300')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/60:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    x = np.arange(0.25,0.35,1/EEG.fs)
    plt.fill_between(0, -10, 10, color = 'red')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/61:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.axvspan(.25, .35, color = 'red')
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/62:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.axvspan(.25, .35, color = 'red', alpha = 0.2)
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/63:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.axvspan(.18, .30, color = 'red', alpha = 0.2)
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/64:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.1, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = 1 
kanał2 = -1
próbki = int(170000)
pstart = int(0)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki]-EEG_2D[-2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
60/65:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.9),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/66:
EEG_Trig = EEG_2D[-1,:] - EEG_2D[-2,:] 
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG_Trig, height=np.percentile(EEG_Trig,99),distance = 100)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG_Trig)
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/67:
fragments_copy = fragments.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
print(fragments_copy.shape)
print(ile)
60/68:
fragments2_copy = fragments2.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments2_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments2_copy[i,:,:] = np.nan
print(fragments2_copy.shape)
print(ile)
60/69:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.axvspan(.18, .30, color = 'red', alpha = 0.2)
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/70:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.3, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = 1 
kanał2 = -1
próbki = int(170000)
pstart = int(0)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki]-EEG_2D[-2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
60/71:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.9),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/72:
EEG_Trig = EEG_2D[-1,:] - EEG_2D[-2,:] 
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG_Trig, height=np.percentile(EEG_Trig,99),distance = 100)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG_Trig)
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/73:
fragments_copy = fragments.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
print(fragments_copy.shape)
print(ile)
60/74:
fragments2_copy = fragments2.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments2_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments2_copy[i,:,:] = np.nan
print(fragments2_copy.shape)
print(ile)
60/75:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.axvspan(.18, .30, color = 'red', alpha = 0.2)
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/76:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.5, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = 1 
kanał2 = -1
próbki = int(170000)
pstart = int(0)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki]-EEG_2D[-2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
60/77:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.9),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/78:
EEG_Trig = EEG_2D[-1,:] - EEG_2D[-2,:] 
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG_Trig, height=np.percentile(EEG_Trig,99),distance = 100)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG_Trig)
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/79:
fragments_copy = fragments.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
print(fragments_copy.shape)
print(ile)
60/80:
fragments2_copy = fragments2.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments2_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments2_copy[i,:,:] = np.nan
print(fragments2_copy.shape)
print(ile)
60/81:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.axvspan(.18, .30, color = 'red', alpha = 0.2)
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/82:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=0.8, highcut=20, order=4)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = 1 
kanał2 = -1
próbki = int(170000)
pstart = int(0)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki]-EEG_2D[-2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
60/83:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.9),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/84:
EEG_Trig = EEG_2D[-1,:] - EEG_2D[-2,:] 
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG_Trig, height=np.percentile(EEG_Trig,99),distance = 100)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG_Trig)
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/85:
fragments_copy = fragments.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
print(fragments_copy.shape)
print(ile)
60/86:
fragments2_copy = fragments2.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments2_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments2_copy[i,:,:] = np.nan
print(fragments2_copy.shape)
print(ile)
60/87:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.axvspan(.18, .30, color = 'red', alpha = 0.2)
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/88:
'''Czytanie, montowanie i obróbka sygnałów.
                BEZ FILTRA.'''

pliki = {'1':'beata1', '2':'beata2', '3':'beata3'}
fig = plt.figure(figsize = (25,10))

EEG = saffy.SignalManager(generator=svarog(pliki['3']))

CH = ['O1','O2','T5','P3','Pz','P4','T6','T3','C3','Cz','C4','T4','F7','F3','Fz','F4','F8','Fp1','Fp2','ref','trig1','trig2'] 
EEG.extract_channels(CH)
print(len(CH))


EEG.data[0,:-2,:] = EEG.data[0,:-2,:] - EEG.data[0,-3,:]
triggery = EEG.data[0,-2:,:]
EEG.butter_bandpass_filter(lowcut=1, highcut=20, order=2)
EEG.data[0,-2:,:] = triggery


EEG_2D = EEG.data[0,:,:] #jest tylko jeden zestaw danych

CH_N = EEG_2D.shape[0]
kanał = 1 
kanał2 = -1
próbki = int(170000)
pstart = int(0)


plt.plot(EEG_2D[kanał,pstart:próbki], color = 'g')
plt.title(f"sygnał EEG z {CH[kanał]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
fig = plt.figure(figsize = (25,10))
plt.plot(EEG_2D[kanał2,pstart:próbki]-EEG_2D[-2,pstart:próbki])
plt.title(f"sygnał EEG z {CH[kanał2]} kanału, trwajacy {próbki/EEG.fs}s.")
plt.show()
print(f"rozmiar naszej macierzy z sygnałami (liczba kanałów , liczba próbek) = {EEG_2D.data.shape} ")
print('Fs: ', EEG.fs)
60/89:
trigger_index = -2
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks, _ = ss.find_peaks(EEG.data[0, trigger_index, :], height=np.percentile(EEG.data[0, trigger_index, :],99.9),distance = 100)
print(len(peaks))
fragments = np.zeros((len(peaks), 22, int(abs(stop - start)*EEG.fs+1)))
fragments.shape
plt.figure(figsize=(16,4))
plt.plot(EEG.data[0, trigger_index, :])
plt.plot(peaks, EEG.data[0, trigger_index, peaks], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks):
    fragments[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments.shape)
60/90:
EEG_Trig = EEG_2D[-1,:] - EEG_2D[-2,:] 
trigger_index2 = -1
print(EEG.data.shape)
start = -0.3
stop = 0.6

peaks2, _ = ss.find_peaks(EEG_Trig, height=np.percentile(EEG_Trig,99),distance = 100)
print(len(peaks2))
fragments2 = np.zeros((len(peaks2), 22, int(abs(stop - start)*EEG.fs+1)))
fragments2.shape
plt.figure(figsize=(16,4))
plt.plot(EEG_Trig)
plt.plot(peaks2, EEG.data[0, trigger_index2, peaks2], "x")
# plt.xlim((543552 -5*2048, 543552-6*2048))
plt.show()
for i, peak in enumerate(peaks2):
    fragments2[i,:,:] = EEG.data[0, :, int(peak+start*EEG.fs):int(peak+stop*EEG.fs)]
print(fragments2.shape)
60/91:
fragments_copy = fragments.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments_copy[i,:,:] = np.nan
print(fragments_copy.shape)
print(ile)
60/92:
fragments2_copy = fragments2.copy()
cutoff = 75
ile = 0
for i, fragment in enumerate(fragments2_copy):
    if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff or np.any(np.abs(fragment[:-4,:]) > 75):
#     if np.max(fragment[-5,:]) > cutoff and np.max(fragment[-4,:]) > cutoff:
        ile +=1
        fragments2_copy[i,:,:] = np.nan
print(fragments2_copy.shape)
print(ile)
60/93:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.axvspan(.18, .30, color = 'red', alpha = 0.2)
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
60/94:
cos1 = np.nanmean(fragments_copy,axis=0)
cos2 = np.nanmean(fragments2_copy,axis=0)
cos1 = cos1[:19, :]
cos2 = cos2[:19, :]
plt.figure(figsize=(20,25))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(zip(cos1, cos2)):
    plt.subplot(5,4,i+1)
    plt.ylim(-10,10)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.axvspan(.18, .34, color = 'red', alpha = 0.2)
    plt.title(f'Kanał {CH[i]}')
    plt.plot(t,syg[0], label = 'Błyski podwójne')
    plt.plot(t,syg[1], label = 'Błyski pojedyncze')
    
    plt.legend()
plt.show()
66/26:
plt.figure(figsize=(15,20))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
    plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
66/27:
from matplotlib import cm
cmap = cm.get_cmap('hsv', 256)
colors = cmap(np.linspace(0, 1, 256))

plt.figure(figsize=(15,20))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors)
plt.show()
66/28:
from matplotlib import cm
cmap = cm.get_cmap('hsv', 256)
colors = cmap(np.linspace(0, 1, 256))
66/29:

plt.figure(figsize=(15,20))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors)
plt.show()
66/30:

plt.figure(figsize=(15,20))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i])
plt.show()
66/31:
from matplotlib import cm
cmap = cm.get_cmap('jet', 256)
colors = cmap(np.linspace(0, 1, 256))
66/32:

plt.figure(figsize=(15,20))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i])
plt.show()
66/33:
from matplotlib import cm
cmap = cm.get_cmap('hsv', 256)
colors = cmap(np.linspace(0, 1, 256))
66/34:

plt.figure(figsize=(15,20))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i])
plt.show()
66/35:
from matplotlib import cm
cmap = cm.get_cmap('hsv', 256)
colors = cmap(np.linspace(0, 1, 15))
66/36:

plt.figure(figsize=(15,20))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i])
plt.show()
66/37:
from matplotlib import cm
cmap = cm.get_cmap('jet', 256)
colors = cmap(np.linspace(0, 1, 15))
66/38:

plt.figure(figsize=(15,20))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i])
plt.show()
66/39:
from matplotlib import cm
cmap = cm.get_cmap('jet', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(15,20))
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i])
plt.show()
66/40:
from matplotlib import cm
cmap = cm.get_cmap('jet', 256)
colors = cmap(np.linspace(0, 1, 15))
# plt.figure(figsize=(15,20))

t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i])
plt.show()
66/41:
from matplotlib import cm
cmap = cm.get_cmap('jet', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(20,15))

t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/42:
from matplotlib import cm
cmap = cm.get_cmap('jet', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/43:
from matplotlib import cm
cmap = cm.get_cmap('autumn', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/44:
from matplotlib import cm
cmap = cm.get_cmap('greys', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/45:
from matplotlib import cm
cmap = cm.get_cmap('Greys', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/46:
from matplotlib import cm
cmap = cm.get_cmap('binary', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/47:
from matplotlib import cm
cmap = cm.get_cmap('gray', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/48:
from matplotlib import cm
cmap = cm.get_cmap('binary', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/49:
from matplotlib import cm
cmap = cm.get_cmap('afmhot', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/50:
from matplotlib import cm
cmap = cm.get_cmap('inferno', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/51:
from matplotlib import cm
cmap = cm.get_cmap('inferno', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/52:
from matplotlib import cm
cmap = cm.get_cmap('afmhot', 256)
colors = cmap(np.linspace(0, 1, 15))
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/53:
from matplotlib import cm
cmap = cm.get_cmap('afmhot', 256)
colors = cmap(np.linspace(0, 1, 15))
colors = colors[:-1]
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/54:
from matplotlib import cm
cmap = cm.get_cmap('afmhot', 256)
colors = cmap(np.linspace(0, 1, 15))
colors = colors[::-1]
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/55:
from matplotlib import cm
cmap = cm.get_cmap('afmhot', 256)
colors = cmap(np.linspace(0, 1, 15))
colors = colors[::-1]
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'b', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/56:
from matplotlib import cm
cmap = cm.get_cmap('afmhot', 15)
colors = cmap(np.linspace(0, 1, 15))
colors = colors[::-1]
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'b', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/57:
from matplotlib import cm
cmap = cm.get_cmap('afmhot', 15)
colors = cmap(np.linspace(0, 1, 15))
colors = colors[::-1]
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'black', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/58:
from matplotlib import cm
cmap = cm.get_cmap('afmhot', 15)
colors = cmap(np.linspace(0, 1, 15))
colors = colors[::-1]
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'red', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/59:
from matplotlib import cm
cmap = cm.get_cmap('afmhot', 15)
colors = cmap(np.linspace(0, 1, 15))
colors = colors[::-1]
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'k', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/60:
from matplotlib import cm
cmap = cm.get_cmap('afmhot', 15)
colors = cmap(np.linspace(0, 1, 15))
colors = colors[::-1]
plt.figure(figsize=(20,15))
plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
#     plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
#     plt.axvline(0, color = 'g', label = 'Bodziec')
#     plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:], color = colors[i], label = f'Błysk nr {i+1}')
    plt.legend()
plt.show()
66/61:
plt.figure(figsize=(20,15))
# plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
    plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
66/62:
plt.figure(figsize=(20,20))
# plt.axvline(0, color = 'g', label = 'Bodziec')
t = np.arange(-0.3,0.6,1/EEG.fs)
mpl.style.use('default')
for i, syg in enumerate(cos):
    plt.subplot(5,3,i+1)
    plt.ylim(-12,12)
    plt.axvline(0, color = 'g', label = 'Bodziec')
    plt.title(f'Błysk nr {i+1}')
    plt.plot(t,syg[2,:])
plt.show()
67/22:
plt.figure(figsize=(18,12))

for ch in range(0,6):
    N = 1000
#     ch = 1
    ALL = np.concatenate((clean_data_first[:,ch,:],clean_data_second[:,ch,:]), axis = 0)
    random = np.zeros(N)

    for i in range(N):
        mieszać = np.copy(ALL)
        np.random.shuffle(mieszać)
        first_shuffeld = mieszać[:clean_data_first.shape[0],:]
        second_shuffeld = mieszać[clean_data_first.shape[0]:,:]
        first = np.mean(first_shuffeld, axis=0)
        second = np.mean(second_shuffeld, axis=0)

        try:
            N2f, P2f = find_N2_P2(first,EEG.fs)
            N2s, P2s = find_N2_P2(second,EEG.fs)
            random[i]=abs(abs(P2s[1]-N2s[1])-abs(P2f[1]-N2f[1]))
        except IndexError:
            pass

    
    
    plt.subplot(3,2,ch+1)
    dobre = random[random!=0]
    gorny=np.percentile(dobre,95)
    plt.axvline(abs(S[ch]),color='g',label = f'Różnica amplitud: {round(abs(S[ch]), 2)}')
    plt.hist(random, bins = 25)
    plt.axvline(gorny,color='r',label =f'Granica istotności statystycznej (95%): {round(gorny, 2)}')
    plt.title(f'Rozkład różnic amplitud  dla kanłu {CH[ch]}')
    plt.legend()
#     print(f'Różnica amplitud dla kanłu {CH[ch]}: {round(abs(S[ch]), 2)}')
#     print(f'Granica dla 95 percentyla: {round(gorny, 2)}')
plt.show()
68/1: import numpy as np
68/2:
def sin(f, phi, Fs, T):
    t = np.arange(0,T,1/Fs)
    syg = np.sin(2*np.pi*t*f + phi)
    return syg
68/3:
def sin(f, phi, Fs, T):
    t = np.arange(0,T,1/Fs)
    sinus = np.sin(2*np.pi*t*f + phi)
    return t, sinus

def gabor(t0, sigma, omega, Fs, T):
    t = np.arange(0,T,1/Fs)
    gabor = np.exp((t-t0)**2/(2*sigma**2)) * np.cos(omega*(t-t0))
    return t, gabor

t, gabor1 = gabor(1, 0.1, 16, 128, 2)
plt.plot(t,gabor1)
plt.show()
68/4:
import numpy as np
import maplotlib.pyplot as plt
68/5:
def sin(f, phi, Fs, T):
    t = np.arange(0,T,1/Fs)
    sinus = np.sin(2*np.pi*t*f + phi)
    return t, sinus

def gabor(t0, sigma, omega, Fs, T):
    t = np.arange(0,T,1/Fs)
    gabor = np.exp((t-t0)**2/(2*sigma**2)) * np.cos(omega*(t-t0))
    return t, gabor

t, gabor1 = gabor(1, 0.1, 16, 128, 2)
plt.plot(t,gabor1)
plt.show()
68/6:
import numpy as np
import matplotlib.pyplot as plt
68/7:
def sin(f, phi, Fs, T):
    t = np.arange(0,T,1/Fs)
    sinus = np.sin(2*np.pi*t*f + phi)
    return t, sinus

def gabor(t0, sigma, omega, Fs, T):
    t = np.arange(0,T,1/Fs)
    gabor = np.exp((t-t0)**2/(2*sigma**2)) * np.cos(omega*(t-t0))
    return t, gabor

t, gabor1 = gabor(1, 0.1, 16, 128, 2)
plt.plot(t,gabor1)
plt.show()
68/8:
def sin(f, phi, Fs, T):
    t = np.arange(0,T,1/Fs)
    sinus = np.sin(2*np.pi*t*f + phi)
    return t, sinus

def gabor(t0, sigma, omega, Fs, T):
    t = np.arange(0,T,1/Fs)
    gabor = np.exp(-(t-t0)**2/(2*sigma**2)) * np.cos(omega*(t-t0))
    return t, gabor

t, gabor1 = gabor(1, 0.1, 16, 128, 2)
plt.plot(t,gabor1)
plt.show()
68/9:
import numpy as np
import matplotlib.pyplot as plt
import scipy.signal as ss
68/10:
def sin(f, phi, Fs, T):
    t = np.arange(0,T,1/Fs)
    sinus = np.sin(2*np.pi*t*f + phi)
    return t, sinus

def gabor(t0, sigma, omega, Fs, T):
    t = np.arange(0,T,1/Fs)
    gabor = np.exp(-(t-t0)**2/(2*sigma**2)) * np.cos(omega*(t-t0))
    return t, gabor

t, gabor1 = gabor(1, 0.1, 16, 128, 2)
plt.plot(t,gabor1)
plt.show()
68/11:
def sin(f, phi, Fs, T):
    t = np.arange(0,T,1/Fs)
    sinus = np.sin(2*np.pi*t*f + phi)
    return t, sinus

def gabor(t0, sigma, omega, Fs, T):
    t = np.arange(0,T,1/Fs)
    gabor = np.exp(-(t-t0)**2/(2*sigma**2)) * np.cos(omega*(t-t0))
    return t, gabor

t, gabor1 = gabor(1, 0.1, 16, 128, 2)
plt.plot(t,gabor1)
plt.show()
68/12:
t, gabor1 = gabor(1, 0.1, 16, 128, 2)
plt.plot(t,gabor1)
plt.show()
68/13:
def sin(f, phi, Fs, T):
    t = np.arange(0,T,1/Fs)
    sinus = np.sin(2*np.pi*t*f + phi)
    return t, sinus

def gabor(t0, sigma, omega, Fs, T):
    t = np.arange(0,T,1/Fs)
    gabor = np.exp(-(t-t0)**2/(2*sigma**2)) * np.cos(omega*(t-t0))
    return t, gabor
68/14:
gabor_hilbert = ss.hilbert(gabor1)
plt.plot(gabor_hilbert)
plt.show()
68/15:
gabor_hilbert = ss.hilbert(gabor1)
amplitude_envelope = np.abs(gabor_hilbert)
plt.plot(amplitude_envelope)
plt.show()
68/16:
def sin(f, phi, Fs, T):
    t = np.arange(0,T,1/Fs)
    sinus = np.sin(2*np.pi*t*f + phi)
    return t, sinus

def gabor(t0, sigma, omega, Fs, T):
    t = np.arange(0,T,1/Fs)
    gabor = np.exp(-(t-t0)**2/(2*sigma**2)) * np.cos(2*np.pi*omega*(t-t0))
    return t, gabor
68/17:
t, gabor1 = gabor(1, 0.1, 16, 128, 2)
plt.plot(t,gabor1)
plt.show()
68/18:
gabor_hilbert = ss.hilbert(gabor1)
amplitude_envelope = np.abs(gabor_hilbert)
plt.plot(amplitude_envelope)
plt.show()
68/19:
gabor_hilbert = ss.hilbert(gabor1)
amplitude_envelope = np.abs(gabor_hilbert)
plt.plot(amplitude_envelope)
plt.plot(t,gabor1)
plt.show()
68/20:
gabor_hilbert = ss.hilbert(gabor1)
amplitude_envelope = np.abs(gabor_hilbert)
plt.plot(t,amplitude_envelope)
plt.plot(t,gabor1)
plt.show()
68/21:
gabor_hilbert = ss.hilbert(gabor1)
amplitude_envelope = np.abs(gabor_hilbert)
plt.plot(t,gabor1)
plt.plot(t,amplitude_envelope)
plt.show()
68/22: sinus1 = sin(16, 0 ,128 , 1)
68/23:
t, sinus1 = sin(16, 0 ,128 , 1)
plt.plot(t,sinus1)
68/24:
t, sinus1 = sin(16, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
68/25:
t, sinus1 = sin(16, 0 ,128 , 2)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
68/26:
t, sinus1 = sin(16, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
68/27:
t, sinus1 = sin(16, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)

faza = np.unwrap(np.angle(sinus_hilbert))




plt.show()
68/28:
t, sinus1 = sin(16, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)

faza = np.unwrap(np.angle(sinus_hilbert))
plt.plot(t,faza)



plt.show()
68/29:
t, sinus1 = sin(16, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)

faza = np.unwrap(np.angle(sinus_hilbert))
plt.show()

plt.plot(t,faza)



plt.show()
68/30:
t, sinus1 = sin(16, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
plt.plot(t,faza)
plt.show()
68/31:
t, sinus1 = sin(16, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
plt.plot(faza)
plt.show()
68/32:
t, sinus1 = sin(16, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
plt.plot(t,faza)
plt.show()
68/33:
t, sinus1 = sin(16, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faz = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/34:
t, sinus1 = sin(16, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/35:
t, sinus1 = sin(16, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.angle(sinus_hilbert)
faza = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/36:
t, sinus1 = sin(16, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
# faza = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/37:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = fs * t
phi0 = faza - faza2

# faza = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/38:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega * t
phi0 = faza - faza2

# faza = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/39:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega * t
phi0 = faza - faza2
plt.plot(t,phi0)
# faza = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/40:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega * t
phi0 = faza - faza2
plt.plot(t,faza2)
# faza = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/41:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega * t
phi0 = faza - faza2
plt.plot(t,phi0)
# faza = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/42:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0)
# faza = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/43:
omega = 16
t, sinus1 = sin(omega, 0 ,1024 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0)
# faza = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/44:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0)
# faza = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/45:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0)
# faza = faza % (2*np.pi)
plt.plot(t,faza)
plt.show()
68/46:
omega = 16
t, sinus1 = sin(omega, 0 ,16 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0)
plt.plot(t,faza)
plt.show()
68/47:
omega = 16
t, sinus1 = sin(omega, 0 ,32 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0)
plt.plot(t,faza)
plt.show()
68/48:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()

faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0)
plt.plot(t,faza)
plt.show()
68/49:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faz_prim = np.arctan(sinus_hilbert/sinus1)*2*np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0)
plt.plot(t,faza)
plt.show()
68/50:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faz_prim = np.arctan(sinus_hilbert/sinus1)*2*np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
# plt.plot(t,phi0)
# plt.plot(t,faza)
plt.plot(faza_prim)
plt.show()
68/51:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza_prim = np.arctan(sinus_hilbert/sinus1)*2*np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
# plt.plot(t,phi0)
# plt.plot(t,faza)
plt.plot(faza_prim)
plt.show()
68/52:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza_prim = np.arctan(sinus_hilbert/sinus1)*2*np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
# plt.plot(t,phi0)
# plt.plot(t,faza)
plt.plot(t,faza_prim)
plt.show()
68/53:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza_prim = np.arctan(sinus_hilbert/sinus1)
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
# plt.plot(t,phi0)
# plt.plot(t,faza)
plt.plot(t,faza_prim)
plt.show()
68/54:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza_prim = np.arctan(sinus_hilbert/sinus1)/2/np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
# plt.plot(t,phi0)
# plt.plot(t,faza)
plt.plot(t,faza_prim)
plt.show()
68/55:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza_prim = np.arctan(sinus_hilbert.real/sinus1)
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
# plt.plot(t,phi0)
# plt.plot(t,faza)
plt.plot(t,faza_prim)
plt.show()
68/56:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza_prim = np.arctan(sinus_hilbert.real/sinus1)*2*np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
# plt.plot(t,phi0)
# plt.plot(t,faza)
plt.plot(t,faza_prim)
plt.show()
68/57:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza_prim = np.arctan(sinus_hilbert.imag/sinus1)*2*np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
# plt.plot(t,phi0)
# plt.plot(t,faza)
plt.plot(t,faza_prim)
plt.show()
68/58:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza_prim = np.arctan(sinus_hilbert.imag/sinus_hilbert.real)*2*np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
# plt.plot(t,phi0)
# plt.plot(t,faza)
plt.plot(t,faza_prim)
plt.show()
68/59:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza_prim = np.arctan(sinus_hilbert.real/sinus_hilbert.imag)*2*np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
# plt.plot(t,phi0)
# plt.plot(t,faza)
plt.plot(t,faza_prim)
plt.show()
68/60:
omega = 16
t, sinus1 = sin(omega, 0 ,64 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza_prim = np.arctan(sinus_hilbert.imag/sinus_hilbert.real)*2*np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
# plt.plot(t,phi0)
# plt.plot(t,faza)
plt.plot(t,faza_prim)
plt.show()
68/61:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza_prim = np.arctan(sinus_hilbert.imag/sinus_hilbert.real)*2*np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
# plt.plot(t,phi0)
# plt.plot(t,faza)
plt.plot(t,faza_prim)
plt.show()
68/62:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
# faza_prim = np.arctan(sinus_hilbert.imag/sinus_hilbert.real)*2*np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0)
plt.plot(t,faza)
# plt.plot(t,faza_prim)
plt.show()
68/63:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
# faza_prim = np.arctan(sinus_hilbert.imag/sinus_hilbert.real)*2*np.pi
faza = np.angle(sinus_hilbert)
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0)
plt.plot(t,faza)
# plt.plot(t,faza_prim)
plt.show()
68/64:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
# faza_prim = np.arctan(sinus_hilbert.imag/sinus_hilbert.real)*2*np.pi
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0)
plt.plot(t,faza)
# plt.plot(t,faza_prim)
plt.show()
68/65:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0)
plt.plot(t,faza)
plt.show()
68/66:
f = 32
Fs = 128
sinus = sin(     f     ,     0     ,     Fs    ,    T     )
68/67:
f = 32
Fs = 128
sinus = sin(     f     ,     0     ,     Fs    ,    1     )
68/68:
omega = 16
t, sinus1 = sin(omega, 0 ,128 , 1)
sinus_hilbert = ss.hilbert(sinus1)
obwiednia_sinus = np.abs(sinus_hilbert)
plt.plot(t,sinus1)
plt.plot(t,obwiednia_sinus)
plt.show()
faza = np.unwrap(np.angle(sinus_hilbert))
faza2 = omega*2*np.pi * t
phi0 = faza - faza2
plt.plot(t,phi0,label='phi0')
plt.plot(t,faza,label="faza z hilberta")
plt.legend()
plt.show()
68/69:
f = 32
Fs = 128
t, sinus = sin(f, 0, Fs, 1)
t, sinus2 = sin(f, np.pi/4, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = np.abs(faza1-faza2)
plt.plot(t,faza1)
plt.plot(t,faza2)
plt.plot(t,delta_faza)
plt.show()
68/70:
f = 32
Fs = 128
t, sinus = sin(f, 0, Fs, 1)
t, sinus2 = sin(f, np.pi/4, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = faza1-faza2
plt.plot(t,faza1)
plt.plot(t,faza2)
plt.plot(t,delta_faza)
plt.show()
68/71:
f = 32
Fs = 128
t, sinus = sin(f, 0, Fs, 1)
t, sinus2 = sin(f, np.pi/4, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = faza2-faza1
plt.plot(t,faza1)
plt.plot(t,faza2)
plt.plot(t,delta_faza)
plt.show()
68/72:
f = 32
Fs = 128
t, sinus = sin(f, 0, Fs, 1)
t, sinus2 = sin(f, np.pi/4, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = faza2-faza1
plt.plot(t,faza1,label='faza sinusa1')
plt.plot(t,faza2,label='faza sinusa2')
plt.plot(t,delta_faza,label='różnica faz')
plt.legend()
plt.show()
68/73:
f = 32
Fs = 128
t, sinus = sin(f, 0, Fs, 1)
t, sinus2 = sin(f, np.pi/4, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = faza2-faza1
# plt.plot(t,faza1,label='faza sinusa1')
# plt.plot(t,faza2,label='faza sinusa2')
plt.plot(t,delta_faza,label='różnica faz')
plt.legend()
plt.show()
68/74:
f = 32
Fs = 128
t, sinus = sin(f, 0, Fs, 1)
t, sinus2 = sin(f, np.pi/4, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = faza2-faza1
# plt.plot(t,faza1,label='faza sinusa1')
# plt.plot(t,faza2,label='faza sinusa2')
plt.plot(t,delta_faza,label='różnica faz')
ply.ylim(-4,4)
plt.legend()
plt.show()
68/75:
f = 32
Fs = 128
t, sinus = sin(f, 0, Fs, 1)
t, sinus2 = sin(f, np.pi/4, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = faza2-faza1
# plt.plot(t,faza1,label='faza sinusa1')
# plt.plot(t,faza2,label='faza sinusa2')
plt.plot(t,delta_faza,label='różnica faz')
plt.ylim(-4,4)
plt.legend()
plt.show()
68/76:
f = 32
Fs = 128
t, sinus = sin(f, 0, Fs, 1)
t, sinus2 = sin(f, np.pi/4, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = faza2-faza1
# plt.plot(t,faza1,label='faza sinusa1')
# plt.plot(t,faza2,label='faza sinusa2')
plt.plot(t,delta_faza,label='różnica faz')
plt.ylim(-4,4)
plt.legend()
plt.show()
print(np.mean(delta_faza))
68/77:
f = 32
Fs = 128
t, sinus = sin(f, 0, Fs, 1)
t, sinus2 = sin(f, np.pi/4, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = faza2-faza1
# plt.plot(t,faza1,label='faza sinusa1')
# plt.plot(t,faza2,label='faza sinusa2')
plt.plot(t,delta_faza,label='różnica faz')
plt.ylim(-4,4)
plt.legend()
plt.show()
print(np.mean(delta_faza),np.pi/4)
68/78:
f = 32
Fs = 128
t, sinus = sin(f, 0, Fs, 1)
t, sinus2 = sin(f, np.pi/4, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = faza2-faza1
# plt.plot(t,faza1,label='faza sinusa1')
# plt.plot(t,faza2,label='faza sinusa2')
plt.plot(t,delta_faza,label='różnica faz')
plt.ylim(-4,4)
plt.legend()
plt.show()
print(np.mean(delta_faza)-np.pi/4)
68/79:
plt.plot(t,s_hil)
plt.plot(t,s2_hil)
plt.show()
68/80:
plt.plot(t,s_hil)
plt.plot(t,s2_hil)
plt.xlim(0,0.2)
plt.show()
68/81:
f = 32
Fs = 128
t, sinus = sin(f, np.pi/5, Fs, 1)
t, sinus2 = sin(f, -np.pi/3, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = faza2-faza1
# plt.plot(t,faza1,label='faza sinusa1')
# plt.plot(t,faza2,label='faza sinusa2')
plt.plot(t,delta_faza,label='różnica faz')
plt.ylim(-4,4)
plt.legend()
plt.show()
print(np.mean(delta_faza)-np.pi/4)
68/82:
f = 32
Fs = 128
t, sinus = sin(f, np.pi/5, Fs, 1)
t, sinus2 = sin(f, -np.pi/3, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = faza2-faza1
# plt.plot(t,faza1,label='faza sinusa1')
# plt.plot(t,faza2,label='faza sinusa2')
plt.plot(t,delta_faza,label='różnica faz')
plt.ylim(-4,4)
plt.legend()
plt.show()
print(np.mean(delta_faza))
68/83:
plt.plot(t,s_hil)
plt.plot(t,s2_hil)
plt.xlim(0,0.2)
plt.show()
68/84:
f = 32
Fs = 128
t, sinus = sin(f, 0, Fs, 1)
t, sinus2 = sin(f, np.pi/4, Fs, 1)
s_hil = ss.hilbert(sinus)
s2_hil = ss.hilbert(sinus2)
faza1 = np.unwrap(np.angle(s_hil))
faza2 = np.unwrap(np.angle(s2_hil))
delta_faza = faza2-faza1
# plt.plot(t,faza1,label='faza sinusa1')
# plt.plot(t,faza2,label='faza sinusa2')
plt.plot(t,delta_faza,label='różnica faz')
plt.ylim(-4,4)
plt.legend()
plt.show()
print(np.mean(delta_faza)-np.pi/4)
68/85:
sin_sum = sin(30,0,128,1)[1] + sin(32,0,128,1)[1]
t = np.arange(0,1,1/128)
ss_hil = ss.hilbert(sin_sum)
obw = np.abs(ss_hil)
plt.plot(t,obw)
plt.show()
68/86:
sin_sum = sin(30,0,128,1)[1] + sin(32,0,128,1)[1]
t = np.arange(0,1,1/128)
ss_hil = ss.hilbert(sin_sum)
obw = np.abs(ss_hil)
plt.plot(t,obw)
plt.plot(t,sin_sum)
plt.show()
68/87:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * fs)
plt.plot(instantaneous_frequency)
plt.show()
68/88:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
plt.plot(instantaneous_frequency)
plt.show()
68/89:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
plt.plot(t[1:],instantaneous_frequency)
plt.show()
68/90:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase)) #/(2.0*np.pi) * 128)
plt.plot(t[1:],instantaneous_frequency)
plt.show()
68/91:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase)/(2*np.pi)) #/(2.0*np.pi) * 128)
plt.plot(t[1:],instantaneous_frequency)
plt.show()
68/92:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase)) #/(2.0*np.pi) * 128)
plt.plot(t[1:],instantaneous_frequency)
plt.show()
68/93:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase)) #/(2.0*np.pi) * 128)
plt.plot(t[1:],instantaneous_frequency)
plt.show()
print(np.mean(instantaneous_frequency))
68/94:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
plt.plot(t[1:],instantaneous_frequency)
plt.show()
print(np.mean(instantaneous_frequency))
68/95:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
plt.plot(t[1:],instantaneous_frequency)
plt.ylim(-100,100)
plt.show()
print(np.mean(instantaneous_frequency))
68/96:
sin_sum = sin(30,0,128,1)[1] + sin(32,0,128,1)[1]
t = np.arange(0,1,1/128)
ss_hil = ss.hilbert(sin_sum)
instantaneous_phase = np.unwrap(np.angle(ss_hil))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * fs)
obw = np.abs(ss_hil)
plt.plot(t,obw)
plt.plot(t,sin_sum)
plt.show()
print(np.mean(instantaneous_frequency))
68/97:
sin_sum = sin(30,0,128,1)[1] + sin(32,0,128,1)[1]
t = np.arange(0,1,1/128)
ss_hil = ss.hilbert(sin_sum)
instantaneous_phase = np.unwrap(np.angle(ss_hil))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
obw = np.abs(ss_hil)
plt.plot(t,obw)
plt.plot(t,sin_sum)
plt.show()
print(np.mean(instantaneous_frequency))
68/98:
sin_sum = sin(30,0,128,1)[1] + sin(32,0,128,1)[1]
t = np.arange(0,1,1/128)
ss_hil = ss.hilbert(sin_sum)
instantaneous_phase = np.unwrap(np.angle(ss_hil))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
obw = np.abs(ss_hil)
plt.plot(t,obw)
plt.plot(t,sin_sum)
plt.show()
print(np.mean(instantaneous_frequency) , instantaneous_frequency[0])
68/99:
sin_sum = sin(30,0,128,1)[1] + sin(32,0,128,1)[1]
t = np.arange(0,1,1/128)
ss_hil = ss.hilbert(sin_sum)
instantaneous_phase = np.unwrap(np.angle(ss_hil))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
obw = np.abs(ss_hil)
plt.plot(t,obw)
plt.plot(t,sin_sum)
plt.show()
print(np.mean(instantaneous_frequency) , instantaneous_frequency[0] , instantaneous_frequency[-1])
68/100:
sin_sum = sin(30,0,128,1)[1] + sin(32,0,128,1)[1]
t = np.arange(0,1,1/128)
ss_hil = ss.hilbert(sin_sum)
instantaneous_phase = np.unwrap(np.angle(ss_hil))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
obw = np.abs(ss_hil)
plt.plot(t,obw)
plt.plot(t,sin_sum)
plt.show()
plt.plot(t,instantaneous_frequency)
plt.ylim(-50,50)
plt.show()
print(np.mean(instantaneous_frequency) , instantaneous_frequency[0] , instantaneous_frequency[-1])
68/101:
sin_sum = sin(30,0,128,1)[1] + sin(32,0,128,1)[1]
t = np.arange(0,1,1/128)
ss_hil = ss.hilbert(sin_sum)
instantaneous_phase = np.unwrap(np.angle(ss_hil))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
obw = np.abs(ss_hil)
plt.plot(t,obw)
plt.plot(t,sin_sum)
plt.show()
plt.plot(t[1:],instantaneous_frequency)
plt.ylim(-50,50)
plt.show()
print(np.mean(instantaneous_frequency) , instantaneous_frequency[0] , instantaneous_frequency[-1])
68/102:
sin_sum = sin(30,0,128,1)[1] + sin(32,0,128,1)[1]
t = np.arange(0,1,1/128)
ss_hil = ss.hilbert(sin_sum)
instantaneous_phase = np.unwrap(np.angle(ss_hil))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
obw = np.abs(ss_hil)
plt.plot(t,obw)
plt.plot(t,sin_sum)
plt.show()
plt.plot(t[1:],instantaneous_frequency)
plt.ylim(-50,50)
plt.show()
print(min(instantaneous_frequency[:60]) , min(instantaneous_frequency[60:]))

print(np.mean(instantaneous_frequency) , instantaneous_frequency[0] , instantaneous_frequency[-1])
68/103:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
A1 = np.abs(ss.hilbert(s1))
A2 = np.abs(ss.hilbert(s2))
plt.plot(t,A1)
plt.plot(t,A2)
# plt.plot(t,A1+A2)
plt.show()
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
# plt.plot(t[1:],instantaneous_frequency)
# plt.ylim(-100,100)
# plt.show()
# print(np.mean(instantaneous_frequency))
68/104:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
A1 = np.abs(ss.hilbert(s1))
A2 = np.abs(ss.hilbert(s2))
plt.ylim(-5,5)
plt.plot(t,A1)
plt.plot(t,A2)
# plt.plot(t,A1+A2)
plt.show()
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
# plt.plot(t[1:],instantaneous_frequency)
# plt.ylim(-100,100)
# plt.show()
# print(np.mean(instantaneous_frequency))
68/105:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
A1 = np.abs(ss.hilbert(s1))
A2 = np.abs(ss.hilbert(s2))
plt.ylim(-5,5)
plt.plot(t,A1)
# plt.plot(t,A2)
# plt.plot(t,A1+A2)
plt.show()
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
# plt.plot(t[1:],instantaneous_frequency)
# plt.ylim(-100,100)
# plt.show()
# print(np.mean(instantaneous_frequency))
68/106:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
A1 = np.abs(ss.hilbert(s1))
A2 = np.abs(ss.hilbert(s2))
plt.ylim(-5,5)
# plt.plot(t,A1)
plt.plot(t,A2)
# plt.plot(t,A1+A2)
plt.show()
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
# plt.plot(t[1:],instantaneous_frequency)
# plt.ylim(-100,100)
# plt.show()
# print(np.mean(instantaneous_frequency))
68/107:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
A1 = np.abs(ss.hilbert(s1))
A2 = np.abs(ss.hilbert(s2))
plt.ylim(-5,5)
plt.plot(t,A1)
plt.plot(t,A2)
# plt.plot(t,A1+A2)
plt.show()
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
# plt.plot(t[1:],instantaneous_frequency)
# plt.ylim(-100,100)
# plt.show()
# print(np.mean(instantaneous_frequency))
69/1:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
A1 = np.abs(ss.hilbert(s1))
A2 = np.abs(ss.hilbert(s2))
plt.ylim(-5,5)
plt.plot(t,A1)
plt.plot(t,A2)
# plt.plot(t,A1+A2)
plt.show()
# instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
# instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
# plt.plot(t[1:],instantaneous_frequency)
# plt.ylim(-100,100)
# plt.show()
# print(np.mean(instantaneous_frequency))
69/2:
import numpy as np
import matplotlib.pyplot as plt
import scipy.signal as ss
69/3:
def sin(f, phi, Fs, T):
    t = np.arange(0,T,1/Fs)
    sinus = np.sin(2*np.pi*t*f + phi)
    return t, sinus

def gabor(t0, sigma, omega, Fs, T):
    t = np.arange(0,T,1/Fs)
    gabor = np.exp(-(t-t0)**2/(2*sigma**2)) * np.cos(2*np.pi*omega*(t-t0))
    return t, gabor
69/4:
t, gabor1 = gabor(1, 0.1, 16, 128, 2)
plt.plot(t,gabor1)
plt.show()
69/5:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
A1 = np.abs(ss.hilbert(s1))
A2 = np.abs(ss.hilbert(s2))
plt.ylim(-5,5)
plt.plot(t,A1)
plt.plot(t,A2)
# plt.plot(t,A1+A2)
plt.show()
# instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
# instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
# plt.plot(t[1:],instantaneous_frequency)
# plt.ylim(-100,100)
# plt.show()
# print(np.mean(instantaneous_frequency))
69/6:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
A1 = np.abs(ss.hilbert(s1))
A2 = np.abs(ss.hilbert(s2))
plt.ylim(-5,5)
plt.plot(t,A1)
# plt.plot(t,A2)
# plt.plot(t,A1+A2)
plt.show()
# instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
# instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
# plt.plot(t[1:],instantaneous_frequency)
# plt.ylim(-100,100)
# plt.show()
# print(np.mean(instantaneous_frequency))
69/7:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
A1 = np.abs(ss.hilbert(s1))
A2 = np.abs(ss.hilbert(s2))
plt.ylim(-5,5)
plt.plot(t,A1+A2)
# plt.plot(t,A2)
# plt.plot(t,A1+A2)
plt.show()
# instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
# instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
# plt.plot(t[1:],instantaneous_frequency)
# plt.ylim(-100,100)
# plt.show()
# print(np.mean(instantaneous_frequency))
69/8:
t,s1 = sin(30,0,128,1) 
t,s2 = sin(32,0,128,1)
instantaneous_phase = np.unwrap(np.angle(ss.hilbert(s1)))
instantaneous_frequency = (np.diff(instantaneous_phase) /(2.0*np.pi) * 128)
plt.plot(t[1:],instantaneous_frequency)
plt.ylim(-100,100)
plt.show()
print(np.mean(instantaneous_frequency))
70/1:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return a.to_bytes(2,byteorder=sys.byteorder)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = (3).to_bytes(1,byteorder=sys.byteorder) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = int(period - bright)
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = (4).to_bytes(1,byteorder=sys.byteorder) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
 
        self.send(str)
70/2: sp.blinkSSVEP([10, 0],1,1)
70/3:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return a.to_bytes(2,byteorder=sys.byteorder)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = (3).to_bytes(1,byteorder=sys.byteorder) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = int(period - bright)
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = (4).to_bytes(1,byteorder=sys.byteorder) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
 
        self.send(str)
70/4: sp.blinkSSVEP([10, 0],1,1)
70/5: import SerialPort as sp
70/6: SerialPort.blinkSSVEP([10, 0],1,1)
70/7:
sp = SeriaPort()
sp.blinkSSVEP([10, 0],1,1)
70/8:
sp = SerialPort()
sp.blinkSSVEP([10, 0],1,1)
70/9:
sp = SerialPort('/dev/ttyUSB0')
sp.blinkSSVEP([10, 0],1,1)
70/10:
sp = SerialPort('/dev/ttyUSB0')
sp.open()
sp.blinkSSVEP([10, 0],1,1)
71/1:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return a.to_bytes(2,byteorder=sys.byteorder)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = (3).to_bytes(1,byteorder=sys.byteorder) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = int(period - bright)
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = (4).to_bytes(1,byteorder=sys.byteorder) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
 
        self.send(str)
71/2:
sp = SerialPort('/dev/ttyUSB0')
sp.open()
sp.blinkSSVEP([10, 0],1,1)
71/3:
k=0
while k < 1000000:
    sp.blinkP300([1000, 1000])
    #time.sleep(1)
    k += 1
71/4:
sp = SerialPort('/dev/ttyUSB0')
sp.open()
sp.blinkSSVEP([10, 0],1,1)
73/1:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return a.to_bytes(2,byteorder=sys.byteorder)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = (3).to_bytes(1,byteorder=sys.byteorder) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = int(period - bright)
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = (4).to_bytes(1,byteorder=sys.byteorder) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
 
        self.send(str)
73/2:
sp = SerialPort('/dev/ttyUSB0')
sp.open()
sp.blinkSSVEP([10, 0],1,1)
73/3:
sp = SerialPort('/dev/ttyUSB1')
sp.open()
sp.blinkSSVEP([10, 0],1,1)
73/4:
sp = SerialPort('/dev/ttyUSB1')
sp.open()
sp.blinkSSVEP([10, 0],0,0)
73/5:
sp = SerialPort('/dev/ttyUSB1')
sp.open()
sp.blinkSSVEP([10, 0],1,1)
72/1:
import SerialPortMy as SP
import time
import numpy as np
72/2: sp = SP.SerialPortMy('/dev/ttyUSB0')
72/3: sp = SP.SerialPortMy('/dev/ttyUSB1')
72/4: sp.open()
72/5:
k=0
while k < 1000000:
    sp.blinkP300([1000, 1000])
    #time.sleep(1)
    k += 1
72/6:
k=0
while k < 1000000:
    sp.blinkP300([1000, 1000])
    time.sleep(1)
    k += 1
72/7: sp.blinkP300([0, 0])
72/8:
k=0
while k < 100:
    sleeptime = 1 + np.random.rand()*0.2-0.1
    sp.blinkP300([0, 20])
    time.sleep(sleeptime)
    k += 1

time.sleep(120)
k=0
while k < 100:
    sleeptime = 1 + np.random.rand()*0.2-0.1
    sp.blinkP300([20, 20])
    time.sleep(sleeptime)
    k += 1
72/9:
k=0
while k < 1000000:
    sp.blinkP300([1000, 1000])
    time.sleep(1)
    k += 1
72/10:
k=0
while k < 60:
    j = 0
    while j < 15:
        sleeptime = 0.5
        sp.blinkP300([0, 20])
        time.sleep(sleeptime)
        j += 1
    time.sleep(10)
    k += 1
72/11:
import SerialPortMy as SP
import time
import numpy as np
72/12: sp = SP.SerialPortMy('/dev/ttyUSB0')
72/13: sp.open()
72/14:
k=0
while k < 1000000:
    sp.blinkP300([1000, 1000])
    time.sleep(1)
    k += 1
72/15:
import SerialPortMy as SP
import time
import numpy as np
74/1:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return a.to_bytes(2,byteorder=sys.byteorder)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = (3).to_bytes(1,byteorder=sys.byteorder) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = int(period - bright)
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = (4).to_bytes(1,byteorder=sys.byteorder) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
 
        self.send(str)
74/2:
sp = SerialPort('/dev/ttyUSB1')
sp.open()
sp.blinkSSVEP([10, 0],1,1)
74/3:
sp = SerialPort('/dev/ttyUSB0')
sp.open()
sp.blinkSSVEP([10, 0],1,1)
74/4:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return a.to_bytes(2,byteorder=sys.byteorder)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = (3).to_bytes(1,byteorder=sys.byteorder) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = int(period - bright)
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = (4).to_bytes(1,byteorder=sys.byteorder) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
 
        self.send(str)
74/5:
sp = SerialPort('/dev/ttyUSB0')
sp.open()
sp.blinkSSVEP([10, 0],1,1)
74/6: sp.blinkP300([0,0])
74/7: sp.blinkP300([1,1])
74/8: sp.blinkP300([1,1])
74/9: import numpy as np
74/10:
for i in range(0, 15):
    temp_freqs = np.random.shuffle(freqs.copy())
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        print(freq)
74/11: freqs = np.array([4, 7, 10, 13, 16, 20, 25, 30, 35, 40])
74/12:
for i in range(0, 15):
    temp_freqs = np.random.shuffle(freqs.copy())
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        print(freq)
74/13:
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        print(freq)
74/14:
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    print(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
#         print(freq)
74/15:
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    print(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        print(temp_freqs)
#         print(freq)
74/16:
import numpy as np
import time
74/17:
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    print(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,7)
        print(sleep_time)
        time.sleep(sleep_time)
74/18:
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
#         time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,7)
        print(sleep_time)
        time.sleep(sleep_time)
74/19:
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
#         time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,7)
        print(sleep_time)
#         time.sleep(sleep_time)
74/20:
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        print(sleep_time)
        time.sleep(sleep_time)
74/21:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
#         time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        print(sleep_time)
        text_file.write("{freq},{sleep_time}")
#         time.sleep(sleep_time)
74/22:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
#         time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        print(sleep_time)
        text_file.write("{freq},{sleep_time}")
#         time.sleep(sleep_time)
text_file.close()
74/23:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
#         time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        print(sleep_time)
        text_file.write(f"{freq},{sleep_time} \n")
#         time.sleep(sleep_time)
text_file.close()
74/24:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko\n")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
#         time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        print(sleep_time)
        text_file.write(f"{freq},{sleep_time}\n")
#         time.sleep(sleep_time)
text_file.close()
74/25:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko\n")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
#         time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        print(sleep_time)
        text_file.write(f"{freq},{sleep_time}\n")
#         time.sleep(sleep_time)
# text_file.close()
74/26:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko\n")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{freq},{sleep_time}\n")
        print(f"{freq},{sleep_time})
        time.sleep(sleep_time)
text_file.close()
74/27:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko\n")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{freq},{sleep_time}\n")
        print(f"{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
74/28:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko\n")
print("Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{freq},{sleep_time}\n")
        print(f"{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
74/29:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko\n")
print("Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{freq},{sleep_time}\n")
        print(f"{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
74/30: sp.blink300([0, 0])
74/31: sp.blinkP300([0, 0])
74/32:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko\n")
print("Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{freq},{sleep_time}\n")
        print(f"{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
74/33: sp.blinkP300([0, 0])
74/34:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko\n")
print("Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{freq},{sleep_time}\n")
        print(f"{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
74/35: sp.blinkP300([0, 0])
74/36:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko\n")
print("Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{freq},{sleep_time}\n")
        print(f"{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
   1:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return a.to_bytes(2,byteorder=sys.byteorder)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = (3).to_bytes(1,byteorder=sys.byteorder) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = int(period - bright)
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = (4).to_bytes(1,byteorder=sys.byteorder) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
 
        self.send(str)
   2:
# -*- coding: cp1250 -*-
import serial
import logging
import sys
import os
 
 
def to_hex_word(a):
    '''encodes a decimal number hexadecimally on two bytes'''
    return a.to_bytes(2,byteorder=sys.byteorder)
 
class SerialPort(object):
    def __init__(self, port_name):
        import serial
        try:
            self.port = serial.Serial(
                port=port_name,
                baudrate=9600,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                xonxoff=False
                )
        except serial.SerialException as e:
            print("Nieprawidłowa nazwa portu lub port zajęty.")
            raise e
        self.close()
 
    def open(self):
        self.port.open()
 
    def close(self):
        self.port.close()
 
    def send(self, value):
        self.port.write(value)
 
    def blinkSSVEP(self,d, p1, p2):
        '''
        d = list of frequencies;
        p1:p2 = ratio LED_on_time/LED_off_time
        if you want i-th LED to be OFF all the time send  d[i] = 0
        if you want i-th LED to be ON all the time send  d[i] = -1
        in these two cases p1 and p2 do not matter
        '''
        clock  = 62500
        factor = float(p1) / float(p1 + p2)
 
        str = (3).to_bytes(1,byteorder=sys.byteorder) # 'SSVEP_RUN'
 
        for i in range(len(d)):
            # i-th LED OFF
            if d[i] == 0:                       
                str += to_hex_word(0) + to_hex_word(255) 
            # i-th LED ON
            elif d[i] == -1:
                str += to_hex_word(255) + to_hex_word(0)
                #str = 'S'
                # i-th LED blinks d[i] times per second
                # p1:p2 = on_time:off_time in one blink
            else:
                period = clock/d[i]
                bright = int((clock/d[i]) * factor)
                dark = int(period - bright)
                str += to_hex_word(bright) + to_hex_word(dark)
 
        self.send(str)
 
    def blinkP300(self,d):
        clock  = 62500
        str = (4).to_bytes(1,byteorder=sys.byteorder) # 'P300_RUN'
 
        for i in range(len(d)):
            period = int(clock*d[i]/1000.0)
            str += to_hex_word(period)
 
        self.send(str)
   3:
sp = SerialPort('/dev/ttyUSB0')
sp.open()
sp.blinkSSVEP([10, 0],1,1)
   4:
import numpy as np
import time
   5: sp.blinkP300([0, 0])
   6:
import numpy as np
import time
   7: freqs = np.array([4, 7, 10, 13, 16, 20, 25, 30, 35, 40])
   8:
text_file = open("kolejnosc.csv", "w")
text_file.write("Częstość,Spanko\n")
print("Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{freq},{sleep_time}\n")
        print(f"{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
   9:
text_file = open("kolejnosc.csv", "w")
text_file.write("Index,Częstość,Spanko\n")
print("Index,Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{i*j+j},{freq},{sleep_time}\n")
        print(f"{i*j+j},{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
  10:
text_file = open("kolejnosc.csv", "w")
text_file.write("Index,Częstość,Spanko\n")
print("Index,Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{i*j+j},{freq},{sleep_time}\n")
        print(f"{i*j+j},{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
  11:  print(__)
  12:  print(__)
  13: Out[8]
  14: _8
  15:
print(_)
print(__)
print(___)
text_file = open("kolejnosc.csv", "w")
text_file.write("Index,Częstość,Spanko\n")
print("Index,Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{i*j+j},{freq},{sleep_time}\n")
        print(f"{i*j+j},{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
  16: print(Out[2])
  17: %history
  18: %history -o
  19: %history -o 10-15
  20:
timestamp = time.now()
text_file = open(f"kolejnosc_{timestamp}.csv", "w")
text_file.write("Index,Częstość,Spanko\n")
print("Index,Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{i*j+j},{freq},{sleep_time}\n")
        print(f"{i*j+j},{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
  21:
timestamp = time.time.now()
text_file = open(f"kolejnosc_{timestamp}.csv", "w")
text_file.write("Index,Częstość,Spanko\n")
print("Index,Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{i*j+j},{freq},{sleep_time}\n")
        print(f"{i*j+j},{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
  22:
import numpy as np
import time
import datetime
  23:
import numpy as np
import time
import datetime
  24:
timestamp = datetime.datetime.now()
text_file = open(f"kolejnosc_{timestamp}.csv", "w")
text_file.write("Index,Częstość,Spanko\n")
print("Index,Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{i*j+j},{freq},{sleep_time}\n")
        print(f"{i*j+j},{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
  25: sp.blinkP300([0, 0])
  26:
timestamp = datetime.datetime.now()
text_file = open(f"kolejnosc_{timestamp}.csv", "w")
text_file.write("Index,Częstość,Spanko\n")
print("Index,Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{i*j+j},{freq},{sleep_time}\n")
        print(f"{i*j+j},{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
  27: sp.blinkP300([0, 0])
  28:
timestamp = datetime.datetime.now()
text_file = open(f"kolejnosc_{timestamp}.csv", "w")
text_file.write("Index,Częstość,Spanko\n")
print("Index,Częstość,Spanko")
for i in range(0, 15):
    temp_freqs = freqs.copy()
    np.random.shuffle(temp_freqs)
    for j in range(0, len(freqs)):
        freq = temp_freqs[-1]
        temp_freqs = temp_freqs[:-1]
        sp.blinkSSVEP([freq, 0],1,1)
        time.sleep(5)
        sp.blinkP300([0,0])
        sleep_time = np.random.randint(3,8)
        text_file.write(f"{i*j+j},{freq},{sleep_time}\n")
        print(f"{i*j+j},{freq},{sleep_time}")
        time.sleep(sleep_time)
text_file.close()
  29: %history -f -f "historia_uno.txt"
  30: %history -g -f "historia_uno.txt"
  31: %history -g -o -f "historia_uno.txt"
  32: %history -g -o -f "historia_duo.txt"
  33: %hist -g -o -f "historia_3.txt"
